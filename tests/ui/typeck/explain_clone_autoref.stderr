error[E0308]: mismatched types
  --> $DIR/explain_clone_autoref.rs:9:5
   |
LL | fn clone_thing(nc: &NotClone) -> NotClone {
   |                                  -------- expected `NotClone` because of return type
LL |
LL |     nc.clone()
   |     ^^^^^^^^^^ expected `NotClone`, found `&NotClone`
   |
note: `NotClone` does not implement `Clone`, so `&NotClone` was cloned instead
  --> $DIR/explain_clone_autoref.rs:9:5
   |
LL |     nc.clone()
   |     ^^
note: the method clone is defined here
  --> $SRC_DIR/core/src/clone.rs:LL:COL
help: consider annotating `NotClone` with `#[derive(Clone)]`
   |
LL + #[derive(Clone)]
LL | struct NotClone;
   |

error[E0308]: mismatched types
  --> $DIR/explain_clone_autoref.rs:17:24
   |
LL |     let nc: NotClone = nc.clone();
   |             --------   ^^^^^^^^^^ expected `NotClone`, found `&NotClone`
   |             |
   |             expected due to this
   |
note: `NotClone` does not implement `Clone`, so `&NotClone` was cloned instead
  --> $DIR/explain_clone_autoref.rs:17:24
   |
LL |     let nc: NotClone = nc.clone();
   |                        ^^
note: the method clone is defined here
  --> $SRC_DIR/core/src/clone.rs:LL:COL
help: consider annotating `NotClone` with `#[derive(Clone)]`
   |
LL + #[derive(Clone)]
LL | struct NotClone;
   |

error[E0308]: mismatched types
  --> $DIR/explain_clone_autoref.rs:30:5
   |
LL | fn clone_thing3(nc: &NotClone) -> NotClone {
   |                                   -------- expected `NotClone` because of return type
...
LL |     nc
   |     ^^ expected `NotClone`, found `&NotClone`
   |
note: `NotClone` does not implement `Clone`, so `&NotClone` was cloned instead
  --> $DIR/explain_clone_autoref.rs:28:14
   |
LL |     let nc = nc.clone();
   |              ^^
help: consider annotating `NotClone` with `#[derive(Clone)]`
   |
LL + #[derive(Clone)]
LL | struct NotClone;
   |

error[E0308]: mismatched types
  --> $DIR/explain_clone_autoref.rs:40:5
   |
LL | fn clone_thing4(nc: &NotClone) -> NotClone {
   |                                   -------- expected `NotClone` because of return type
...
LL |     nc2
   |     ^^^ expected `NotClone`, found `&NotClone`
   |
note: `NotClone` does not implement `Clone`, so `&NotClone` was cloned instead
  --> $DIR/explain_clone_autoref.rs:37:14
   |
LL |     let nc = nc.clone();
   |              ^^
help: consider annotating `NotClone` with `#[derive(Clone)]`
   |
LL + #[derive(Clone)]
LL | struct NotClone;
   |

error[E0308]: mismatched types
  --> $DIR/explain_clone_autoref.rs:59:5
   |
LL | fn clone_thing5(nc: &NotClone) -> NotClone {
   |                                   -------- expected `NotClone` because of return type
...
LL |     nc3
   |     ^^^ expected `NotClone`, found `&NotClone`
   |
note: `NotClone` does not implement `Clone`, so `&NotClone` was cloned instead
  --> $DIR/explain_clone_autoref.rs:54:14
   |
LL |     let nc = nc.clone();
   |              ^^
help: consider annotating `NotClone` with `#[derive(Clone)]`
   |
LL + #[derive(Clone)]
LL | struct NotClone;
   |

error[E0308]: mismatched types
  --> $DIR/explain_clone_autoref.rs:69:5
   |
LL | fn clone_thing6(nc: &NotClone) -> NotClone {
   |                                   -------- expected `NotClone` because of return type
...
LL |     ret
   |     ^^^ expected `NotClone`, found `&NotClone`
   |
note: `NotClone` does not implement `Clone`, so `&NotClone` was cloned instead
  --> $DIR/explain_clone_autoref.rs:66:21
   |
LL |     let (ret, _) = (nc.clone(), 1);
   |                     ^^
help: consider annotating `NotClone` with `#[derive(Clone)]`
   |
LL + #[derive(Clone)]
LL | struct NotClone;
   |

error[E0308]: mismatched types
  --> $DIR/explain_clone_autoref.rs:78:5
   |
LL | fn clone_thing7(nc: Vec<&NotClone>) -> NotClone {
   |                                        -------- expected `NotClone` because of return type
...
LL |     ret
   |     ^^^ expected `NotClone`, found `&NotClone`
   |
note: `NotClone` does not implement `Clone`, so `&NotClone` was cloned instead
  --> $DIR/explain_clone_autoref.rs:76:15
   |
LL |     let ret = nc[0].clone();
   |               ^^^^^
help: consider annotating `NotClone` with `#[derive(Clone)]`
   |
LL + #[derive(Clone)]
LL | struct NotClone;
   |

error[E0308]: mismatched types
  --> $DIR/explain_clone_autoref.rs:90:5
   |
LL | fn clone_thing8(nc: &NotClone) -> NotClone {
   |                                   -------- expected `NotClone` because of return type
...
LL |     ret
   |     ^^^ expected `NotClone`, found `&NotClone`
   |
note: `NotClone` does not implement `Clone`, so `&NotClone` was cloned instead
  --> $DIR/explain_clone_autoref.rs:86:17
   |
LL |         let a = nc.clone();
   |                 ^^
help: consider annotating `NotClone` with `#[derive(Clone)]`
   |
LL + #[derive(Clone)]
LL | struct NotClone;
   |

error[E0308]: mismatched types
  --> $DIR/explain_clone_autoref.rs:100:5
   |
LL | fn clone_thing9(nc: &NotClone) -> NotClone {
   |                                   -------- expected `NotClone` because of return type
...
LL |     ret
   |     ^^^ expected `NotClone`, found `&NotClone`
   |
note: `NotClone` does not implement `Clone`, so `&NotClone` was cloned instead
  --> $DIR/explain_clone_autoref.rs:97:17
   |
LL |     let cl = || nc.clone();
   |                 ^^
help: consider annotating `NotClone` with `#[derive(Clone)]`
   |
LL + #[derive(Clone)]
LL | struct NotClone;
   |

error[E0308]: mismatched types
  --> $DIR/explain_clone_autoref.rs:112:6
   |
LL |     (a, b)
   |      ^ expected `NotClone`, found `&NotClone`
   |
note: `NotClone` does not implement `Clone`, so `&NotClone` was cloned instead
  --> $DIR/explain_clone_autoref.rs:107:17
   |
LL |         let a = nc.clone();
   |                 ^^
help: consider annotating `NotClone` with `#[derive(Clone)]`
   |
LL + #[derive(Clone)]
LL | struct NotClone;
   |

error[E0308]: mismatched types
  --> $DIR/explain_clone_autoref.rs:112:9
   |
LL |     (a, b)
   |         ^ expected `NotClone`, found `&NotClone`
   |
note: `NotClone` does not implement `Clone`, so `&NotClone` was cloned instead
  --> $DIR/explain_clone_autoref.rs:109:13
   |
LL |         (a, nc.clone())
   |             ^^
help: consider annotating `NotClone` with `#[derive(Clone)]`
   |
LL + #[derive(Clone)]
LL | struct NotClone;
   |

error[E0308]: mismatched types
  --> $DIR/explain_clone_autoref.rs:128:5
   |
LL | fn clone_thing11(nc: &NotClone) -> NotClone {
   |                                    -------- expected `NotClone` because of return type
...
LL |     a
   |     ^ expected `NotClone`, found `&NotClone`
   |
note: `NotClone` does not implement `Clone`, so `&NotClone` was cloned instead
  --> $DIR/explain_clone_autoref.rs:123:17
   |
LL |         let a = nc.clone();
   |                 ^^
help: consider annotating `NotClone` with `#[derive(Clone)]`
   |
LL + #[derive(Clone)]
LL | struct NotClone;
   |

error: aborting due to 12 previous errors

For more information about this error, try `rustc --explain E0308`.
