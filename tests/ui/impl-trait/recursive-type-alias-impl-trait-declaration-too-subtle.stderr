error[E0053]: method `eq` has an incompatible type for trait
  --> $DIR/recursive-type-alias-impl-trait-declaration-too-subtle.rs:10:30
   |
LL |     type Foo = impl PartialEq<(Foo, i32)>;
   |                -------------------------- the found opaque type
...
LL |         fn eq(&self, _other: &(Foo, i32)) -> bool {
   |                              ^^^^^^^^^^^ expected `a::Bar`, found opaque type
   |
   = note: expected signature `fn(&a::Bar, &(a::Bar, _)) -> _`
              found signature `fn(&a::Bar, &(a::Foo, _)) -> _`
help: change the parameter type to match the trait
   |
LL |         fn eq(&self, _other: &(a::Bar, i32)) -> bool {
   |                              ~~~~~~~~~~~~~~

error[E0053]: method `eq` has an incompatible type for trait
  --> $DIR/recursive-type-alias-impl-trait-declaration-too-subtle.rs:25:30
   |
LL |     type Foo = impl PartialEq<(Foo, i32)>;
   |                -------------------------- the expected opaque type
...
LL |         fn eq(&self, _other: &(Bar, i32)) -> bool {
   |                              ^^^^^^^^^^^ expected opaque type, found `b::Bar`
   |
   = note: expected signature `fn(&b::Bar, &(b::Foo, _)) -> _`
              found signature `fn(&b::Bar, &(b::Bar, _)) -> _`
note: this item must have the opaque type in its signature in order to be able to register hidden types
  --> $DIR/recursive-type-alias-impl-trait-declaration-too-subtle.rs:25:12
   |
LL |         fn eq(&self, _other: &(Bar, i32)) -> bool {
   |            ^^
help: change the parameter type to match the trait
   |
LL |         fn eq(&self, _other: &(b::Foo, i32)) -> bool {
   |                              ~~~~~~~~~~~~~~

error: aborting due to 2 previous errors

For more information about this error, try `rustc --explain E0053`.
