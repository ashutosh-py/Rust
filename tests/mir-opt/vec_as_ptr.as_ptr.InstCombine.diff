- // MIR for `as_ptr` before InstCombine
+ // MIR for `as_ptr` after InstCombine
  
  fn as_ptr(_1: &Vec<i32>) -> *const i32 {
      debug v => _1;
      let mut _0: *const i32;
      scope 1 (inlined Vec::<i32>::as_ptr) {
          debug self => _1;
          let mut _2: *mut i32;
          let mut _3: &alloc::raw_vec::RawVec<i32>;
          scope 2 (inlined alloc::raw_vec::RawVec::<i32>::ptr) {
              debug self => _3;
              let mut _5: std::ptr::NonNull<i32>;
              scope 3 (inlined Unique::<i32>::as_ptr) {
                  debug ((self: Unique<i32>).0: std::ptr::NonNull<i32>) => _5;
                  debug ((self: Unique<i32>).1: std::marker::PhantomData<i32>) => const PhantomData::<i32>;
                  scope 4 (inlined NonNull::<i32>::as_ptr) {
                      debug self => _5;
                      let mut _4: *const i32;
                  }
              }
          }
      }
  
      bb0: {
          StorageLive(_2);
          StorageLive(_3);
          _3 = &((*_1).0: alloc::raw_vec::RawVec<i32>);
          StorageLive(_5);
          _5 = ((((*_1).0: alloc::raw_vec::RawVec<i32>).0: std::ptr::Unique<i32>).0: std::ptr::NonNull<i32>);
          StorageLive(_4);
          _4 = (_5.0: *const i32);
          _2 = move _4 as *mut i32 (PtrToPtr);
          StorageDead(_4);
          StorageDead(_5);
          _0 = move _2 as *const i32 (PointerCoercion(MutToConstPointer));
          StorageDead(_3);
          StorageDead(_2);
          return;
      }
  }
  
