- // MIR for `slow_4_i` before SimplifyPowOfTwo
+ // MIR for `slow_4_i` after SimplifyPowOfTwo
  
  fn slow_4_i(_1: u32) -> i32 {
      debug a => _1;
      let mut _0: i32;
      let mut _2: u32;
+     let mut _3: (u32, bool);
+     let mut _4: bool;
+     let mut _5: bool;
+     let mut _6: i32;
+     let mut _7: u32;
+     let mut _8: i32;
+     let mut _9: i32;
+     let mut _10: bool;
+     let mut _11: bool;
  
      bb0: {
          StorageLive(_2);
          _2 = _1;
-         _0 = core::num::<impl i32>::pow(const 4_i32, move _2) -> [return: bb1, unwind continue];
+         _3 = CheckedMul(move _2, const 2_u32);
+         _4 = Lt((_3.0: u32), const 32_u32);
+         _5 = BitOr((_3.1: bool), _4);
+         _6 = _5 as i32 (IntToInt);
+         _7 = Shl(const 1_u32, (_3.0: u32));
+         _8 = _7 as i32 (IntToInt);
+         _0 = MulUnchecked(_8, _6);
+         _9 = Shr(_8, (_3.0: u32));
+         _10 = Eq(_8, _9);
+         _11 = BitOr(_10, _4);
+         assert(!_11, "attempt to compute `{} * {}`, which would overflow", const 1_u32, (_3.0: u32)) -> [success: bb1, unwind continue];
      }
  
      bb1: {
          StorageDead(_2);
          return;
      }
  }
  
