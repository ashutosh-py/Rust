- // MIR for `h` before Inline
+ // MIR for `h` after Inline
  
  fn h() -> () {
      let mut _0: ();
      let mut _1: !;
      let _2: (!, !);
+     let mut _3: fn() -> ! {sleep};
+     scope 1 (inlined call_twice::<!, fn() -> ! {sleep}>) {
+         debug f => _3;
+         let mut _4: &fn() -> ! {sleep};
+         let _5: !;
+         let mut _6: &fn() -> ! {sleep};
+         let mut _8: !;
+         scope 2 {
+             debug a => _5;
+             let _7: !;
+             scope 3 {
+                 debug b => _7;
+             }
+         }
+     }
  
      bb0: {
          StorageLive(_2);
-         _2 = call_twice::<!, fn() -> ! {sleep}>(sleep) -> unwind continue;
+         StorageLive(_3);
+         _3 = sleep;
+         StorageLive(_7);
+         StorageLive(_5);
+         StorageLive(_4);
+         _4 = &_3;
+         _5 = <fn() -> ! {sleep} as Fn<()>>::call(move _4, const ()) -> [return: bb1, unwind: bb5];
+     }
+ 
+     bb1: {
+         StorageDead(_4);
+         StorageLive(_6);
+         _6 = &_3;
+         _7 = <fn() -> ! {sleep} as Fn<()>>::call(move _6, const ()) -> [return: bb2, unwind: bb4];
+     }
+ 
+     bb2: {
+         StorageDead(_6);
+         StorageLive(_8);
+         _8 = move _5;
+         _2 = (move _8, _7);
+         StorageDead(_8);
+         StorageDead(_5);
+         drop(_3) -> [return: bb3, unwind continue];
+     }
+ 
+     bb3: {
+         unreachable;
+     }
+ 
+     bb4 (cleanup): {
+         drop(_5) -> [return: bb5, unwind terminate(cleanup)];
+     }
+ 
+     bb5 (cleanup): {
+         drop(_3) -> [return: bb6, unwind terminate(cleanup)];
+     }
+ 
+     bb6 (cleanup): {
+         resume;
      }
  }
  
