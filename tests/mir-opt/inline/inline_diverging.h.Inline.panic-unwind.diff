- // MIR for `h` before Inline
+ // MIR for `h` after Inline
  
  fn h() -> () {
      let mut _0: ();
      let _1: (!, !);
+     let mut _2: fn() -> ! {sleep};
+     scope 1 (inlined call_twice::<!, fn() -> ! {sleep}>) {
+         debug f => _2;
+         let mut _3: &fn() -> ! {sleep};
+         let _4: !;
+         let mut _5: &fn() -> ! {sleep};
+         let mut _7: !;
+         let mut _8: *mut fn() -> ! {sleep};
+         let mut _9: ();
+         scope 2 {
+             debug a => _4;
+             let _6: !;
+             scope 3 {
+                 debug b => _6;
+             }
+         }
+         scope 4 (inlined std::ptr::drop_in_place::<fn() -> ! {sleep}> - shim(None)) {
+         }
+     }
  
      bb0: {
          StorageLive(_1);
-         _1 = call_twice::<!, fn() -> ! {sleep}>(sleep) -> unwind continue;
+         StorageLive(_2);
+         _2 = sleep;
+         StorageLive(_6);
+         StorageLive(_8);
+         StorageLive(_9);
+         StorageLive(_4);
+         StorageLive(_3);
+         _3 = &_2;
+         _4 = <fn() -> ! {sleep} as Fn<()>>::call(move _3, const ()) -> [return: bb1, unwind: bb4];
+     }
+ 
+     bb1: {
+         StorageDead(_3);
+         StorageLive(_5);
+         _5 = &_2;
+         _6 = <fn() -> ! {sleep} as Fn<()>>::call(move _5, const ()) -> [return: bb2, unwind: bb3];
+     }
+ 
+     bb2: {
+         StorageDead(_5);
+         StorageLive(_7);
+         _7 = move _4;
+         _1 = (move _7, _6);
+         StorageDead(_7);
+         StorageDead(_4);
+         _8 = &raw mut _2;
+         unreachable;
+     }
+ 
+     bb3 (cleanup): {
+         drop(_4) -> [return: bb4, unwind terminate(cleanup)];
+     }
+ 
+     bb4 (cleanup): {
+         drop(_2) -> [return: bb5, unwind terminate(cleanup)];
+     }
+ 
+     bb5 (cleanup): {
+         resume;
      }
  }
  
