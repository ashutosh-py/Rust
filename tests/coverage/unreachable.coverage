   LL|       |#![feature(core_intrinsics)]
   LL|       |//@ edition: 2021
   LL|       |
   LL|       |// <https://github.com/rust-lang/rust/issues/116171>
   LL|       |// If we instrument a function for coverage, but all of its counter-increment
   LL|       |// statements are removed by MIR optimizations, LLVM will think it isn't
   LL|       |// instrumented and it will disappear from coverage maps and coverage reports.
   LL|       |// Most MIR opts won't cause this because they tend not to remove statements
   LL|       |// from bb0, but `UnreachablePropagation` can do so if it sees that bb0 ends
   LL|       |// with `TerminatorKind::Unreachable`.
   LL|       |
   LL|       |use std::hint::{black_box, unreachable_unchecked};
   LL|       |
   LL|       |static UNREACHABLE_CLOSURE: fn() = || unsafe { unreachable_unchecked() };
   LL|       |
   LL|       |fn unreachable_function() {
   LL|       |    unsafe { unreachable_unchecked() }
   LL|       |}
   LL|       |
   LL|       |// Use an intrinsic to more reliably trigger unreachable-propagation.
   LL|       |fn unreachable_intrinsic() {
   LL|       |    unsafe { std::intrinsics::unreachable() }
   LL|       |}
   LL|       |
   LL|      1|fn main() {
   LL|      1|    if black_box(false) {
   LL|      0|        UNREACHABLE_CLOSURE();
   LL|      1|    }
   LL|      1|    if black_box(false) {
   LL|      0|        unreachable_function();
   LL|      1|    }
   LL|      1|    if black_box(false) {
   LL|      0|        unreachable_intrinsic();
   LL|      1|    }
   LL|      1|}

