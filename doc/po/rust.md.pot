# SOME DESCRIPTIVE TITLE
# Copyright (C) YEAR The Rust Project Developers
# This file is distributed under the same license as the Rust package.
# FIRST AUTHOR <EMAIL@ADDRESS>, YEAR.
#
#, fuzzy
msgid ""
msgstr ""
"Project-Id-Version: Rust 0.9\n"
"POT-Creation-Date: 2014-01-08 11:30+0900\n"
"PO-Revision-Date: YEAR-MO-DA HO:MI+ZONE\n"
"Last-Translator: FULL NAME <EMAIL@ADDRESS>\n"
"Language-Team: LANGUAGE <LL@li.org>\n"
"Language: \n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=UTF-8\n"
"Content-Transfer-Encoding: 8bit\n"

#. type: Plain text
#: doc/complement-cheatsheet.md:112 doc/rust.md:2970
msgid "# Type system"
msgstr ""

#. type: Plain text
#: doc/guide-conditions.md:4 doc/guide-ffi.md:4 doc/guide-lifetimes.md:4
#: doc/guide-macros.md:4 doc/guide-rustpkg.md:4 doc/guide-tasks.md:4
#: doc/rust.md:4 doc/rustpkg.md:4 doc/tutorial.md:4
msgid "# Introduction"
msgstr ""

#. type: Plain text
#: doc/guide-macros.md:325 doc/rust.md:2567
msgid "~~~~"
msgstr ""

#. type: Plain text
#: doc/guide-tasks.md:520 doc/rust.md:2384
msgid "# } ~~~~"
msgstr ""

#. type: Plain text
#: doc/rust.md:2
msgid "% Rust Reference Manual"
msgstr ""

#. type: Plain text
#: doc/rust.md:7
msgid ""
"This document is the reference manual for the Rust programming language. It "
"provides three kinds of material:"
msgstr ""

#. type: Bullet: '  - '
#: doc/rust.md:15
msgid ""
"Chapters that formally define the language grammar and, for each construct, "
"informally describe its semantics and give examples of its use."
msgstr ""

#. type: Bullet: '  - '
#: doc/rust.md:15
msgid ""
"Chapters that informally describe the memory model, concurrency model, "
"runtime services, linkage model and debugging facilities."
msgstr ""

#. type: Bullet: '  - '
#: doc/rust.md:15
msgid ""
"Appendix chapters providing rationale and references to languages that "
"influenced the design."
msgstr ""

#. type: Plain text
#: doc/rust.md:19
msgid ""
"This document does not serve as a tutorial introduction to the language. "
"Background familiarity with the language is assumed. A separate [tutorial] "
"document is available to help acquire such background familiarity."
msgstr ""

#. type: Plain text
#: doc/rust.md:24
msgid ""
"This document also does not serve as a reference to the [standard] or "
"[extra] libraries included in the language distribution. Those libraries are "
"documented separately by extracting documentation attributes from their "
"source code."
msgstr ""

#. type: Plain text
#: doc/rust.md:28
msgid ""
"[tutorial]: tutorial.html [standard]: std/index.html [extra]: extra/index."
"html"
msgstr ""

#. type: Plain text
#: doc/rust.md:30 doc/rustpkg.md:8
msgid "## Disclaimer"
msgstr ""

#. type: Plain text
#: doc/rust.md:34
msgid ""
"Rust is a work in progress. The language continues to evolve as the design "
"shifts and is fleshed out in working code. Certain parts work, certain parts "
"do not, certain parts will be removed or changed."
msgstr ""

#. type: Plain text
#: doc/rust.md:39
msgid ""
"This manual is a snapshot written in the present tense. All features "
"described exist in working code unless otherwise noted, but some are quite "
"primitive or remain to be further modified by planned work. Some may be "
"temporary. It is a *draft*, and we ask that you not take anything you read "
"here as final."
msgstr ""

#. type: Plain text
#: doc/rust.md:43
msgid ""
"If you have suggestions to make, please try to focus them on *reductions* to "
"the language: possible features that can be combined or omitted. We aim to "
"keep the size and complexity of the language under control."
msgstr ""

#. type: Plain text
#: doc/rust.md:52
msgid ""
"> **Note:** The grammar for Rust given in this document is rough and > very "
"incomplete; only a modest number of sections have accompanying grammar > "
"rules. Formalizing the grammar accepted by the Rust parser is ongoing work, "
"> but future versions of this document will contain a complete > grammar. "
"Moreover, we hope that this grammar will be extracted and verified > as "
"LL(1) by an automated grammar-analysis tool, and further tested against the "
"> Rust sources. Preliminary versions of this automation exist, but are not "
"yet > complete."
msgstr ""

#. type: Plain text
#: doc/rust.md:54
msgid "# Notation"
msgstr ""

#. type: Plain text
#: doc/rust.md:62
msgid ""
"Rust's grammar is defined over Unicode codepoints, each conventionally "
"denoted `U+XXXX`, for 4 or more hexadecimal digits `X`. _Most_ of Rust's "
"grammar is confined to the ASCII range of Unicode, and is described in this "
"document by a dialect of Extended Backus-Naur Form (EBNF), specifically a "
"dialect of EBNF supported by common automated LL(k) parsing tools such as "
"`llgen`, rather than the dialect given in ISO 14977. The dialect can be "
"defined self-referentially as follows:"
msgstr ""

#. type: Plain text
#: doc/rust.md:72
#, no-wrap
msgid ""
"~~~~ {.ebnf .notation}\n"
"grammar : rule + ;\n"
"rule    : nonterminal ':' productionrule ';' ;\n"
"productionrule : production [ '|' production ] * ;\n"
"production : term * ;\n"
"term : element repeats ;\n"
"element : LITERAL | IDENTIFIER | '[' productionrule ']' ;\n"
"repeats : [ '*' | '+' ] NUMBER ? | NUMBER ? | '?' ;\n"
"~~~~\n"
msgstr ""

#. type: Plain text
#: doc/rust.md:74
msgid "Where:"
msgstr ""

#. type: Bullet: '  - '
#: doc/rust.md:87
msgid "Whitespace in the grammar is ignored."
msgstr ""

#. type: Bullet: '  - '
#: doc/rust.md:87
msgid "Square brackets are used to group rules."
msgstr ""

#. type: Plain text
#: doc/rust.md:87
#, no-wrap
msgid ""
"  - `LITERAL` is a single printable ASCII character, or an escaped hexadecimal\n"
"     ASCII code of the form `\\xQQ`, in single quotes, denoting the corresponding\n"
"     Unicode codepoint `U+00QQ`.\n"
"  - `IDENTIFIER` is a nonempty string of ASCII letters and underscores.\n"
"  - The `repeat` forms apply to the adjacent `element`, and are as follows:\n"
"    - `?` means zero or one repetition\n"
"    - `*` means zero or more repetitions\n"
"    - `+` means one or more repetitions\n"
"    - NUMBER trailing a repeat symbol gives a maximum repetition count\n"
"    - NUMBER on its own gives an exact repetition count\n"
msgstr ""

#. type: Plain text
#: doc/rust.md:89
msgid "This EBNF dialect should hopefully be familiar to many readers."
msgstr ""

#. type: Plain text
#: doc/rust.md:91
msgid "## Unicode productions"
msgstr ""

#. type: Plain text
#: doc/rust.md:96
msgid ""
"A few productions in Rust's grammar permit Unicode codepoints outside the "
"ASCII range.  We define these productions in terms of character properties "
"specified in the Unicode standard, rather than in terms of ASCII-range "
"codepoints.  The section [Special Unicode Productions](#special-unicode-"
"productions) lists these productions."
msgstr ""

#. type: Plain text
#: doc/rust.md:98
msgid "## String table productions"
msgstr ""

#. type: Plain text
#: doc/rust.md:107
msgid ""
"Some rules in the grammar -- notably [unary operators](#unary-operator-"
"expressions), [binary operators](#binary-operator-expressions), and "
"[keywords](#keywords) -- are given in a simplified form: as a listing of a "
"table of unquoted, printable whitespace-separated strings. These cases form "
"a subset of the rules regarding the [token](#tokens) rule, and are assumed "
"to be the result of a lexical-analysis phase feeding the parser, driven by a "
"DFA, operating over the disjunction of all such string table entries."
msgstr ""

#. type: Plain text
#: doc/rust.md:111
msgid ""
"When such a string enclosed in double-quotes (`\"`) occurs inside the "
"grammar, it is an implicit reference to a single member of such a string "
"table production. See [tokens](#tokens) for more information."
msgstr ""

#. type: Plain text
#: doc/rust.md:113
msgid "# Lexical structure"
msgstr ""

#. type: Plain text
#: doc/rust.md:115
msgid "## Input format"
msgstr ""

#. type: Plain text
#: doc/rust.md:121
msgid ""
"Rust input is interpreted as a sequence of Unicode codepoints encoded in "
"UTF-8, normalized to Unicode normalization form NFKC.  Most Rust grammar "
"rules are defined in terms of printable ASCII-range codepoints, but a small "
"number are defined in terms of Unicode properties or explicit codepoint "
"lists.  ^[Substitute definitions for the special Unicode productions are "
"provided to the grammar verifier, restricted to ASCII range, when verifying "
"the grammar in this document.]"
msgstr ""

#. type: Plain text
#: doc/rust.md:123
msgid "## Special Unicode Productions"
msgstr ""

#. type: Plain text
#: doc/rust.md:126
msgid ""
"The following productions in the Rust grammar are defined in terms of "
"Unicode properties: `ident`, `non_null`, `non_star`, `non_eol`, "
"`non_slash_or_star`, `non_single_quote` and `non_double_quote`."
msgstr ""

#. type: Plain text
#: doc/rust.md:128
msgid "### Identifiers"
msgstr ""

#. type: Plain text
#: doc/rust.md:130
msgid ""
"The `ident` production is any nonempty Unicode string of the following form:"
msgstr ""

#. type: Bullet: '   - '
#: doc/rust.md:133
msgid "The first character has property `XID_start`"
msgstr ""

#. type: Bullet: '   - '
#: doc/rust.md:133
msgid "The remaining characters have property `XID_continue`"
msgstr ""

#. type: Plain text
#: doc/rust.md:135
msgid "that does _not_ occur in the set of [keywords](#keywords)."
msgstr ""

#. type: Plain text
#: doc/rust.md:139
msgid ""
"Note: `XID_start` and `XID_continue` as character properties cover the "
"character ranges used to form the more familiar C and Java language-family "
"identifiers."
msgstr ""

#. type: Plain text
#: doc/rust.md:141
msgid "### Delimiter-restricted productions"
msgstr ""

#. type: Plain text
#: doc/rust.md:143
msgid ""
"Some productions are defined by exclusion of particular Unicode characters:"
msgstr ""

#. type: Bullet: '  - '
#: doc/rust.md:150
msgid "`non_null` is any single Unicode character aside from `U+0000` (null)"
msgstr ""

#. type: Bullet: '  - '
#: doc/rust.md:150
msgid "`non_eol` is `non_null` restricted to exclude `U+000A` (`'\\n'`)"
msgstr ""

#. type: Bullet: '  - '
#: doc/rust.md:150
msgid "`non_star` is `non_null` restricted to exclude `U+002A` (`*`)"
msgstr ""

#. type: Bullet: '  - '
#: doc/rust.md:150
msgid ""
"`non_slash_or_star` is `non_null` restricted to exclude `U+002F` (`/`) and `U"
"+002A` (`*`)"
msgstr ""

#. type: Bullet: '  - '
#: doc/rust.md:150
msgid "`non_single_quote` is `non_null` restricted to exclude `U+0027` (`'`)"
msgstr ""

#. type: Bullet: '  - '
#: doc/rust.md:150
msgid "`non_double_quote` is `non_null` restricted to exclude `U+0022` (`\"`)"
msgstr ""

#. type: Plain text
#: doc/rust.md:152
msgid "## Comments"
msgstr ""

#. type: Plain text
#: doc/rust.md:159
msgid ""
"~~~~ {.ebnf .gram} comment : block_comment | line_comment ; block_comment : "
"\"/*\" block_comment_body * '*' + '/' ; block_comment_body : (block_comment "
"| character) * ; line_comment : \"//\" non_eol * ; ~~~~"
msgstr ""

#. type: Plain text
#: doc/rust.md:162
msgid ""
"Comments in Rust code follow the general C++ style of line and block-comment "
"forms, with no nesting of block-comment delimiters."
msgstr ""

#. type: Plain text
#: doc/rust.md:169
msgid ""
"Line comments beginning with exactly _three_ slashes (`///`), and block "
"comments beginning with a exactly one repeated asterisk in the block-open "
"sequence (`/**`), are interpreted as a special syntax for `doc` [attributes]"
"(#attributes).  That is, they are equivalent to writing `#[doc=\"...\"]` "
"around the body of the comment (this includes the comment characters "
"themselves, ie `/// Foo` turns into `#[doc=\"/// Foo\"]`)."
msgstr ""

#. type: Plain text
#: doc/rust.md:171
msgid "Non-doc comments are interpreted as a form of whitespace."
msgstr ""

#. type: Plain text
#: doc/rust.md:173
msgid "## Whitespace"
msgstr ""

#. type: Plain text
#: doc/rust.md:178
msgid ""
"~~~~ {.ebnf .gram} whitespace_char : '\\x20' | '\\x09' | '\\x0a' | '\\x0d' ; "
"whitespace : [ whitespace_char | comment ] + ; ~~~~"
msgstr ""

#. type: Plain text
#: doc/rust.md:182
msgid ""
"The `whitespace_char` production is any nonempty Unicode string consisting "
"of any of the following Unicode characters: `U+0020` (space, `' '`), `U"
"+0009` (tab, `'\\t'`), `U+000A` (LF, `'\\n'`), `U+000D` (CR, `'\\r'`)."
msgstr ""

#. type: Plain text
#: doc/rust.md:185
msgid ""
"Rust is a \"free-form\" language, meaning that all forms of whitespace serve "
"only to separate _tokens_ in the grammar, and have no semantic significance."
msgstr ""

#. type: Plain text
#: doc/rust.md:188
msgid ""
"A Rust program has identical meaning if each whitespace element is replaced "
"with any other legal whitespace element, such as a single space character."
msgstr ""

#. type: Plain text
#: doc/rust.md:190
msgid "## Tokens"
msgstr ""

#. type: Plain text
#: doc/rust.md:195
msgid ""
"~~~~ {.ebnf .gram} simple_token : keyword | unop | binop ; token : "
"simple_token | ident | literal | symbol | whitespace token ; ~~~~"
msgstr ""

#. type: Plain text
#: doc/rust.md:200
msgid ""
"Tokens are primitive productions in the grammar defined by regular (non-"
"recursive) languages. \"Simple\" tokens are given in [string table "
"production](#string-table-productions) form, and occur in the rest of the "
"grammar as double-quoted strings. Other tokens have exact rules given."
msgstr ""

#. type: Plain text
#: doc/rust.md:202
msgid "### Keywords"
msgstr ""

#. type: Plain text
#: doc/rust.md:204
msgid "The keywords are the following strings:"
msgstr ""

#. type: Plain text
#: doc/rust.md:221
msgid ""
"~~~~ {.keyword} as break do else enum extern false fn for if impl in let "
"loop match mod mut priv pub ref return self static struct super true trait "
"type unsafe use while ~~~~"
msgstr ""

#. type: Plain text
#: doc/rust.md:224
msgid ""
"Each of these keywords has special meaning in its grammar, and all of them "
"are excluded from the `ident` rule."
msgstr ""

#. type: Plain text
#: doc/rust.md:226
msgid "### Literals"
msgstr ""

#. type: Plain text
#: doc/rust.md:232
msgid ""
"A literal is an expression consisting of a single token, rather than a "
"sequence of tokens, that immediately and directly denotes the value it "
"evaluates to, rather than referring to it by name or some other evaluation "
"rule. A literal is a form of constant expression, so is evaluated "
"(primarily)  at compile time."
msgstr ""

#. type: Plain text
#: doc/rust.md:236
msgid "~~~~ {.ebnf .gram} literal : string_lit | char_lit | num_lit ; ~~~~"
msgstr ""

#. type: Plain text
#: doc/rust.md:238
msgid "#### Character and string literals"
msgstr ""

#. type: Plain text
#: doc/rust.md:242
msgid ""
"~~~~ {.ebnf .gram} char_lit : '\\x27' char_body '\\x27' ; string_lit : '\"' "
"string_body * '\"' | 'r' raw_string ;"
msgstr ""

#. type: Plain text
#: doc/rust.md:245
#, no-wrap
msgid ""
"char_body : non_single_quote\n"
"          | '\\x5c' [ '\\x27' | common_escape ] ;\n"
msgstr ""

#. type: Plain text
#: doc/rust.md:249
#, no-wrap
msgid ""
"string_body : non_double_quote\n"
"            | '\\x5c' [ '\\x22' | common_escape ] ;\n"
"raw_string : '\"' raw_string_body '\"' | '#' raw_string '#' ;\n"
msgstr ""

#. type: Plain text
#: doc/rust.md:255
#, no-wrap
msgid ""
"common_escape : '\\x5c'\n"
"              | 'n' | 'r' | 't' | '0'\n"
"              | 'x' hex_digit 2\n"
"              | 'u' hex_digit 4\n"
"              | 'U' hex_digit 8 ;\n"
msgstr ""

#. type: Plain text
#: doc/rust.md:264
#, no-wrap
msgid ""
"hex_digit : 'a' | 'b' | 'c' | 'd' | 'e' | 'f'\n"
"          | 'A' | 'B' | 'C' | 'D' | 'E' | 'F'\n"
"          | dec_digit ;\n"
"oct_digit : '0' | '1' | '2' | '3' | '4' | '5' | '6' | '7' ;\n"
"dec_digit : '0' | nonzero_dec ;\n"
"nonzero_dec: '1' | '2' | '3' | '4'\n"
"           | '5' | '6' | '7' | '8' | '9' ;\n"
"~~~~\n"
msgstr ""

#. type: Plain text
#: doc/rust.md:268
msgid ""
"A _character literal_ is a single Unicode character enclosed within two `U"
"+0027` (single-quote) characters, with the exception of `U+0027` itself, "
"which must be _escaped_ by a preceding U+005C character (`\\`)."
msgstr ""

#. type: Plain text
#: doc/rust.md:273
msgid ""
"A _string literal_ is a sequence of any Unicode characters enclosed within "
"two `U+0022` (double-quote) characters, with the exception of `U+0022` "
"itself, which must be _escaped_ by a preceding `U+005C` character (`\\`), or "
"a _raw string literal_."
msgstr ""

#. type: Plain text
#: doc/rust.md:277
msgid ""
"Some additional _escapes_ are available in either character or non-raw "
"string literals. An escape starts with a `U+005C` (`\\`) and continues with "
"one of the following forms:"
msgstr ""

#. type: Bullet: '  * '
#: doc/rust.md:292
msgid ""
"An _8-bit codepoint escape_ escape starts with `U+0078` (`x`) and is "
"followed by exactly two _hex digits_. It denotes the Unicode codepoint equal "
"to the provided hex value."
msgstr ""

#. type: Bullet: '  * '
#: doc/rust.md:292
msgid ""
"A _16-bit codepoint escape_ starts with `U+0075` (`u`) and is followed by "
"exactly four _hex digits_. It denotes the Unicode codepoint equal to the "
"provided hex value."
msgstr ""

#. type: Bullet: '  * '
#: doc/rust.md:292
msgid ""
"A _32-bit codepoint escape_ starts with `U+0055` (`U`) and is followed by "
"exactly eight _hex digits_. It denotes the Unicode codepoint equal to the "
"provided hex value."
msgstr ""

#. type: Bullet: '  * '
#: doc/rust.md:292
msgid ""
"A _whitespace escape_ is one of the characters `U+006E` (`n`), `U+0072` "
"(`r`), or `U+0074` (`t`), denoting the unicode values `U+000A` (LF), `U"
"+000D` (CR) or `U+0009` (HT) respectively."
msgstr ""

#. type: Bullet: '  * '
#: doc/rust.md:292
msgid ""
"The _backslash escape_ is the character `U+005C` (`\\`) which must be "
"escaped in order to denote *itself*."
msgstr ""

#. type: Plain text
#: doc/rust.md:300
msgid ""
"Raw string literals do not process any escapes. They start with the "
"character `U+0072` (`r`), followed zero or more of the character `U+0023` "
"(`#`) and a `U+0022` (double-quote) character. The _raw string body_ is not "
"defined in the EBNF grammar above: it can contain any sequence of Unicode "
"characters and is terminated only by another `U+0022` (double-quote) "
"character, followed by the same number of `U+0023` (`#`) characters that "
"preceeded the opening `U+0022` (double-quote) character."
msgstr ""

#. type: Plain text
#: doc/rust.md:305
msgid ""
"All Unicode characters contained in the raw string body represent "
"themselves, the characters `U+0022` (double-quote) (except when followed by "
"at least as many `U+0023` (`#`) characters as were used to start the raw "
"string literal) or `U+005C` (`\\`) do not have any special meaning."
msgstr ""

#. type: Plain text
#: doc/rust.md:307
msgid "Examples for string literals:"
msgstr ""

#. type: Plain text
#: doc/rust.md:311
#, no-wrap
msgid ""
"~~~~\n"
"\"foo\"; r\"foo\";                     // foo\n"
"\"\\\"foo\\\"\"; r#\"\"foo\"\"#;             // \"foo\"\n"
msgstr ""

#. type: Plain text
#: doc/rust.md:314
#, no-wrap
msgid ""
"\"foo #\\\"# bar\";\n"
"r##\"foo #\"# bar\"##;                // foo #\"# bar\n"
msgstr ""

#. type: Plain text
#: doc/rust.md:318
#, no-wrap
msgid ""
"\"\\x52\"; \"R\"; r\"R\";                 // R\n"
"\"\\\\x52\"; r\"\\x52\";                  // \\x52\n"
"~~~~\n"
msgstr ""

#. type: Plain text
#: doc/rust.md:320
msgid "#### Number literals"
msgstr ""

#. type: Plain text
#: doc/rust.md:327
#, no-wrap
msgid ""
"~~~~ {.ebnf .gram}\n"
"num_lit : nonzero_dec [ dec_digit | '_' ] * num_suffix ?\n"
"        | '0' [       [ dec_digit | '_' ] * num_suffix ?\n"
"              | 'b'   [ '1' | '0' | '_' ] + int_suffix ?\n"
"              | 'o'   [ oct_digit | '_' ] + int_suffix ?\n"
"              | 'x'   [ hex_digit | '_' ] + int_suffix ? ] ;\n"
msgstr ""

#. type: Plain text
#: doc/rust.md:329
msgid "num_suffix : int_suffix | float_suffix ;"
msgstr ""

#. type: Plain text
#: doc/rust.md:333
#, no-wrap
msgid ""
"int_suffix : 'u' int_suffix_size ?\n"
"           | 'i' int_suffix_size ? ;\n"
"int_suffix_size : [ '8' | '1' '6' | '3' '2' | '6' '4' ] ;\n"
msgstr ""

#. type: Plain text
#: doc/rust.md:339
msgid ""
"float_suffix : [ exponent | '.' dec_lit exponent ? ] ? float_suffix_ty ? ; "
"float_suffix_ty : 'f' [ '3' '2' | '6' '4' ] ; exponent : ['E' | 'e'] ['-' | "
"'+' ] ? dec_lit ; dec_lit : [ dec_digit | '_' ] + ; ~~~~"
msgstr ""

#. type: Plain text
#: doc/rust.md:343
msgid ""
"A _number literal_ is either an _integer literal_ or a _floating-point "
"literal_. The grammar for recognizing the two kinds of literals is mixed, as "
"they are differentiated by suffixes."
msgstr ""

#. type: Plain text
#: doc/rust.md:345
msgid "##### Integer literals"
msgstr ""

#. type: Plain text
#: doc/rust.md:347
msgid "An _integer literal_ has one of four forms:"
msgstr ""

#. type: Bullet: '  * '
#: doc/rust.md:356
msgid ""
"A _decimal literal_ starts with a *decimal digit* and continues with any "
"mixture of *decimal digits* and _underscores_."
msgstr ""

#. type: Bullet: '  * '
#: doc/rust.md:356
msgid ""
"A _hex literal_ starts with the character sequence `U+0030` `U+0078` (`0x`) "
"and continues as any mixture hex digits and underscores."
msgstr ""

#. type: Bullet: '  * '
#: doc/rust.md:356
msgid ""
"An _octal literal_ starts with the character sequence `U+0030` `U+006F` "
"(`0o`) and continues as any mixture octal digits and underscores."
msgstr ""

#. type: Bullet: '  * '
#: doc/rust.md:356
msgid ""
"A _binary literal_ starts with the character sequence `U+0030` `U+0062` "
"(`0b`) and continues as any mixture binary digits and underscores."
msgstr ""

#. type: Plain text
#: doc/rust.md:360
msgid ""
"An integer literal may be followed (immediately, without any spaces) by an "
"_integer suffix_, which changes the type of the literal. There are two kinds "
"of integer literal suffix:"
msgstr ""

#. type: Bullet: '  * '
#: doc/rust.md:366
msgid ""
"The `i` and `u` suffixes give the literal type `int` or `uint`, respectively."
msgstr ""

#. type: Bullet: '  * '
#: doc/rust.md:366
msgid ""
"Each of the signed and unsigned machine types `u8`, `i8`, `u16`, `i16`, "
"`u32`, `i32`, `u64` and `i64` give the literal the corresponding machine "
"type."
msgstr ""

#. type: Plain text
#: doc/rust.md:373
msgid ""
"The type of an _unsuffixed_ integer literal is determined by type "
"inference.  If a integer type can be _uniquely_ determined from the "
"surrounding program context, the unsuffixed integer literal has that type.  "
"If the program context underconstrains the type, the unsuffixed integer "
"literal's type is `int`; if the program context overconstrains the type, it "
"is considered a static type error."
msgstr ""

#. type: Plain text
#: doc/rust.md:375
msgid "Examples of integer literals of various forms:"
msgstr ""

#. type: Plain text
#: doc/rust.md:380
#, no-wrap
msgid ""
"~~~~\n"
"123; 0xff00;                       // type determined by program context\n"
"                                   // defaults to int in absence of type\n"
"                                   // information\n"
msgstr ""

#. type: Plain text
#: doc/rust.md:387
#, no-wrap
msgid ""
"123u;                              // type uint\n"
"123_u;                             // type uint\n"
"0xff_u8;                           // type u8\n"
"0o70_i16;                          // type i16\n"
"0b1111_1111_1001_0000_i32;         // type i32\n"
"~~~~\n"
msgstr ""

#. type: Plain text
#: doc/rust.md:389
msgid "##### Floating-point literals"
msgstr ""

#. type: Plain text
#: doc/rust.md:391
msgid "A _floating-point literal_ has one of two forms:"
msgstr ""

#. type: Bullet: '* '
#: doc/rust.md:396
msgid ""
"Two _decimal literals_ separated by a period character `U+002E` (`.`), with "
"an optional _exponent_ trailing after the second decimal literal."
msgstr ""

#. type: Bullet: '* '
#: doc/rust.md:396
msgid "A single _decimal literal_ followed by an _exponent_."
msgstr ""

#. type: Plain text
#: doc/rust.md:402
msgid ""
"By default, a floating-point literal has a generic type, but will fall back "
"to `f64`. A floating-point literal may be followed (immediately, without any "
"spaces) by a _floating-point suffix_, which changes the type of the "
"literal.  There are two floating-point suffixes: `f32`, and `f64` (the 32-"
"bit and 64-bit floating point types)."
msgstr ""

#. type: Plain text
#: doc/rust.md:404
msgid "Examples of floating-point literals of various forms:"
msgstr ""

#. type: Plain text
#: doc/rust.md:411
#, no-wrap
msgid ""
"~~~~\n"
"123.0;                             // type f64\n"
"0.1;                               // type f64\n"
"0.1f32;                            // type f32\n"
"12E+99_f64;                        // type f64\n"
"~~~~\n"
msgstr ""

#. type: Plain text
#: doc/rust.md:413
msgid "##### Unit and boolean literals"
msgstr ""

#. type: Plain text
#: doc/rust.md:416
msgid ""
"The _unit value_, the only value of the type that has the same name, is "
"written as `()`.  The two values of the boolean type are written `true` and "
"`false`."
msgstr ""

#. type: Plain text
#: doc/rust.md:418
msgid "### Symbols"
msgstr ""

#. type: Plain text
#: doc/rust.md:424
#, no-wrap
msgid ""
"~~~~ {.ebnf .gram}\n"
"symbol : \"::\" \"->\"\n"
"       | '#' | '[' | ']' | '(' | ')' | '{' | '}'\n"
"       | ',' | ';' ;\n"
"~~~~\n"
msgstr ""

#. type: Plain text
#: doc/rust.md:430
msgid ""
"Symbols are a general class of printable [token](#tokens) that play "
"structural roles in a variety of grammar productions. They are catalogued "
"here for completeness as the set of remaining miscellaneous printable tokens "
"that do not otherwise appear as [unary operators](#unary-operator-"
"expressions), [binary operators](#binary-operator-expressions), or [keywords]"
"(#keywords)."
msgstr ""

#. type: Plain text
#: doc/rust.md:433
msgid "## Paths"
msgstr ""

#. type: Plain text
#: doc/rust.md:438
#, no-wrap
msgid ""
"~~~~ {.ebnf .gram}\n"
"expr_path : ident [ \"::\" expr_path_tail ] + ;\n"
"expr_path_tail : '<' type_expr [ ',' type_expr ] + '>'\n"
"               | expr_path ;\n"
msgstr ""

#. type: Plain text
#: doc/rust.md:443
#, no-wrap
msgid ""
"type_path : ident [ type_path_tail ] + ;\n"
"type_path_tail : '<' type_expr [ ',' type_expr ] + '>'\n"
"               | \"::\" type_path ;\n"
"~~~~\n"
msgstr ""

#. type: Plain text
#: doc/rust.md:448
msgid ""
"A _path_ is a sequence of one or more path components _logically_ separated "
"by a namespace qualifier (`::`). If a path consists of only one component, "
"it may refer to either an [item](#items) or a [slot](#memory-slots) in a "
"local control scope. If a path has multiple components, it refers to an item."
msgstr ""

#. type: Plain text
#: doc/rust.md:452
msgid ""
"Every item has a _canonical path_ within its crate, but the path naming an "
"item is only meaningful within a given crate. There is no global namespace "
"across crates; an item's canonical path merely identifies it within the "
"crate."
msgstr ""

#. type: Plain text
#: doc/rust.md:454
msgid "Two examples of simple paths consisting of only identifier components:"
msgstr ""

#. type: Plain text
#: doc/rust.md:459
msgid "~~~~ {.ignore} x; x::y::z; ~~~~"
msgstr ""

#. type: Plain text
#: doc/rust.md:466
msgid ""
"Path components are usually [identifiers](#identifiers), but the trailing "
"component of a path may be an angle-bracket-enclosed list of type arguments. "
"In [expression](#expressions) context, the type argument list is given after "
"a final (`::`) namespace qualifier in order to disambiguate it from a "
"relational expression involving the less-than symbol (`<`). In type "
"expression context, the final namespace qualifier is omitted."
msgstr ""

#. type: Plain text
#: doc/rust.md:468
msgid "Two examples of paths with type arguments:"
msgstr ""

#. type: Plain text
#: doc/rust.md:477
#, no-wrap
msgid ""
"~~~~\n"
"# use std::hashmap::HashMap;\n"
"# fn f() {\n"
"# fn id<T>(t: T) -> T { t }\n"
"type t = HashMap<int,~str>;  // Type arguments used in a type expression\n"
"let x = id::<int>(10);         // Type arguments used in a call expression\n"
"# }\n"
"~~~~\n"
msgstr ""

#. type: Plain text
#: doc/rust.md:479
msgid "# Syntax extensions"
msgstr ""

#. type: Plain text
#: doc/rust.md:484
msgid ""
"A number of minor features of Rust are not central enough to have their own "
"syntax, and yet are not implementable as functions. Instead, they are given "
"names, and invoked through a consistent syntax: `name!(...)`. Examples "
"include:"
msgstr ""

#. type: Bullet: '* '
#: doc/rust.md:492
msgid "`fmt!` : format data into a string"
msgstr ""

#. type: Bullet: '* '
#: doc/rust.md:492
msgid "`env!` : look up an environment variable's value at compile time"
msgstr ""

#. type: Bullet: '* '
#: doc/rust.md:492
msgid "`stringify!` : pretty-print the Rust expression given as an argument"
msgstr ""

#. type: Bullet: '* '
#: doc/rust.md:492
msgid "`include!` : include the Rust expression in the given file"
msgstr ""

#. type: Bullet: '* '
#: doc/rust.md:492
msgid "`include_str!` : include the contents of the given file as a string"
msgstr ""

#. type: Bullet: '* '
#: doc/rust.md:492
msgid ""
"`include_bin!` : include the contents of the given file as a binary blob"
msgstr ""

#. type: Bullet: '* '
#: doc/rust.md:492
msgid "`error!`, `warn!`, `info!`, `debug!` : provide diagnostic information."
msgstr ""

#. type: Plain text
#: doc/rust.md:494
msgid "All of the above extensions are expressions with values."
msgstr ""

#. type: Plain text
#: doc/rust.md:496
msgid "## Macros"
msgstr ""

#. type: Plain text
#: doc/rust.md:509
#, no-wrap
msgid ""
"~~~~ {.ebnf .gram}\n"
"expr_macro_rules : \"macro_rules\" '!' ident '(' macro_rule * ')'\n"
"macro_rule : '(' matcher * ')' \"=>\" '(' transcriber * ')' ';'\n"
"matcher : '(' matcher * ')' | '[' matcher * ']'\n"
"        | '{' matcher * '}' | '$' ident ':' ident\n"
"        | '$' '(' matcher * ')' sep_token? [ '*' | '+' ]\n"
"        | non_special_token\n"
"transcriber : '(' transcriber * ')' | '[' transcriber * ']'\n"
"            | '{' transcriber * '}' | '$' ident\n"
"            | '$' '(' transcriber * ')' sep_token? [ '*' | '+' ]\n"
"            | non_special_token\n"
"~~~~\n"
msgstr ""

#. type: Plain text
#: doc/rust.md:513
msgid ""
"User-defined syntax extensions are called \"macros\", and the `macro_rules` "
"syntax extension defines them.  Currently, user-defined macros can expand to "
"expressions, statements, or items."
msgstr ""

#. type: Plain text
#: doc/rust.md:516
msgid ""
"(A `sep_token` is any token other than `*` and `+`.  A `non_special_token` "
"is any token other than a delimiter or `$`.)"
msgstr ""

#. type: Plain text
#: doc/rust.md:522
msgid ""
"The macro expander looks up macro invocations by name, and tries each macro "
"rule in turn.  It transcribes the first successful match.  Matching and "
"transcription are closely related to each other, and we will describe them "
"together."
msgstr ""

#. type: Plain text
#: doc/rust.md:524
msgid "### Macro By Example"
msgstr ""

#. type: Plain text
#: doc/rust.md:527
msgid ""
"The macro expander matches and transcribes every token that does not begin "
"with a `$` literally, including delimiters.  For parsing reasons, delimiters "
"must be balanced, but they are otherwise not special."
msgstr ""

#. type: Plain text
#: doc/rust.md:533
msgid ""
"In the matcher, `$` _name_ `:` _designator_ matches the nonterminal in the "
"Rust syntax named by _designator_. Valid designators are `item`, `block`, "
"`stmt`, `pat`, `expr`, `ty` (type), `ident`, `path`, `matchers` (lhs of the "
"`=>` in macro rules), `tt` (rhs of the `=>` in macro rules). In the "
"transcriber, the designator is already known, and so only the name of a "
"matched nonterminal comes after the dollar sign."
msgstr ""

#. type: Plain text
#: doc/rust.md:542
msgid ""
"In both the matcher and transcriber, the Kleene star-like operator indicates "
"repetition.  The Kleene star operator consists of `$` and parens, optionally "
"followed by a separator token, followed by `*` or `+`.  `*` means zero or "
"more repetitions, `+` means at least one repetition.  The parens are not "
"matched or transcribed.  On the matcher side, a name is bound to _all_ of "
"the names it matches, in a structure that mimics the structure of the "
"repetition encountered on a successful match. The job of the transcriber is "
"to sort that structure out."
msgstr ""

#. type: Plain text
#: doc/rust.md:548
msgid ""
"The rules for transcription of these repetitions are called \"Macro By "
"Example\".  Essentially, one \"layer\" of repetition is discharged at a "
"time, and all of them must be discharged by the time a name is transcribed. "
"Therefore, `( $( $i:ident ),* ) => ( $i )` is an invalid macro, but `( $( $i:"
"ident ),* ) => ( $( $i:ident ),* )` is acceptable (if trivial)."
msgstr ""

#. type: Plain text
#: doc/rust.md:556
msgid ""
"When Macro By Example encounters a repetition, it examines all of the `$` "
"_name_ s that occur in its body. At the \"current layer\", they all must "
"repeat the same number of times, so ` ( $( $i:ident ),* ; $( $j:ident ),* ) "
"=> ( $( ($i,$j) ),* )` is valid if given the argument `(a,b,c ; d,e,f)`, but "
"not `(a,b,c ; d,e)`. The repetition walks through the choices at that layer "
"in lockstep, so the former input transcribes to `( (a,d), (b,e), (c,f) )`."
msgstr ""

#. type: Plain text
#: doc/rust.md:558
msgid "Nested repetitions are allowed."
msgstr ""

#. type: Plain text
#: doc/rust.md:560
msgid "### Parsing limitations"
msgstr ""

#. type: Plain text
#: doc/rust.md:563
msgid ""
"The parser used by the macro system is reasonably powerful, but the parsing "
"of Rust syntax is restricted in two ways:"
msgstr ""

#. type: Plain text
#: doc/rust.md:569
#, no-wrap
msgid ""
"1. The parser will always parse as much as possible. If it attempts to match\n"
"`$i:expr [ , ]` against `8 [ , ]`, it will attempt to parse `i` as an array\n"
"index operation and fail. Adding a separator can solve this problem.\n"
"2. The parser must have eliminated all ambiguity by the time it reaches a `$` _name_ `:` _designator_.\n"
"This requirement most often affects name-designator pairs when they occur at the beginning of, or immediately after, a `$(...)*`; requiring a distinctive token in front can solve the problem.\n"
msgstr ""

#. type: Plain text
#: doc/rust.md:571
msgid "## Syntax extensions useful for the macro author"
msgstr ""

#. type: Bullet: '* '
#: doc/rust.md:577
msgid "`log_syntax!` : print out the arguments at compile time"
msgstr ""

#. type: Bullet: '* '
#: doc/rust.md:577
msgid ""
"`trace_macros!` : supply `true` or `false` to enable or disable macro "
"expansion logging"
msgstr ""

#. type: Bullet: '* '
#: doc/rust.md:577
msgid "`stringify!` : turn the identifier argument into a string literal"
msgstr ""

#. type: Bullet: '* '
#: doc/rust.md:577
msgid "`concat!` : concatenates a comma-separated list of literals"
msgstr ""

#. type: Bullet: '* '
#: doc/rust.md:577
msgid ""
"`concat_idents!` : create a new identifier by concatenating the arguments"
msgstr ""

#. type: Plain text
#: doc/rust.md:579
msgid "# Crates and source files"
msgstr ""

#. type: Plain text
#: doc/rust.md:586
msgid ""
"Rust is a *compiled* language.  Its semantics obey a *phase distinction* "
"between compile-time and run-time.  Those semantic rules that have a *static "
"interpretation* govern the success or failure of compilation.  We refer to "
"these rules as \"static semantics\".  Semantic rules called \"dynamic "
"semantics\" govern the behavior of programs at run-time.  A program that "
"fails to compile due to violation of a compile-time rule has no defined "
"dynamic semantics; the compiler should halt with an error report, and "
"produce no executable artifact."
msgstr ""

#. type: Plain text
#: doc/rust.md:592
msgid ""
"The compilation model centres on artifacts called _crates_.  Each "
"compilation processes a single crate in source form, and if successful, "
"produces a single crate in binary form: either an executable or a library."
"^[A crate is somewhat analogous to an *assembly* in the ECMA-335 CLI model, "
"a *library* in the SML/NJ Compilation Manager, a *unit* in the Owens and "
"Flatt module system, or a *configuration* in Mesa.]"
msgstr ""

#. type: Plain text
#: doc/rust.md:596
msgid ""
"A _crate_ is a unit of compilation and linking, as well as versioning, "
"distribution and runtime loading.  A crate contains a _tree_ of nested "
"[module](#modules) scopes.  The top level of this tree is a module that is "
"anonymous (from the point of view of paths within the module) and any item "
"within a crate has a canonical [module path](#paths) denoting its location "
"within the crate's module tree."
msgstr ""

#. type: Plain text
#: doc/rust.md:600
msgid ""
"The Rust compiler is always invoked with a single source file as input, and "
"always produces a single output crate.  The processing of that source file "
"may result in other source files being loaded as modules.  Source files have "
"the extension `.rs`."
msgstr ""

#. type: Plain text
#: doc/rust.md:605
msgid ""
"A Rust source file describes a module, the name and location of which -- in "
"the module tree of the current crate -- are defined from outside the source "
"file: either by an explicit `mod_item` in a referencing source file, or by "
"the name of the crate itself."
msgstr ""

#. type: Plain text
#: doc/rust.md:610
msgid ""
"Each source file contains a sequence of zero or more `item` definitions, and "
"may optionally begin with any number of `attributes` that apply to the "
"containing module.  Attributes on the anonymous crate module define "
"important metadata that influences the behavior of the compiler."
msgstr ""

#. type: Plain text
#: doc/rust.md:614
msgid "~~~~ // Package ID #[ crate_id = \"projx#2.5\" ];"
msgstr ""

#. type: Plain text
#: doc/rust.md:619
msgid ""
"// Additional metadata attributes #[ desc = \"Project X\" ]; #[ license = "
"\"BSD\" ]; #[ comment = \"This is a comment on Project X.\" ];"
msgstr ""

#. type: Plain text
#: doc/rust.md:622
msgid "// Specify the output type #[ crate_type = \"lib\" ];"
msgstr ""

#. type: Plain text
#: doc/rust.md:626
msgid "// Turn on a warning #[ warn(non_camel_case_types) ]; ~~~~"
msgstr ""

#. type: Plain text
#: doc/rust.md:629
msgid ""
"A crate that contains a `main` function can be compiled to an executable.  "
"If a `main` function is present, its return type must be [`unit`](#primitive-"
"types) and it must take no arguments."
msgstr ""

#. type: Plain text
#: doc/rust.md:631
msgid "# Items and attributes"
msgstr ""

#. type: Plain text
#: doc/rust.md:634
msgid ""
"Crates contain [items](#items), each of which may have some number of "
"[attributes](#attributes) attached to it."
msgstr ""

#. type: Plain text
#: doc/rust.md:636
msgid "## Items"
msgstr ""

#. type: Plain text
#: doc/rust.md:641
#, no-wrap
msgid ""
"~~~~ {.ebnf .gram}\n"
"item : mod_item | fn_item | type_item | struct_item | enum_item\n"
"     | static_item | trait_item | impl_item | extern_block ;\n"
"~~~~\n"
msgstr ""

#. type: Plain text
#: doc/rust.md:647
msgid ""
"An _item_ is a component of a crate; some module items can be defined in "
"crate files, but most are defined in source files. Items are organized "
"within a crate by a nested set of [modules](#modules). Every crate has a "
"single \"outermost\" anonymous module; all further items within the crate "
"have [paths](#paths) within the module tree of the crate."
msgstr ""

#. type: Plain text
#: doc/rust.md:650
msgid ""
"Items are entirely determined at compile-time, generally remain fixed during "
"execution, and may reside in read-only memory."
msgstr ""

#. type: Plain text
#: doc/rust.md:652
msgid "There are several kinds of item:"
msgstr ""

#. type: Bullet: '  * '
#: doc/rust.md:661
msgid "[modules](#modules)"
msgstr ""

#. type: Bullet: '  * '
#: doc/rust.md:661
msgid "[functions](#functions)"
msgstr ""

#. type: Bullet: '  * '
#: doc/rust.md:661
msgid "[type definitions](#type-definitions)"
msgstr ""

#. type: Bullet: '  * '
#: doc/rust.md:661
msgid "[structures](#structures)"
msgstr ""

#. type: Bullet: '  * '
#: doc/rust.md:661
msgid "[enumerations](#enumerations)"
msgstr ""

#. type: Bullet: '  * '
#: doc/rust.md:661
msgid "[static items](#static-items)"
msgstr ""

#. type: Bullet: '  * '
#: doc/rust.md:661
msgid "[traits](#traits)"
msgstr ""

#. type: Bullet: '  * '
#: doc/rust.md:661
msgid "[implementations](#implementations)"
msgstr ""

#. type: Plain text
#: doc/rust.md:671
msgid ""
"Some items form an implicit scope for the declaration of sub-items. In other "
"words, within a function or module, declarations of items can (in many "
"cases)  be mixed with the statements, control blocks, and similar artifacts "
"that otherwise compose the item body. The meaning of these scoped items is "
"the same as if the item was declared outside the scope -- it is still a "
"static item -- except that the item's *path name* within the module "
"namespace is qualified by the name of the enclosing item, or is private to "
"the enclosing item (in the case of functions).  The grammar specifies the "
"exact locations in which sub-item declarations may appear."
msgstr ""

#. type: Plain text
#: doc/rust.md:673
msgid "### Type Parameters"
msgstr ""

#. type: Plain text
#: doc/rust.md:682
msgid ""
"All items except modules may be *parameterized* by type. Type parameters are "
"given as a comma-separated list of identifiers enclosed in angle brackets "
"(`<...>`), after the name of the item and before its definition.  The type "
"parameters of an item are considered \"part of the name\", not part of the "
"type of the item.  A referencing [path](#paths) must (in principle) provide "
"type arguments as a list of comma-separated types enclosed within angle "
"brackets, in order to refer to the type-parameterized item.  In practice, "
"the type-inference system can usually infer such argument types from "
"context.  There are no general type-parametric types, only type-parametric "
"items.  That is, Rust has no notion of type abstraction: there are no first-"
"class \"forall\" types."
msgstr ""

#. type: Plain text
#: doc/rust.md:684
msgid "### Modules"
msgstr ""

#. type: Plain text
#: doc/rust.md:689
msgid ""
"~~~~ {.ebnf .gram} mod_item : \"mod\" ident ( ';' | '{' mod '}' ); mod : "
"[ view_item | item ] * ; ~~~~"
msgstr ""

#. type: Plain text
#: doc/rust.md:694
msgid ""
"A module is a container for zero or more [view items](#view-items) and zero "
"or more [items](#items). The view items manage the visibility of the items "
"defined within the module, as well as the visibility of names from outside "
"the module when referenced from inside the module."
msgstr ""

#. type: Plain text
#: doc/rust.md:698
msgid ""
"A _module item_ is a module, surrounded in braces, named, and prefixed with "
"the keyword `mod`. A module item introduces a new, named module into the "
"tree of modules making up a crate. Modules can nest arbitrarily."
msgstr ""

#. type: Plain text
#: doc/rust.md:700
msgid "An example of a module:"
msgstr ""

#. type: Plain text
#: doc/rust.md:718
#, no-wrap
msgid ""
"~~~~\n"
"mod math {\n"
"    type complex = (f64, f64);\n"
"    fn sin(f: f64) -> f64 {\n"
"        ...\n"
"# fail!();\n"
"    }\n"
"    fn cos(f: f64) -> f64 {\n"
"        ...\n"
"# fail!();\n"
"    }\n"
"    fn tan(f: f64) -> f64 {\n"
"        ...\n"
"# fail!();\n"
"    }\n"
"}\n"
"~~~~\n"
msgstr ""

#. type: Plain text
#: doc/rust.md:723
msgid ""
"Modules and types share the same namespace.  Declaring a named type that has "
"the same name as a module in scope is forbidden: that is, a type definition, "
"trait, struct, enumeration, or type parameter can't shadow the name of a "
"module in scope, or vice versa."
msgstr ""

#. type: Plain text
#: doc/rust.md:728
msgid ""
"A module without a body is loaded from an external file, by default with the "
"same name as the module, plus the `.rs` extension.  When a nested submodule "
"is loaded from an external file, it is loaded from a subdirectory path that "
"mirrors the module hierarchy."
msgstr ""

#. type: Plain text
#: doc/rust.md:732
msgid "~~~~ {.xfail-test} // Load the `vec` module from `vec.rs` mod vec;"
msgstr ""

#. type: Plain text
#: doc/rust.md:738
#, no-wrap
msgid ""
"mod task {\n"
"    // Load the `local_data` module from `task/local_data.rs`\n"
"    mod local_data;\n"
"}\n"
"~~~~\n"
msgstr ""

#. type: Plain text
#: doc/rust.md:741
msgid ""
"The directories and files used for loading external file modules can be "
"influenced with the `path` attribute."
msgstr ""

#. type: Plain text
#: doc/rust.md:750
#, no-wrap
msgid ""
"~~~~ {.xfail-test}\n"
"#[path = \"task_files\"]\n"
"mod task {\n"
"    // Load the `local_data` module from `task_files/tls.rs`\n"
"    #[path = \"tls.rs\"]\n"
"    mod local_data;\n"
"}\n"
"~~~~\n"
msgstr ""

#. type: Plain text
#: doc/rust.md:752
msgid "#### View items"
msgstr ""

#. type: Plain text
#: doc/rust.md:756
msgid "~~~~ {.ebnf .gram} view_item : extern_mod_decl | use_decl ; ~~~~"
msgstr ""

#. type: Plain text
#: doc/rust.md:760
msgid ""
"A view item manages the namespace of a module.  View items do not define new "
"items, but rather, simply change other items' visibility.  There are several "
"kinds of view item:"
msgstr ""

#. type: Bullet: ' * '
#: doc/rust.md:763
msgid "[`extern mod` declarations](#extern-mod-declarations)"
msgstr ""

#. type: Bullet: ' * '
#: doc/rust.md:763
msgid "[`use` declarations](#use-declarations)"
msgstr ""

#. type: Plain text
#: doc/rust.md:765
msgid "##### Extern mod declarations"
msgstr ""

#. type: Plain text
#: doc/rust.md:771
msgid ""
"~~~~ {.ebnf .gram} extern_mod_decl : \"extern\" \"mod\" ident [ '(' "
"link_attrs ')' ] ? [ '=' string_lit ] ? ; link_attrs : link_attr [ ',' "
"link_attrs ] + ; link_attr : ident '=' literal ; ~~~~"
msgstr ""

#. type: Plain text
#: doc/rust.md:775
msgid ""
"An _`extern mod` declaration_ specifies a dependency on an external crate.  "
"The external crate is then bound into the declaring scope as the `ident` "
"provided in the `extern_mod_decl`."
msgstr ""

#. type: Plain text
#: doc/rust.md:783
msgid ""
"The external crate is resolved to a specific `soname` at compile time, and a "
"runtime linkage requirement to that `soname` is passed to the linker for "
"loading at runtime.  The `soname` is resolved at compile time by scanning "
"the compiler's library path and matching the optional `crateid` provided as "
"a string literal against the `crateid` attributes that were declared on the "
"external crate when it was compiled.  If no `crateid` is provided, a default "
"`name` attribute is assumed, equal to the `ident` given in the "
"`extern_mod_decl`."
msgstr ""

#. type: Plain text
#: doc/rust.md:785
msgid "Four examples of `extern mod` declarations:"
msgstr ""

#. type: Plain text
#: doc/rust.md:788
msgid "~~~~ {.xfail-test} extern mod pcre;"
msgstr ""

#. type: Plain text
#: doc/rust.md:790
msgid "extern mod extra; // equivalent to: extern mod extra = \"extra\";"
msgstr ""

#. type: Plain text
#: doc/rust.md:792
msgid ""
"extern mod rustextra = \"extra\"; // linking to 'extra' under another name"
msgstr ""

#. type: Plain text
#: doc/rust.md:795
msgid ""
"extern mod foo = \"some/where/rust-foo#foo:1.0\"; // a full package ID for "
"rustpkg ~~~~"
msgstr ""

#. type: Plain text
#: doc/rust.md:797
msgid "##### Use declarations"
msgstr ""

#. type: Plain text
#: doc/rust.md:801
#, no-wrap
msgid ""
"~~~~ {.ebnf .gram}\n"
"use_decl : \"pub\" ? \"use\" ident [ '=' path\n"
"                          | \"::\" path_glob ] ;\n"
msgstr ""

#. type: Plain text
#: doc/rust.md:806
#, no-wrap
msgid ""
"path_glob : ident [ \"::\" path_glob ] ?\n"
"          | '*'\n"
"          | '{' ident [ ',' ident ] * '}'\n"
"~~~~\n"
msgstr ""

#. type: Plain text
#: doc/rust.md:810
msgid ""
"A _use declaration_ creates one or more local name bindings synonymous with "
"some other [path](#paths).  Usually a `use` declaration is used to shorten "
"the path required to refer to a module item."
msgstr ""

#. type: Plain text
#: doc/rust.md:814
#, no-wrap
msgid ""
"*Note*: Unlike in many languages,\n"
"`use` declarations in Rust do *not* declare linkage dependency with external crates.\n"
"Rather, [`extern mod` declarations](#extern-mod-declarations) declare linkage dependencies.\n"
msgstr ""

#. type: Plain text
#: doc/rust.md:816
msgid "Use declarations support a number of convenient shortcuts:"
msgstr ""

#. type: Bullet: '  * '
#: doc/rust.md:821
msgid ""
"Rebinding the target name as a new local name, using the syntax `use x = p::"
"q::r;`."
msgstr ""

#. type: Bullet: '  * '
#: doc/rust.md:821
msgid ""
"Simultaneously binding a list of paths differing only in their final "
"element, using the glob-like brace syntax `use a::b::{c,d,e,f};`"
msgstr ""

#. type: Bullet: '  * '
#: doc/rust.md:821
msgid ""
"Binding all paths matching a given prefix, using the asterisk wildcard "
"syntax `use a::b::*;`"
msgstr ""

#. type: Plain text
#: doc/rust.md:823
msgid "An example of `use` declarations:"
msgstr ""

#. type: Plain text
#: doc/rust.md:827
msgid "~~~~ use std::num::sin; use std::option::{Some, None};"
msgstr ""

#. type: Plain text
#: doc/rust.md:829
msgid "# fn foo<T>(_: T){}"
msgstr ""

#. type: Plain text
#: doc/rust.md:833
#, no-wrap
msgid ""
"fn main() {\n"
"    // Equivalent to 'std::num::sin(1.0);'\n"
"    sin(1.0);\n"
msgstr ""

#. type: Plain text
#: doc/rust.md:838
#, no-wrap
msgid ""
"    // Equivalent to 'foo(~[std::option::Some(1.0), std::option::None]);'\n"
"    foo(~[Some(1.0), None]);\n"
"}\n"
"~~~~\n"
msgstr ""

#. type: Plain text
#: doc/rust.md:846
msgid ""
"Like items, `use` declarations are private to the containing module, by "
"default.  Also like items, a `use` declaration can be public, if qualified "
"by the `pub` keyword.  Such a `use` declaration serves to _re-export_ a "
"name.  A public `use` declaration can therefore _redirect_ some public name "
"to a different target definition: even a definition with a private canonical "
"path, inside a different module.  If a sequence of such redirections form a "
"cycle or cannot be resolved unambiguously, they represent a compile-time "
"error."
msgstr ""

#. type: Plain text
#: doc/rust.md:848
msgid "An example of re-exporting:"
msgstr ""

#. type: Plain text
#: doc/rust.md:853
#, no-wrap
msgid ""
"~~~~\n"
"# fn main() { }\n"
"mod quux {\n"
"    pub use quux::foo::*;\n"
msgstr ""

#. type: Plain text
#: doc/rust.md:860
#, no-wrap
msgid ""
"    pub mod foo {\n"
"        pub fn bar() { }\n"
"        pub fn baz() { }\n"
"    }\n"
"}\n"
"~~~~\n"
msgstr ""

#. type: Plain text
#: doc/rust.md:862
msgid ""
"In this example, the module `quux` re-exports all of the public names "
"defined in `foo`."
msgstr ""

#. type: Plain text
#: doc/rust.md:870
msgid ""
"Also note that the paths contained in `use` items are relative to the crate "
"root.  So, in the previous example, the `use` refers to `quux::foo::*`, and "
"not simply to `foo::*`.  This also means that top-level module declarations "
"should be at the crate root if direct usage of the declared modules within "
"`use` items is desired.  It is also possible to use `self` and `super` at "
"the beginning of a `use` item to refer to the current and direct parent "
"modules respectively.  All rules regarding accessing declared modules in "
"`use` declarations applies to both module declarations and `extern mod` "
"declarations."
msgstr ""

#. type: Plain text
#: doc/rust.md:872
msgid "An example of what will and will not work for `use` items:"
msgstr ""

#. type: Plain text
#: doc/rust.md:877
#, no-wrap
msgid ""
"~~~~\n"
"# #[allow(unused_imports)];\n"
"use foo::extra;          // good: foo is at the root of the crate\n"
"use foo::baz::foobaz;    // good: foo is at the root of the crate\n"
msgstr ""

#. type: Plain text
#: doc/rust.md:880
#, no-wrap
msgid ""
"mod foo {\n"
"    extern mod extra;\n"
msgstr ""

#. type: Plain text
#: doc/rust.md:885
#, no-wrap
msgid ""
"    use foo::extra::list;  // good: foo is at crate root\n"
"//  use extra::*;          // bad:  extra is not at the crate root\n"
"    use self::baz::foobaz; // good: self refers to module 'foo'\n"
"    use foo::bar::foobar;  // good: foo is at crate root\n"
msgstr ""

#. type: Plain text
#: doc/rust.md:889
#, no-wrap
msgid ""
"    pub mod bar {\n"
"        pub fn foobar() { }\n"
"    }\n"
msgstr ""

#. type: Plain text
#: doc/rust.md:895
#, no-wrap
msgid ""
"    pub mod baz {\n"
"        use super::bar::foobar; // good: super refers to module 'foo'\n"
"        pub fn foobaz() { }\n"
"    }\n"
"}\n"
msgstr ""

#. type: Plain text
#: doc/rust.md:898
msgid "fn main() {} ~~~~"
msgstr ""

#. type: Plain text
#: doc/rust.md:900
msgid "### Functions"
msgstr ""

#. type: Plain text
#: doc/rust.md:904
msgid ""
"A _function item_ defines a sequence of [statements](#statements) and an "
"optional final [expression](#expressions), along with a name and a set of "
"parameters.  Functions are declared with the keyword `fn`.  Functions "
"declare a set of *input* [*slots*](#memory-slots) as parameters, through "
"which the caller passes arguments into the function, and an *output* [*slot*]"
"(#memory-slots) through which the function passes results back to the caller."
msgstr ""

#. type: Plain text
#: doc/rust.md:909
msgid ""
"A function may also be copied into a first class *value*, in which case the "
"value has the corresponding [*function type*](#function-types), and can be "
"used otherwise exactly as a function item (with a minor additional cost of "
"calling the function indirectly)."
msgstr ""

#. type: Plain text
#: doc/rust.md:915
msgid ""
"Every control path in a function logically ends with a `return` expression "
"or a diverging expression. If the outermost block of a function has a value-"
"producing expression in its final-expression position, that expression is "
"interpreted as an implicit `return` expression applied to the final-"
"expression."
msgstr ""

#. type: Plain text
#: doc/rust.md:917
msgid "An example of a function:"
msgstr ""

#. type: Plain text
#: doc/rust.md:923
#, no-wrap
msgid ""
"~~~~\n"
"fn add(x: int, y: int) -> int {\n"
"    return x + y;\n"
"}\n"
"~~~~\n"
msgstr ""

#. type: Plain text
#: doc/rust.md:926
msgid ""
"As with `let` bindings, function arguments are irrefutable patterns, so any "
"pattern that is valid in a let binding is also valid as an argument."
msgstr ""

#. type: Plain text
#: doc/rust.md:930
msgid "~~~~ fn first((value, _): (int, int)) -> int { value } ~~~~"
msgstr ""

#. type: Plain text
#: doc/rust.md:933
msgid "#### Generic functions"
msgstr ""

#. type: Plain text
#: doc/rust.md:938
msgid ""
"A _generic function_ allows one or more _parameterized types_ to appear in "
"its signature. Each type parameter must be explicitly declared, in an angle-"
"bracket-enclosed, comma-separated list following the function name."
msgstr ""

#. type: Plain text
#: doc/rust.md:949
#, no-wrap
msgid ""
"~~~~ {.xfail-test}\n"
"fn iter<T>(seq: &[T], f: |T|) {\n"
"    for elt in seq.iter() { f(elt); }\n"
"}\n"
"fn map<T, U>(seq: &[T], f: |T| -> U) -> ~[U] {\n"
"    let mut acc = ~[];\n"
"    for elt in seq.iter() { acc.push(f(elt)); }\n"
"    acc\n"
"}\n"
"~~~~\n"
msgstr ""

#. type: Plain text
#: doc/rust.md:952
msgid ""
"Inside the function signature and body, the name of the type parameter can "
"be used as a type name."
msgstr ""

#. type: Plain text
#: doc/rust.md:958
msgid ""
"When a generic function is referenced, its type is instantiated based on the "
"context of the reference. For example, calling the `iter` function defined "
"above on `[1, 2]` will instantiate type parameter `T` with `int`, and "
"require the closure parameter to have type `fn(int)`."
msgstr ""

#. type: Plain text
#: doc/rust.md:963
msgid ""
"The type parameters can also be explicitly supplied in a trailing [path]"
"(#paths) component after the function name. This might be necessary if there "
"is not sufficient context to determine the type parameters. For example, "
"`mem::size_of::<u32>() == 4`."
msgstr ""

#. type: Plain text
#: doc/rust.md:967
msgid ""
"Since a parameter type is opaque to the generic function, the set of "
"operations that can be performed on it is limited. Values of parameter type "
"can only be moved, not copied."
msgstr ""

#. type: Plain text
#: doc/rust.md:971
msgid "~~~~ fn id<T>(x: T) -> T { x } ~~~~"
msgstr ""

#. type: Plain text
#: doc/rust.md:975
msgid ""
"Similarly, [trait](#traits) bounds can be specified for type parameters to "
"allow methods with that trait to be called on values of that type."
msgstr ""

#. type: Plain text
#: doc/rust.md:978
msgid "#### Unsafety"
msgstr ""

#. type: Plain text
#: doc/rust.md:980
msgid ""
"Unsafe operations are those that potentially violate the memory-safety "
"guarantees of Rust's static semantics."
msgstr ""

#. type: Plain text
#: doc/rust.md:982
msgid ""
"The following language level features cannot be used in the safe subset of "
"Rust:"
msgstr ""

#. type: Bullet: '  - '
#: doc/rust.md:985
msgid "Dereferencing a [raw pointer](#pointer-types)."
msgstr ""

#. type: Bullet: '  - '
#: doc/rust.md:985
msgid ""
"Calling an unsafe function (including an intrinsic or foreign function)."
msgstr ""

#. type: Plain text
#: doc/rust.md:987
msgid "##### Unsafe functions"
msgstr ""

#. type: Plain text
#: doc/rust.md:990
msgid ""
"Unsafe functions are functions that are not safe in all contexts and/or for "
"all possible inputs.  Such a function must be prefixed with the keyword "
"`unsafe`."
msgstr ""

#. type: Plain text
#: doc/rust.md:992
msgid "##### Unsafe blocks"
msgstr ""

#. type: Plain text
#: doc/rust.md:995
msgid ""
"A block of code can also be prefixed with the `unsafe` keyword, to permit "
"calling `unsafe` functions or dereferencing raw pointers within a safe "
"function."
msgstr ""

#. type: Plain text
#: doc/rust.md:999
msgid ""
"When a programmer has sufficient conviction that a sequence of potentially "
"unsafe operations is actually safe, they can encapsulate that sequence "
"(taken as a whole) within an `unsafe` block. The compiler will consider uses "
"of such code safe, in the surrounding context."
msgstr ""

#. type: Plain text
#: doc/rust.md:1004
msgid ""
"Unsafe blocks are used to wrap foreign libraries, make direct use of "
"hardware or implement features not directly present in the language. For "
"example, Rust provides the language features necessary to implement memory-"
"safe concurrency in the language but the implementation of tasks and message "
"passing is in the standard library."
msgstr ""

#. type: Plain text
#: doc/rust.md:1010
msgid ""
"Rust's type system is a conservative approximation of the dynamic safety "
"requirements, so in some cases there is a performance cost to using safe "
"code.  For example, a doubly-linked list is not a tree structure and can "
"only be represented with managed or reference-counted pointers in safe "
"code.  By using `unsafe` blocks to represent the reverse links as raw "
"pointers, it can be implemented with only owned pointers."
msgstr ""

#. type: Plain text
#: doc/rust.md:1012
msgid "##### Behavior considered unsafe"
msgstr ""

#. type: Plain text
#: doc/rust.md:1016
msgid ""
"This is a list of behavior which is forbidden in all Rust code. Type "
"checking provides the guarantee that these issues are never caused by safe "
"code. An `unsafe` block or function is responsible for never invoking this "
"behaviour or exposing an API making it possible for it to occur in safe code."
msgstr ""

#. type: Bullet: '* '
#: doc/rust.md:1034
msgid "Data races"
msgstr ""

#. type: Bullet: '* '
#: doc/rust.md:1034
msgid "Dereferencing a null/dangling raw pointer"
msgstr ""

#. type: Bullet: '* '
#: doc/rust.md:1034
msgid ""
"Mutating an immutable value/reference, if it is not marked as non-`Freeze`"
msgstr ""

#. type: Bullet: '* '
#: doc/rust.md:1034
msgid ""
"Reads of [undef](http://llvm.org/docs/LangRef.html#undefined-values) "
"(uninitialized) memory"
msgstr ""

#. type: Plain text
#: doc/rust.md:1034
#, no-wrap
msgid ""
"* Breaking the [pointer aliasing rules](http://llvm.org/docs/LangRef.html#pointer-aliasing-rules)\n"
"  with raw pointers (a subset of the rules used by C)\n"
"* Invoking undefined behavior via compiler intrinsics:\n"
"    * Indexing outside of the bounds of an object with `std::ptr::offset` (`offset` intrinsic), with\n"
"      the exception of one byte past the end which is permitted.\n"
"    * Using `std::ptr::copy_nonoverlapping_memory` (`memcpy32`/`memcpy64` instrinsics) on\n"
"      overlapping buffers\n"
"* Invalid values in primitive types, even in private fields/locals:\n"
"    * Dangling/null pointers in non-raw pointers, or slices\n"
"    * A value other than `false` (0) or `true` (1) in a `bool`\n"
"    * A discriminant in an `enum` not included in the type definition\n"
"    * A value in a `char` which is a surrogate or above `char::MAX`\n"
"    * non-UTF-8 byte sequences in a `str`\n"
msgstr ""

#. type: Plain text
#: doc/rust.md:1036
msgid "##### Behaviour not considered unsafe"
msgstr ""

#. type: Plain text
#: doc/rust.md:1038
msgid ""
"This is a list of behaviour not considered *unsafe* in Rust terms, but that "
"may be undesired."
msgstr ""

#. type: Bullet: '* '
#: doc/rust.md:1047
msgid "Deadlocks"
msgstr ""

#. type: Bullet: '* '
#: doc/rust.md:1047
msgid "Reading data from private fields (`std::repr`, `format!(\"{:?}\", x)`)"
msgstr ""

#. type: Bullet: '* '
#: doc/rust.md:1047
msgid "Leaks due to reference count cycles, even in the global heap"
msgstr ""

#. type: Bullet: '* '
#: doc/rust.md:1047
msgid "Exiting without calling destructors"
msgstr ""

#. type: Bullet: '* '
#: doc/rust.md:1047
msgid "Sending signals"
msgstr ""

#. type: Bullet: '* '
#: doc/rust.md:1047
msgid "Accessing/modifying the file system"
msgstr ""

#. type: Bullet: '* '
#: doc/rust.md:1047
msgid "Unsigned integer overflow (well-defined as wrapping)"
msgstr ""

#. type: Bullet: '* '
#: doc/rust.md:1047
msgid ""
"Signed integer overflow (well-defined as two's complement representation "
"wrapping)"
msgstr ""

#. type: Plain text
#: doc/rust.md:1049
msgid "#### Diverging functions"
msgstr ""

#. type: Plain text
#: doc/rust.md:1052
msgid ""
"A special kind of function can be declared with a `!` character where the "
"output slot type would normally be. For example:"
msgstr ""

#. type: Plain text
#: doc/rust.md:1059
#, no-wrap
msgid ""
"~~~~\n"
"fn my_err(s: &str) -> ! {\n"
"    info!(\"{}\", s);\n"
"    fail!();\n"
"}\n"
"~~~~\n"
msgstr ""

#. type: Plain text
#: doc/rust.md:1066
msgid ""
"We call such functions \"diverging\" because they never return a value to "
"the caller. Every control path in a diverging function must end with a `fail!"
"()` or a call to another diverging function on every control path. The `!` "
"annotation does *not* denote a type. Rather, the result type of a diverging "
"function is a special type called $\\bot$ (\"bottom\") that unifies with any "
"type. Rust has no syntax for $\\bot$."
msgstr ""

#. type: Plain text
#: doc/rust.md:1072
msgid ""
"It might be necessary to declare a diverging function because as mentioned "
"previously, the typechecker checks that every control path in a function "
"ends with a [`return`](#return-expressions) or diverging expression. So, if "
"`my_err` were declared without the `!` annotation, the following code would "
"not typecheck:"
msgstr ""

#. type: Plain text
#: doc/rust.md:1075
msgid "~~~~ # fn my_err(s: &str) -> ! { fail!() }"
msgstr ""

#. type: Plain text
#: doc/rust.md:1085
#, no-wrap
msgid ""
"fn f(i: int) -> int {\n"
"   if i == 42 {\n"
"     return 42;\n"
"   }\n"
"   else {\n"
"     my_err(\"Bad number!\");\n"
"   }\n"
"}\n"
"~~~~\n"
msgstr ""

#. type: Plain text
#: doc/rust.md:1093
msgid ""
"This will not compile without the `!` annotation on `my_err`, since the "
"`else` branch of the conditional in `f` does not return an `int`, as "
"required by the signature of `f`.  Adding the `!` annotation to `my_err` "
"informs the typechecker that, should control ever enter `my_err`, no further "
"type judgments about `f` need to hold, since control will never resume in "
"any context that relies on those judgments.  Thus the return type on `f` "
"only needs to reflect the `if` branch of the conditional."
msgstr ""

#. type: Plain text
#: doc/rust.md:1096
msgid "#### Extern functions"
msgstr ""

#. type: Plain text
#: doc/rust.md:1103
msgid ""
"Extern functions are part of Rust's foreign function interface, providing "
"the opposite functionality to [external blocks](#external-blocks).  Whereas "
"external blocks allow Rust code to call foreign code, extern functions with "
"bodies defined in Rust code _can be called by foreign code_. They are "
"defined in the same way as any other Rust function, except that they have "
"the `extern` modifier."
msgstr ""

#. type: Plain text
#: doc/rust.md:1107
msgid ""
"~~~~ // Declares an extern fn, the ABI defaults to \"C\" extern fn new_vec() "
"-> ~[int] { ~[] }"
msgstr ""

#. type: Plain text
#: doc/rust.md:1111
msgid ""
"// Declares an extern fn with \"stdcall\" ABI extern \"stdcall\" fn "
"new_vec_stdcall() -> ~[int] { ~[] } ~~~~"
msgstr ""

#. type: Plain text
#: doc/rust.md:1115
msgid ""
"Unlike normal functions, extern fns have an `extern \"ABI\" fn()`.  This is "
"the same type as the functions declared in an extern block."
msgstr ""

#. type: Plain text
#: doc/rust.md:1120
msgid ""
"~~~~ # extern fn new_vec() -> ~[int] { ~[] } let fptr: extern \"C\" fn() -> "
"~[int] = new_vec; ~~~~"
msgstr ""

#. type: Plain text
#: doc/rust.md:1123
msgid ""
"Extern functions may be called directly from Rust code as Rust uses large, "
"contiguous stack segments like C."
msgstr ""

#. type: Plain text
#: doc/rust.md:1125
msgid "### Type definitions"
msgstr ""

#. type: Plain text
#: doc/rust.md:1129
msgid ""
"A _type definition_ defines a new name for an existing [type](#types). Type "
"definitions are declared with the keyword `type`. Every value has a single, "
"specific type; the type-specified aspects of a value include:"
msgstr ""

#. type: Bullet: '* '
#: doc/rust.md:1135
msgid "Whether the value is composed of sub-values or is indivisible."
msgstr ""

#. type: Bullet: '* '
#: doc/rust.md:1135
msgid "Whether the value represents textual or numerical information."
msgstr ""

#. type: Bullet: '* '
#: doc/rust.md:1135
msgid "Whether the value represents integral or floating-point information."
msgstr ""

#. type: Bullet: '* '
#: doc/rust.md:1135
msgid "The sequence of memory operations required to access the value."
msgstr ""

#. type: Bullet: '* '
#: doc/rust.md:1135
msgid "The [kind](#type-kinds) of the type."
msgstr ""

#. type: Plain text
#: doc/rust.md:1138
msgid ""
"For example, the type `(u8, u8)` defines the set of immutable values that "
"are composite pairs, each containing two unsigned 8-bit integers accessed by "
"pattern-matching and laid out in memory with the `x` component preceding the "
"`y` component."
msgstr ""

#. type: Plain text
#: doc/rust.md:1140
msgid "### Structures"
msgstr ""

#. type: Plain text
#: doc/rust.md:1142
msgid ""
"A _structure_ is a nominal [structure type](#structure-types) defined with "
"the keyword `struct`."
msgstr ""

#. type: Plain text
#: doc/rust.md:1144
msgid "An example of a `struct` item and its use:"
msgstr ""

#. type: Plain text
#: doc/rust.md:1150
msgid ""
"~~~~ struct Point {x: int, y: int} let p = Point {x: 10, y: 11}; let px: int "
"= p.x; ~~~~"
msgstr ""

#. type: Plain text
#: doc/rust.md:1153
msgid ""
"A _tuple structure_ is a nominal [tuple type](#tuple-types), also defined "
"with the keyword `struct`.  For example:"
msgstr ""

#. type: Plain text
#: doc/rust.md:1159
msgid ""
"~~~~ struct Point(int, int); let p = Point(10, 11); let px: int = match p "
"{ Point(x, _) => x }; ~~~~"
msgstr ""

#. type: Plain text
#: doc/rust.md:1163
msgid ""
"A _unit-like struct_ is a structure without any fields, defined by leaving "
"off the list of fields entirely.  Such types will have a single value, just "
"like the [unit value `()`](#unit-and-boolean-literals) of the unit type.  "
"For example:"
msgstr ""

#. type: Plain text
#: doc/rust.md:1168
msgid "~~~~ struct Cookie; let c = [Cookie, Cookie, Cookie, Cookie]; ~~~~"
msgstr ""

#. type: Plain text
#: doc/rust.md:1170
msgid "### Enumerations"
msgstr ""

#. type: Plain text
#: doc/rust.md:1173
msgid ""
"An _enumeration_ is a simultaneous definition of a nominal [enumerated type]"
"(#enumerated-types) as well as a set of *constructors*, that can be used to "
"create or pattern-match values of the corresponding enumerated type."
msgstr ""

#. type: Plain text
#: doc/rust.md:1175
msgid "Enumerations are declared with the keyword `enum`."
msgstr ""

#. type: Plain text
#: doc/rust.md:1177
msgid "An example of an `enum` item and its use:"
msgstr ""

#. type: Plain text
#: doc/rust.md:1183
#, no-wrap
msgid ""
"~~~~\n"
"enum Animal {\n"
"  Dog,\n"
"  Cat\n"
"}\n"
msgstr ""

#. type: Plain text
#: doc/rust.md:1187
msgid "let mut a: Animal = Dog; a = Cat; ~~~~"
msgstr ""

#. type: Plain text
#: doc/rust.md:1189
msgid "Enumeration constructors can have either named or unnamed fields:"
msgstr ""

#. type: Plain text
#: doc/rust.md:1195
#, no-wrap
msgid ""
"~~~~\n"
"enum Animal {\n"
"    Dog (~str, f64),\n"
"    Cat { name: ~str, weight: f64 }\n"
"}\n"
msgstr ""

#. type: Plain text
#: doc/rust.md:1199
msgid ""
"let mut a: Animal = Dog(~\"Cocoa\", 37.2); a = Cat{ name: ~\"Spotty\", "
"weight: 2.7 }; ~~~~"
msgstr ""

#. type: Plain text
#: doc/rust.md:1202
msgid ""
"In this example, `Cat` is a _struct-like enum variant_, whereas `Dog` is "
"simply called an enum variant."
msgstr ""

#. type: Plain text
#: doc/rust.md:1204
msgid "### Static items"
msgstr ""

#. type: Plain text
#: doc/rust.md:1208
msgid ""
"~~~~ {.ebnf .gram} static_item : \"static\" ident ':' type '=' expr ';' ; "
"~~~~"
msgstr ""

#. type: Plain text
#: doc/rust.md:1215
msgid ""
"A *static item* is a named _constant value_ stored in the global data "
"section of a crate.  Immutable static items are stored in the read-only data "
"section.  The constant value bound to a static item is, like all constant "
"values, evaluated at compile time.  Static items have the `static` lifetime, "
"which outlives all other lifetimes in a Rust program.  Static items are "
"declared with the `static` keyword.  A static item must have a _constant "
"expression_ giving its definition."
msgstr ""

#. type: Plain text
#: doc/rust.md:1220
msgid ""
"Static items must be explicitly typed.  The type may be ```bool```, "
"```char```, a number, or a type derived from those primitive types.  The "
"derived types are borrowed pointers with the `'static` lifetime, fixed-size "
"arrays, tuples, and structs."
msgstr ""

#. type: Plain text
#: doc/rust.md:1224
msgid "~~~~ static BIT1: uint = 1 << 0; static BIT2: uint = 1 << 1;"
msgstr ""

#. type: Plain text
#: doc/rust.md:1227
msgid ""
"static BITS: [uint, ..2] = [BIT1, BIT2]; static STRING: &'static str = "
"\"bitstring\";"
msgstr ""

#. type: Plain text
#: doc/rust.md:1232
#, no-wrap
msgid ""
"struct BitsNStrings<'a> {\n"
"    mybits: [uint, ..2],\n"
"    mystring: &'a str\n"
"}\n"
msgstr ""

#. type: Plain text
#: doc/rust.md:1238
#, no-wrap
msgid ""
"static bits_n_strings: BitsNStrings<'static> = BitsNStrings {\n"
"    mybits: BITS,\n"
"    mystring: STRING\n"
"};\n"
"~~~~\n"
msgstr ""

#. type: Plain text
#: doc/rust.md:1240
msgid "#### Mutable statics"
msgstr ""

#. type: Plain text
#: doc/rust.md:1248
msgid ""
"If a static item is declared with the ```mut``` keyword, then it is allowed "
"to be modified by the program. One of Rust's goals is to make concurrency "
"bugs hard to run into, and this is obviously a very large source of race "
"conditions or other bugs. For this reason, an ```unsafe``` block is required "
"when either reading or writing a mutable static variable. Care should be "
"taken to ensure that modifications to a mutable static are safe with respect "
"to other tasks running in the same process."
msgstr ""

#. type: Plain text
#: doc/rust.md:1251
msgid ""
"Mutable statics are still very useful, however. They can be used with C "
"libraries and can also be bound from C libraries (in an ```extern``` block)."
msgstr ""

#. type: Plain text
#: doc/rust.md:1254
msgid "~~~~ # fn atomic_add(_: &mut uint, _: uint) -> uint { 2 }"
msgstr ""

#. type: Plain text
#: doc/rust.md:1256
msgid "static mut LEVELS: uint = 0;"
msgstr ""

#. type: Plain text
#: doc/rust.md:1264
#, no-wrap
msgid ""
"// This violates the idea of no shared state, and this doesn't internally\n"
"// protect against races, so this function is `unsafe`\n"
"unsafe fn bump_levels_unsafe1() -> uint {\n"
"    let ret = LEVELS;\n"
"    LEVELS += 1;\n"
"    return ret;\n"
"}\n"
msgstr ""

#. type: Plain text
#: doc/rust.md:1272
#, no-wrap
msgid ""
"// Assuming that we have an atomic_add function which returns the old value,\n"
"// this function is \"safe\" but the meaning of the return value may not be what\n"
"// callers expect, so it's still marked as `unsafe`\n"
"unsafe fn bump_levels_unsafe2() -> uint {\n"
"    return atomic_add(&mut LEVELS, 1);\n"
"}\n"
"~~~~\n"
msgstr ""

#. type: Plain text
#: doc/rust.md:1274
msgid "### Traits"
msgstr ""

#. type: Plain text
#: doc/rust.md:1276
msgid "A _trait_ describes a set of method types."
msgstr ""

#. type: Plain text
#: doc/rust.md:1281
msgid ""
"Traits can include default implementations of methods, written in terms of "
"some unknown [`self` type](#self-types); the `self` type may either be "
"completely unspecified, or constrained by some other trait."
msgstr ""

#. type: Plain text
#: doc/rust.md:1283
msgid ""
"Traits are implemented for specific types through separate [implementations]"
"(#implementations)."
msgstr ""

#. type: Plain text
#: doc/rust.md:1287
msgid "~~~~ # type Surface = int; # type BoundingBox = int;"
msgstr ""

#. type: Plain text
#: doc/rust.md:1293
#, no-wrap
msgid ""
"trait Shape {\n"
"    fn draw(&self, Surface);\n"
"    fn bounding_box(&self) -> BoundingBox;\n"
"}\n"
"~~~~\n"
msgstr ""

#. type: Plain text
#: doc/rust.md:1297
msgid ""
"This defines a trait with two methods.  All values that have "
"[implementations](#implementations) of this trait in scope can have their "
"`draw` and `bounding_box` methods called, using `value.bounding_box()` "
"[syntax](#method-call-expressions)."
msgstr ""

#. type: Plain text
#: doc/rust.md:1300
msgid ""
"Type parameters can be specified for a trait to make it generic.  These "
"appear after the trait name, using the same syntax used in [generic "
"functions](#generic-functions)."
msgstr ""

#. type: Plain text
#: doc/rust.md:1308
#, no-wrap
msgid ""
"~~~~\n"
"trait Seq<T> {\n"
"   fn len(&self) -> uint;\n"
"   fn elt_at(&self, n: uint) -> T;\n"
"   fn iter(&self, |T|);\n"
"}\n"
"~~~~\n"
msgstr ""

#. type: Plain text
#: doc/rust.md:1314
msgid ""
"Generic functions may use traits as _bounds_ on their type parameters.  This "
"will have two effects: only types that have the trait may instantiate the "
"parameter, and within the generic function, the methods of the trait can be "
"called on values that have the parameter's type.  For example:"
msgstr ""

#. type: Plain text
#: doc/rust.md:1318
msgid "~~~~ # type Surface = int; # trait Shape { fn draw(&self, Surface); }"
msgstr ""

#. type: Plain text
#: doc/rust.md:1324
#, no-wrap
msgid ""
"fn draw_twice<T: Shape>(surface: Surface, sh: T) {\n"
"    sh.draw(surface);\n"
"    sh.draw(surface);\n"
"}\n"
"~~~~\n"
msgstr ""

#. type: Plain text
#: doc/rust.md:1329
msgid ""
"Traits also define an [object type](#object-types) with the same name as the "
"trait.  Values of this type are created by [casting](#type-cast-expressions) "
"pointer values (pointing to a type for which an implementation of the given "
"trait is in scope)  to pointers to the trait name, used as a type."
msgstr ""

#. type: Plain text
#: doc/rust.md:1334
msgid "~~~~ # trait Shape { } # impl Shape for int { } # let mycircle = 0;"
msgstr ""

#. type: Plain text
#: doc/rust.md:1337
msgid "let myshape: @Shape = @mycircle as @Shape; ~~~~"
msgstr ""

#. type: Plain text
#: doc/rust.md:1343
msgid ""
"The resulting value is a managed box containing the value that was cast, "
"along with information that identifies the methods of the implementation "
"that was used.  Values with a trait type can have [methods called](#method-"
"call-expressions) on them, for any method in the trait, and can be used to "
"instantiate type parameters that are bounded by the trait."
msgstr ""

#. type: Plain text
#: doc/rust.md:1351
msgid ""
"Trait methods may be static, which means that they lack a `self` argument.  "
"This means that they can only be called with function call syntax (`f(x)`)  "
"and not method call syntax (`obj.f()`).  The way to refer to the name of a "
"static method is to qualify it with the trait name, treating the trait name "
"like a module.  For example:"
msgstr ""

#. type: Plain text
#: doc/rust.md:1361
#, no-wrap
msgid ""
"~~~~\n"
"trait Num {\n"
"    fn from_int(n: int) -> Self;\n"
"}\n"
"impl Num for f64 {\n"
"    fn from_int(n: int) -> f64 { n as f64 }\n"
"}\n"
"let x: f64 = Num::from_int(42);\n"
"~~~~\n"
msgstr ""

#. type: Plain text
#: doc/rust.md:1363
msgid "Traits may inherit from other traits. For example, in"
msgstr ""

#. type: Plain text
#: doc/rust.md:1368
msgid ""
"~~~~ trait Shape { fn area() -> f64; } trait Circle : Shape { fn radius() -> "
"f64; } ~~~~"
msgstr ""

#. type: Plain text
#: doc/rust.md:1373
msgid ""
"the syntax `Circle : Shape` means that types that implement `Circle` must "
"also have an implementation for `Shape`.  Multiple supertraits are separated "
"by spaces, `trait Circle : Shape Eq { }`.  In an implementation of `Circle` "
"for a given type `T`, methods can refer to `Shape` methods, since the "
"typechecker checks that any type with an implementation of `Circle` also has "
"an implementation of `Shape`."
msgstr ""

#. type: Plain text
#: doc/rust.md:1377
msgid ""
"In type-parameterized functions, methods of the supertrait may be called on "
"values of subtrait-bound type parameters.  Referring to the previous example "
"of `trait Circle : Shape`:"
msgstr ""

#. type: Plain text
#: doc/rust.md:1386
#, no-wrap
msgid ""
"~~~~\n"
"# trait Shape { fn area(&self) -> f64; }\n"
"# trait Circle : Shape { fn radius(&self) -> f64; }\n"
"fn radius_times_area<T: Circle>(c: T) -> f64 {\n"
"    // `c` is both a Circle and a Shape\n"
"    c.radius() * c.area()\n"
"}\n"
"~~~~\n"
msgstr ""

#. type: Plain text
#: doc/rust.md:1388 doc/tutorial.md:2508
msgid "Likewise, supertrait methods may also be called on trait objects."
msgstr ""

#. type: Plain text
#: doc/rust.md:1395
msgid ""
"~~~~ {.xfail-test} # trait Shape { fn area(&self) -> f64; } # trait Circle : "
"Shape { fn radius(&self) -> f64; } # impl Shape for int { fn area(&self) -> "
"f64 { 0.0 } } # impl Circle for int { fn radius(&self) -> f64 { 0.0 } } # "
"let mycircle = 0;"
msgstr ""

#. type: Plain text
#: doc/rust.md:1399
msgid ""
"let mycircle: Circle = @mycircle as @Circle; let nonsense = mycircle."
"radius() * mycircle.area(); ~~~~"
msgstr ""

#. type: Plain text
#: doc/rust.md:1401
msgid "### Implementations"
msgstr ""

#. type: Plain text
#: doc/rust.md:1403
msgid ""
"An _implementation_ is an item that implements a [trait](#traits) for a "
"specific type."
msgstr ""

#. type: Plain text
#: doc/rust.md:1405
msgid "Implementations are defined with the keyword `impl`."
msgstr ""

#. type: Plain text
#: doc/rust.md:1412
msgid ""
"~~~~ # struct Point {x: f64, y: f64}; # type Surface = int; # struct "
"BoundingBox {x: f64, y: f64, width: f64, height: f64}; # trait Shape { fn "
"draw(&self, Surface); fn bounding_box(&self) -> BoundingBox; } # fn "
"do_draw_circle(s: Surface, c: Circle) { }"
msgstr ""

#. type: Plain text
#: doc/rust.md:1417
#, no-wrap
msgid ""
"struct Circle {\n"
"    radius: f64,\n"
"    center: Point,\n"
"}\n"
msgstr ""

#. type: Plain text
#: doc/rust.md:1427
#, no-wrap
msgid ""
"impl Shape for Circle {\n"
"    fn draw(&self, s: Surface) { do_draw_circle(s, *self); }\n"
"    fn bounding_box(&self) -> BoundingBox {\n"
"        let r = self.radius;\n"
"        BoundingBox{x: self.center.x - r, y: self.center.y - r,\n"
"         width: 2.0 * r, height: 2.0 * r}\n"
"    }\n"
"}\n"
"~~~~\n"
msgstr ""

#. type: Plain text
#: doc/rust.md:1434
msgid ""
"It is possible to define an implementation without referring to a trait.  "
"The methods in such an implementation can only be used as direct calls on "
"the values of the type that the implementation targets.  In such an "
"implementation, the trait type and `for` after `impl` are omitted.  Such "
"implementations are limited to nominal types (enums, structs), and the "
"implementation must appear in the same module or a sub-module as the `self` "
"type."
msgstr ""

#. type: Plain text
#: doc/rust.md:1438
msgid ""
"When a trait _is_ specified in an `impl`, all methods declared as part of "
"the trait must be implemented, with matching types and type parameter counts."
msgstr ""

#. type: Plain text
#: doc/rust.md:1442
msgid ""
"An implementation can take type parameters, which can be different from the "
"type parameters taken by the trait it implements.  Implementation parameters "
"are written after the `impl` keyword."
msgstr ""

#. type: Plain text
#: doc/rust.md:1445
msgid "~~~~ # trait Seq<T> { }"
msgstr ""

#. type: Plain text
#: doc/rust.md:1453
#, no-wrap
msgid ""
"impl<T> Seq<T> for ~[T] {\n"
"   ...\n"
"}\n"
"impl Seq<bool> for u32 {\n"
"   /* Treat the integer as a sequence of bits */\n"
"}\n"
"~~~~\n"
msgstr ""

#. type: Plain text
#: doc/rust.md:1455
msgid "### External blocks"
msgstr ""

#. type: Plain text
#: doc/rust.md:1460
msgid ""
"~~~~ {.ebnf .gram} extern_block_item : \"extern\" '{' extern_block '} ; "
"extern_block : [ foreign_fn ] * ; ~~~~"
msgstr ""

#. type: Plain text
#: doc/rust.md:1464
msgid ""
"External blocks form the basis for Rust's foreign function interface.  "
"Declarations in an external block describe symbols in external, non-Rust "
"libraries."
msgstr ""

#. type: Plain text
#: doc/rust.md:1469
msgid ""
"Functions within external blocks are declared in the same way as other Rust "
"functions, with the exception that they may not have a body and are instead "
"terminated by a semicolon."
msgstr ""

#. type: Plain text
#: doc/rust.md:1473
msgid "~~~~ # use std::libc::{c_char, FILE}; # #[nolink]"
msgstr ""

#. type: Plain text
#: doc/rust.md:1478
#, no-wrap
msgid ""
"extern {\n"
"    fn fopen(filename: *c_char, mode: *c_char) -> *FILE;\n"
"}\n"
"~~~~\n"
msgstr ""

#. type: Plain text
#: doc/rust.md:1483
msgid ""
"Functions within external blocks may be called by Rust code, just like "
"functions defined in Rust.  The Rust compiler automatically translates "
"between the Rust ABI and the foreign ABI."
msgstr ""

#. type: Plain text
#: doc/rust.md:1486
msgid ""
"A number of [attributes](#attributes) control the behavior of external "
"blocks."
msgstr ""

#. type: Plain text
#: doc/rust.md:1490
msgid ""
"By default external blocks assume that the library they are calling uses the "
"standard C \"cdecl\" ABI.  Other ABIs may be specified using an `abi` "
"string, as shown here:"
msgstr ""

#. type: Plain text
#: doc/rust.md:1495
msgid ""
"~~~~ {.xfail-test} // Interface to the Windows API extern \"stdcall\" { } "
"~~~~"
msgstr ""

#. type: Plain text
#: doc/rust.md:1499
msgid ""
"The `link` attribute allows the name of the library to be specified. When "
"specified the compiler will attempt to link against the native library of "
"the specified name."
msgstr ""

#. type: Plain text
#: doc/rust.md:1504
msgid "~~~~ {.xfail-test} #[link(name = \"crypto\")] extern { } ~~~~"
msgstr ""

#. type: Plain text
#: doc/rust.md:1510
msgid ""
"The type of a function declared in an extern block is `extern \"abi\" "
"fn(A1, ..., An) -> R`, where `A1...An` are the declared types of its "
"arguments and `R` is the decalred return type."
msgstr ""

#. type: Plain text
#: doc/rust.md:1512
msgid "## Visibility and Privacy"
msgstr ""

#. type: Plain text
#: doc/rust.md:1515
msgid ""
"These two terms are often used interchangeably, and what they are attempting "
"to convey is the answer to the question \"Can this item be used at this "
"location?\""
msgstr ""

#. type: Plain text
#: doc/rust.md:1521
msgid ""
"Rust's name resolution operates on a global hierarchy of namespaces. Each "
"level in the hierarchy can be thought of as some item. The items are one of "
"those mentioned above, but also include external crates. Declaring or "
"defining a new module can be thought of as inserting a new tree into the "
"hierarchy at the location of the definition."
msgstr ""

#. type: Plain text
#: doc/rust.md:1526
msgid ""
"To control whether interfaces can be used across modules, Rust checks each "
"use of an item to see whether it should be allowed or not. This is where "
"privacy warnings are generated, or otherwise \"you used a private item of "
"another module and weren't allowed to.\""
msgstr ""

#. type: Plain text
#: doc/rust.md:1534
msgid ""
"By default, everything in rust is *private*, with two exceptions. The first "
"exception is that struct fields are public by default (but the struct itself "
"is still private by default), and the remaining exception is that enum "
"variants in a `pub` enum are the default visibility of the enum container "
"itself.. You are allowed to alter this default visibility with the `pub` "
"keyword (or `priv` keyword for struct fields and enum variants). When an "
"item is declared as `pub`, it can be thought of as being accessible to the "
"outside world. For example:"
msgstr ""

#. type: Plain text
#: doc/rust.md:1539
msgid "~~~~ # fn main() {} // Declare a private struct struct Foo;"
msgstr ""

#. type: Plain text
#: doc/rust.md:1544
#, no-wrap
msgid ""
"// Declare a public struct with a private field\n"
"pub struct Bar {\n"
"    priv field: int\n"
"}\n"
msgstr ""

#. type: Plain text
#: doc/rust.md:1551
#, no-wrap
msgid ""
"// Declare a public enum with public and private variants\n"
"pub enum State {\n"
"    PubliclyAccessibleState,\n"
"    priv PrivatelyAccessibleState\n"
"}\n"
"~~~~\n"
msgstr ""

#. type: Plain text
#: doc/rust.md:1554
msgid ""
"With the notion of an item being either public or private, Rust allows item "
"accesses in two cases:"
msgstr ""

#. type: Bullet: '1. '
#: doc/rust.md:1559
msgid ""
"If an item is public, then it can be used externally through any of its "
"public ancestors."
msgstr ""

#. type: Bullet: '2. '
#: doc/rust.md:1559
msgid ""
"If an item is private, it may be accessed by the current module and its "
"descendants."
msgstr ""

#. type: Plain text
#: doc/rust.md:1563
msgid ""
"These two cases are surprisingly powerful for creating module hierarchies "
"exposing public APIs while hiding internal implementation details. To help "
"explain, here's a few use cases and what they would entail."
msgstr ""

#. type: Bullet: '* '
#: doc/rust.md:1568
msgid ""
"A library developer needs to expose functionality to crates which link "
"against their library. As a consequence of the first case, this means that "
"anything which is usable externally must be `pub` from the root down to the "
"destination item. Any private item in the chain will disallow external "
"accesses."
msgstr ""

#. type: Bullet: '* '
#: doc/rust.md:1574
msgid ""
"A crate needs a global available \"helper module\" to itself, but it doesn't "
"want to expose the helper module as a public API. To accomplish this, the "
"root of the crate's hierarchy would have a private module which then "
"internally has a \"public api\". Because the entire crate is a descendant of "
"the root, then the entire local crate can access this private module through "
"the second case."
msgstr ""

#. type: Bullet: '* '
#: doc/rust.md:1580
msgid ""
"When writing unit tests for a module, it's often a common idiom to have an "
"immediate child of the module to-be-tested named `mod test`. This module "
"could access any items of the parent module through the second case, meaning "
"that internal implementation details could also be seamlessly tested from "
"the child module."
msgstr ""

#. type: Plain text
#: doc/rust.md:1589
msgid ""
"In the second case, it mentions that a private item \"can be accessed\" by "
"the current module and its descendants, but the exact meaning of accessing "
"an item depends on what the item is. Accessing a module, for example, would "
"mean looking inside of it (to import more items). On the other hand, "
"accessing a function would mean that it is invoked. Additionally, path "
"expressions and import statements are considered to access an item in the "
"sense that the import/expression is only valid if the destination is in the "
"current visibility scope."
msgstr ""

#. type: Plain text
#: doc/rust.md:1591
msgid ""
"Here's an example of a program which exemplifies the three cases outlined "
"above."
msgstr ""

#. type: Plain text
#: doc/rust.md:1597
msgid ""
"~~~~ // This module is private, meaning that no external crate can access "
"this // module. Because it is private at the root of this current crate, "
"however, any // module in the crate may access any publicly visible item in "
"this module.  mod crate_helper_module {"
msgstr ""

#. type: Plain text
#: doc/rust.md:1600
#, no-wrap
msgid ""
"    // This function can be used by anything in the current crate\n"
"    pub fn crate_helper() {}\n"
msgstr ""

#. type: Plain text
#: doc/rust.md:1606
#, no-wrap
msgid ""
"    // This function *cannot* be used by anything else in the crate. It is not\n"
"    // publicly visible outside of the `crate_helper_module`, so only this\n"
"    // current module and its descendants may access it.\n"
"    fn implementation_detail() {}\n"
"}\n"
msgstr ""

#. type: Plain text
#: doc/rust.md:1610
msgid ""
"// This function is \"public to the root\" meaning that it's available to "
"external // crates linking against this one.  pub fn public_api() {}"
msgstr ""

#. type: Plain text
#: doc/rust.md:1615
#, no-wrap
msgid ""
"// Similarly to 'public_api', this module is public so external crates may look\n"
"// inside of it.\n"
"pub mod submodule {\n"
"    use crate_helper_module;\n"
msgstr ""

#. type: Plain text
#: doc/rust.md:1621
#, no-wrap
msgid ""
"    pub fn my_method() {\n"
"        // Any item in the local crate may invoke the helper module's public\n"
"        // interface through a combination of the two rules above.\n"
"        crate_helper_module::crate_helper();\n"
"    }\n"
msgstr ""

#. type: Plain text
#: doc/rust.md:1625
#, no-wrap
msgid ""
"    // This function is hidden to any module which is not a descendant of\n"
"    // `submodule`\n"
"    fn my_implementation() {}\n"
msgstr ""

#. type: Plain text
#: doc/rust.md:1628
#, no-wrap
msgid ""
"    #[cfg(test)]\n"
"    mod test {\n"
msgstr ""

#. type: Plain text
#: doc/rust.md:1638
#, no-wrap
msgid ""
"        #[test]\n"
"        fn test_my_implementation() {\n"
"            // Because this module is a descendant of `submodule`, it's allowed\n"
"            // to access private items inside of `submodule` without a privacy\n"
"            // violation.\n"
"            super::my_implementation();\n"
"        }\n"
"    }\n"
"}\n"
msgstr ""

#. type: Plain text
#: doc/rust.md:1641 doc/rust.md:1662
msgid "# fn main() {} ~~~~"
msgstr ""

#. type: Plain text
#: doc/rust.md:1645
msgid ""
"For a rust program to pass the privacy checking pass, all paths must be "
"valid accesses given the two rules above. This includes all use statements, "
"expressions, types, etc."
msgstr ""

#. type: Plain text
#: doc/rust.md:1647
msgid "### Re-exporting and Visibility"
msgstr ""

#. type: Plain text
#: doc/rust.md:1652
msgid ""
"Rust allows publicly re-exporting items through a `pub use` directive. "
"Because this is a public directive, this allows the item to be used in the "
"current module through the rules above. It essentially allows public access "
"into the re-exported item. For example, this program is valid:"
msgstr ""

#. type: Plain text
#: doc/rust.md:1655
msgid "~~~~ pub use api = self::implementation;"
msgstr ""

#. type: Plain text
#: doc/rust.md:1659
#, no-wrap
msgid ""
"mod implementation {\n"
"    pub fn f() {}\n"
"}\n"
msgstr ""

#. type: Plain text
#: doc/rust.md:1665
msgid ""
"This means that any external crate referencing `implementation::f` would "
"receive a privacy violation, while the path `api::f` would be allowed."
msgstr ""

#. type: Plain text
#: doc/rust.md:1669
msgid ""
"When re-exporting a private item, it can be thought of as allowing the "
"\"privacy chain\" being short-circuited through the reexport instead of "
"passing through the namespace hierarchy as it normally would."
msgstr ""

#. type: Plain text
#: doc/rust.md:1671
msgid "### Glob imports and Visibility"
msgstr ""

#. type: Plain text
#: doc/rust.md:1675
msgid ""
"Currently glob imports are considered an \"experimental\" language feature. "
"For sanity purpose along with helping the implementation, glob imports will "
"only import public items from their destination, not private items."
msgstr ""

#. type: Plain text
#: doc/rust.md:1679
msgid ""
"> **Note:** This is subject to change, glob exports may be removed entirely "
"or > they could possibly import private items for a privacy error to later "
"be > issued if the item is used."
msgstr ""

#. type: Plain text
#: doc/rust.md:1681
msgid "## Attributes"
msgstr ""

#. type: Plain text
#: doc/rust.md:1688
#, no-wrap
msgid ""
"~~~~ {.ebnf .gram}\n"
"attribute : '#' '[' attr_list ']' ;\n"
"attr_list : attr [ ',' attr_list ]*\n"
"attr : ident [ '=' literal\n"
"             | '(' attr_list ')' ] ? ;\n"
"~~~~\n"
msgstr ""

#. type: Plain text
#: doc/rust.md:1694
msgid ""
"Static entities in Rust -- crates, modules and items -- may have "
"_attributes_ applied to them. ^[Attributes in Rust are modeled on Attributes "
"in ECMA-335, C#] An attribute is a general, free-form metadatum that is "
"interpreted according to name, convention, and language and compiler "
"version.  Attributes may appear as any of"
msgstr ""

#. type: Bullet: '* '
#: doc/rust.md:1698
msgid "A single identifier, the attribute name"
msgstr ""

#. type: Bullet: '* '
#: doc/rust.md:1698
msgid ""
"An identifier followed by the equals sign '=' and a literal, providing a key/"
"value pair"
msgstr ""

#. type: Bullet: '* '
#: doc/rust.md:1698
msgid ""
"An identifier followed by a parenthesized list of sub-attribute arguments"
msgstr ""

#. type: Plain text
#: doc/rust.md:1701
msgid ""
"Attributes terminated by a semi-colon apply to the entity that the attribute "
"is declared within. Attributes that are not terminated by a semi-colon apply "
"to the next entity."
msgstr ""

#. type: Plain text
#: doc/rust.md:1703
msgid "An example of attributes:"
msgstr ""

#. type: Plain text
#: doc/rust.md:1707
msgid ""
"~~~~ {.xfail-test} // General metadata applied to the enclosing module or "
"crate.  #[license = \"BSD\"];"
msgstr ""

#. type: Plain text
#: doc/rust.md:1713
#, no-wrap
msgid ""
"// A function marked as a unit test\n"
"#[test]\n"
"fn test_foo() {\n"
"  ...\n"
"}\n"
msgstr ""

#. type: Plain text
#: doc/rust.md:1719
#, no-wrap
msgid ""
"// A conditionally-compiled module\n"
"#[cfg(target_os=\"linux\")]\n"
"mod bar {\n"
"  ...\n"
"}\n"
msgstr ""

#. type: Plain text
#: doc/rust.md:1724
msgid ""
"// A lint attribute used to suppress a warning/error "
"#[allow(non_camel_case_types)] pub type int8_t = i8; ~~~~"
msgstr ""

#. type: Plain text
#: doc/rust.md:1727
msgid ""
"> **Note:** In future versions of Rust, user-provided extensions to the "
"compiler will be able to interpret attributes.  > When this facility is "
"provided, the compiler will distinguish between language-reserved and user-"
"available attributes."
msgstr ""

#. type: Plain text
#: doc/rust.md:1730
msgid ""
"At present, only the Rust compiler interprets attributes, so all attribute "
"names are effectively reserved. Some significant attributes include:"
msgstr ""

#. type: Bullet: '* '
#: doc/rust.md:1744
msgid "The `doc` attribute, for documenting code in-place."
msgstr ""

#. type: Bullet: '* '
#: doc/rust.md:1744
msgid ""
"The `cfg` attribute, for conditional-compilation by build-configuration."
msgstr ""

#. type: Bullet: '* '
#: doc/rust.md:1744
msgid ""
"The `lang` attribute, for custom definitions of traits and functions that "
"are known to the Rust compiler (see [Language items](#language-items))."
msgstr ""

#. type: Bullet: '* '
#: doc/rust.md:1744
msgid ""
"The `link` attribute, for describing linkage metadata for a extern blocks."
msgstr ""

#. type: Bullet: '* '
#: doc/rust.md:1744
msgid "The `crate_id` attribute, for describing the package ID of a crate."
msgstr ""

#. type: Bullet: '* '
#: doc/rust.md:1744
msgid "The `test` attribute, for marking functions as unit tests."
msgstr ""

#. type: Bullet: '* '
#: doc/rust.md:1744
msgid ""
"The `allow`, `warn`, `forbid`, and `deny` attributes, for controlling lint "
"checks (see [Lint check attributes](#lint-check-attributes))."
msgstr ""

#. type: Bullet: '* '
#: doc/rust.md:1744
msgid ""
"The `deriving` attribute, for automatically generating implementations of "
"certain traits."
msgstr ""

#. type: Bullet: '* '
#: doc/rust.md:1744
msgid ""
"The `static_assert` attribute, for asserting that a static bool is true at "
"compiletime"
msgstr ""

#. type: Bullet: '* '
#: doc/rust.md:1744
msgid ""
"The `thread_local` attribute, for defining a `static mut` as a thread-local. "
"Note that this is only a low-level building block, and is not local to a "
"*task*, nor does it provide safety."
msgstr ""

#. type: Plain text
#: doc/rust.md:1746
msgid ""
"Other attributes may be added or removed during development of the language."
msgstr ""

#. type: Plain text
#: doc/rust.md:1748
msgid "### Lint check attributes"
msgstr ""

#. type: Plain text
#: doc/rust.md:1752
msgid ""
"A lint check names a potentially undesirable coding pattern, such as "
"unreachable code or omitted documentation, for the static entity to which "
"the attribute applies."
msgstr ""

#. type: Plain text
#: doc/rust.md:1754
msgid "For any lint check `C`:"
msgstr ""

#. type: Bullet: ' * '
#: doc/rust.md:1761
msgid "`warn(C)` warns about violations of `C` but continues compilation,"
msgstr ""

#. type: Bullet: ' * '
#: doc/rust.md:1761
msgid "`deny(C)` signals an error after encountering a violation of `C`,"
msgstr ""

#. type: Plain text
#: doc/rust.md:1761
#, no-wrap
msgid ""
" * `allow(C)` overrides the check for `C` so that violations will go\n"
"    unreported,\n"
" * `forbid(C)` is the same as `deny(C)`, but also forbids uses of\n"
"   `allow(C)` within the entity.\n"
msgstr ""

#. type: Plain text
#: doc/rust.md:1764
msgid ""
"The lint checks supported by the compiler can be found via `rustc -W help`, "
"along with their default settings."
msgstr ""

#. type: Plain text
#: doc/rust.md:1770
#, no-wrap
msgid ""
"~~~~ {.xfail-test}\n"
"mod m1 {\n"
"    // Missing documentation is ignored here\n"
"    #[allow(missing_doc)]\n"
"    pub fn undocumented_one() -> int { 1 }\n"
msgstr ""

#. type: Plain text
#: doc/rust.md:1774
#, no-wrap
msgid ""
"    // Missing documentation signals a warning here\n"
"    #[warn(missing_doc)]\n"
"    pub fn undocumented_too() -> int { 2 }\n"
msgstr ""

#. type: Plain text
#: doc/rust.md:1780
#, no-wrap
msgid ""
"    // Missing documentation signals an error here\n"
"    #[deny(missing_doc)]\n"
"    pub fn undocumented_end() -> int { 3 }\n"
"}\n"
"~~~~\n"
msgstr ""

#. type: Plain text
#: doc/rust.md:1783
msgid ""
"This example shows how one can use `allow` and `warn` to toggle a particular "
"check on and off."
msgstr ""

#. type: Plain text
#: doc/rust.md:1791
#, no-wrap
msgid ""
"~~~~ {.xfail-test}\n"
"#[warn(missing_doc)]\n"
"mod m2{\n"
"    #[allow(missing_doc)]\n"
"    mod nested {\n"
"        // Missing documentation is ignored here\n"
"        pub fn undocumented_one() -> int { 1 }\n"
msgstr ""

#. type: Plain text
#: doc/rust.md:1797
#, no-wrap
msgid ""
"        // Missing documentation signals a warning here,\n"
"        // despite the allow above.\n"
"        #[warn(missing_doc)]\n"
"        pub fn undocumented_two() -> int { 2 }\n"
"    }\n"
msgstr ""

#. type: Plain text
#: doc/rust.md:1802
#, no-wrap
msgid ""
"    // Missing documentation signals a warning here\n"
"    pub fn undocumented_too() -> int { 3 }\n"
"}\n"
"~~~~\n"
msgstr ""

#. type: Plain text
#: doc/rust.md:1805
msgid ""
"This example shows how one can use `forbid` to disallow uses of `allow` for "
"that lint check."
msgstr ""

#. type: Plain text
#: doc/rust.md:1815
#, no-wrap
msgid ""
"~~~~ {.xfail-test}\n"
"#[forbid(missing_doc)]\n"
"mod m3 {\n"
"    // Attempting to toggle warning signals an error here\n"
"    #[allow(missing_doc)]\n"
"    /// Returns 2.\n"
"    pub fn undocumented_too() -> int { 2 }\n"
"}\n"
"~~~~\n"
msgstr ""

#. type: Plain text
#: doc/rust.md:1817
msgid "### Language items"
msgstr ""

#. type: Plain text
#: doc/rust.md:1823
msgid ""
"Some primitive Rust operations are defined in Rust code, rather than being "
"implemented directly in C or assembly language.  The definitions of these "
"operations have to be easy for the compiler to find.  The `lang` attribute "
"makes it possible to declare these operations.  For example, the `str` "
"module in the Rust standard library defines the string equality function:"
msgstr ""

#. type: Plain text
#: doc/rust.md:1830
#, no-wrap
msgid ""
"~~~~ {.xfail-test}\n"
"#[lang=\"str_eq\"]\n"
"pub fn eq_slice(a: &str, b: &str) -> bool {\n"
"    // details elided\n"
"}\n"
"~~~~\n"
msgstr ""

#. type: Plain text
#: doc/rust.md:1834
msgid ""
"The name `str_eq` has a special meaning to the Rust compiler, and the "
"presence of this definition means that it will use this definition when "
"generating calls to the string equality function."
msgstr ""

#. type: Plain text
#: doc/rust.md:1836
msgid "A complete list of the built-in language items follows:"
msgstr ""

#. type: Plain text
#: doc/rust.md:1838
msgid "#### Traits"
msgstr ""

#. type: Plain text
#: doc/rust.md:1877
#, no-wrap
msgid ""
"`const`\n"
"  : Cannot be mutated.\n"
"`owned`\n"
"  : Are uniquely owned.\n"
"`durable`\n"
"  : Contain borrowed pointers.\n"
"`drop`\n"
"  : Have finalizers.\n"
"`add`\n"
"  : Elements can be added (for example, integers and floats).\n"
"`sub`\n"
"  : Elements can be subtracted.\n"
"`mul`\n"
"  : Elements can be multiplied.\n"
"`div`\n"
"  : Elements have a division operation.\n"
"`rem`\n"
"  : Elements have a remainder operation.\n"
"`neg`\n"
"  : Elements can be negated arithmetically.\n"
"`not`\n"
"  : Elements can be negated logically.\n"
"`bitxor`\n"
"  : Elements have an exclusive-or operation.\n"
"`bitand`\n"
"  : Elements have a bitwise `and` operation.\n"
"`bitor`\n"
"  : Elements have a bitwise `or` operation.\n"
"`shl`\n"
"  : Elements have a left shift operation.\n"
"`shr`\n"
"  : Elements have a right shift operation.\n"
"`index`\n"
"  : Elements can be indexed.\n"
"`eq`\n"
"  : Elements can be compared for equality.\n"
"`ord`\n"
"  : Elements have a partial ordering.\n"
msgstr ""

#. type: Plain text
#: doc/rust.md:1879
msgid "#### Operations"
msgstr ""

#. type: Plain text
#: doc/rust.md:1909
#, no-wrap
msgid ""
"`str_eq`\n"
"  : Compare two strings for equality.\n"
"`uniq_str_eq`\n"
"  : Compare two owned strings for equality.\n"
"`annihilate`\n"
"  : Destroy a box before freeing it.\n"
"`log_type`\n"
"  : Generically print a string representation of any type.\n"
"`fail_`\n"
"  : Abort the program with an error.\n"
"`fail_bounds_check`\n"
"  : Abort the program with a bounds check error.\n"
"`exchange_malloc`\n"
"  : Allocate memory on the exchange heap.\n"
"`exchange_free`\n"
"  : Free memory that was allocated on the exchange heap.\n"
"`malloc`\n"
"  : Allocate memory on the managed heap.\n"
"`free`\n"
"  : Free memory that was allocated on the managed heap.\n"
"`borrow_as_imm`\n"
"  : Create an immutable borrowed pointer to a mutable value.\n"
"`return_to_mut`\n"
"  : Release a borrowed pointer created with `return_to_mut`\n"
"`check_not_borrowed`\n"
"  : Fail if a value has existing borrowed pointers to it.\n"
"`strdup_uniq`\n"
"  : Return a new unique string\n"
"    containing a copy of the contents of a unique string.\n"
msgstr ""

#. type: Plain text
#: doc/rust.md:1912
msgid ""
"> **Note:** This list is likely to become out of date. We should auto-"
"generate it > from `librustc/middle/lang_items.rs`."
msgstr ""

#. type: Plain text
#: doc/rust.md:1914
msgid "### Deriving"
msgstr ""

#. type: Plain text
#: doc/rust.md:1920
msgid ""
"The `deriving` attribute allows certain traits to be automatically "
"implemented for data structures. For example, the following will create an "
"`impl` for the `Eq` and `Clone` traits for `Foo`, the type parameter `T` "
"will be given the `Eq` or `Clone` constraints for the appropriate `impl`:"
msgstr ""

#. type: Plain text
#: doc/rust.md:1928
#, no-wrap
msgid ""
"~~~~\n"
"#[deriving(Eq, Clone)]\n"
"struct Foo<T> {\n"
"    a: int,\n"
"    b: T\n"
"}\n"
"~~~~\n"
msgstr ""

#. type: Plain text
#: doc/rust.md:1930
msgid "The generated `impl` for `Eq` is equivalent to"
msgstr ""

#. type: Plain text
#: doc/rust.md:1937
#, no-wrap
msgid ""
"~~~~\n"
"# struct Foo<T> { a: int, b: T }\n"
"impl<T: Eq> Eq for Foo<T> {\n"
"    fn eq(&self, other: &Foo<T>) -> bool {\n"
"        self.a == other.a && self.b == other.b\n"
"    }\n"
msgstr ""

#. type: Plain text
#: doc/rust.md:1943
#, no-wrap
msgid ""
"    fn ne(&self, other: &Foo<T>) -> bool {\n"
"        self.a != other.a || self.b != other.b\n"
"    }\n"
"}\n"
"~~~~\n"
msgstr ""

#. type: Plain text
#: doc/rust.md:1945
msgid "Supported traits for `deriving` are:"
msgstr ""

#. type: Bullet: '* '
#: doc/rust.md:1958
msgid "Comparison traits: `Eq`, `TotalEq`, `Ord`, `TotalOrd`."
msgstr ""

#. type: Bullet: '* '
#: doc/rust.md:1958
msgid "Serialization: `Encodable`, `Decodable`. These require `extra`."
msgstr ""

#. type: Bullet: '* '
#: doc/rust.md:1958
msgid "`Clone` and `DeepClone`, to perform (deep) copies."
msgstr ""

#. type: Bullet: '* '
#: doc/rust.md:1958
msgid "`IterBytes`, to iterate over the bytes in a data type."
msgstr ""

#. type: Bullet: '* '
#: doc/rust.md:1958
msgid "`Rand`, to create a random instance of a data type."
msgstr ""

#. type: Bullet: '* '
#: doc/rust.md:1958
msgid "`Default`, to create an empty instance of a data type."
msgstr ""

#. type: Bullet: '* '
#: doc/rust.md:1958
msgid "`Zero`, to create an zero instance of a numeric data type."
msgstr ""

#. type: Bullet: '* '
#: doc/rust.md:1958
msgid ""
"`ToStr`, to convert to a string. For a type with this instance, `obj."
"to_str()` has similar output as `fmt!(\"%?\", obj)`, but it differs in that "
"each constituent field of the type must also implement `ToStr` and will have "
"`field.to_str()` invoked to build up the result."
msgstr ""

#. type: Bullet: '* '
#: doc/rust.md:1958
msgid "`FromPrimitive`, to create an instance from a numeric primitve."
msgstr ""

#. type: Plain text
#: doc/rust.md:1961
msgid ""
"### Stability One can indicate the stability of an API using the following "
"attributes:"
msgstr ""

#. type: Bullet: '* '
#: doc/rust.md:1975
msgid ""
"`deprecated`: This item should no longer be used, e.g. it has been replaced. "
"No guarantee of backwards-compatibility."
msgstr ""

#. type: Bullet: '* '
#: doc/rust.md:1975
msgid ""
"`experimental`: This item was only recently introduced or is otherwise in a "
"state of flux. It may change significantly, or even be removed. No guarantee "
"of backwards-compatibility."
msgstr ""

#. type: Bullet: '* '
#: doc/rust.md:1975
msgid ""
"`unstable`: This item is still under development, but requires more testing "
"to be considered stable. No guarantee of backwards-compatibility."
msgstr ""

#. type: Bullet: '* '
#: doc/rust.md:1975
msgid ""
"`stable`: This item is considered stable, and will not change significantly. "
"Guarantee of backwards-compatibility."
msgstr ""

#. type: Bullet: '* '
#: doc/rust.md:1975
msgid ""
"`frozen`: This item is very stable, and is unlikely to change. Guarantee of "
"backwards-compatibility."
msgstr ""

#. type: Bullet: '* '
#: doc/rust.md:1975
msgid ""
"`locked`: This item will never change unless a serious bug is found. "
"Guarantee of backwards-compatibility."
msgstr ""

#. type: Plain text
#: doc/rust.md:1978
msgid ""
"These levels are directly inspired by [Node.js' \"stability index\"](http://"
"nodejs.org/api/documentation.html)."
msgstr ""

#. type: Plain text
#: doc/rust.md:1984
msgid ""
"There are lints for disallowing items marked with certain levels: "
"`deprecated`, `experimental` and `unstable`; the first two will warn by "
"default. Items with not marked with a stability are considered to be "
"unstable for the purposes of the lint. One can give an optional string that "
"will be displayed when the lint flags the use of an item."
msgstr ""

#. type: Plain text
#: doc/rust.md:1987
msgid "~~~~ {.xfail-test} #[warn(unstable)];"
msgstr ""

#. type: Plain text
#: doc/rust.md:1992
#, no-wrap
msgid ""
"#[deprecated=\"replaced by `best`\"]\n"
"fn bad() {\n"
"    // delete everything\n"
"}\n"
msgstr ""

#. type: Plain text
#: doc/rust.md:1996
#, no-wrap
msgid ""
"fn better() {\n"
"    // delete fewer things\n"
"}\n"
msgstr ""

#. type: Plain text
#: doc/rust.md:2001
#, no-wrap
msgid ""
"#[stable]\n"
"fn best() {\n"
"    // delete nothing\n"
"}\n"
msgstr ""

#. type: Plain text
#: doc/rust.md:2004
#, no-wrap
msgid ""
"fn main() {\n"
"    bad(); // \"warning: use of deprecated item: replaced by `best`\"\n"
msgstr ""

#. type: Plain text
#: doc/rust.md:2006
#, no-wrap
msgid "    better(); // \"warning: use of unmarked item\"\n"
msgstr ""

#. type: Plain text
#: doc/rust.md:2010
#, no-wrap
msgid ""
"    best(); // no warning\n"
"}\n"
"~~~~\n"
msgstr ""

#. type: Plain text
#: doc/rust.md:2014
msgid ""
"> **Note:** Currently these are only checked when applied to > individual "
"functions, structs, methods and enum variants, *not* to > entire modules, "
"traits, impls or enums themselves."
msgstr ""

#. type: Plain text
#: doc/rust.md:2016
msgid "### Compiler Features"
msgstr ""

#. type: Plain text
#: doc/rust.md:2021
msgid ""
"Certain aspects of Rust may be implemented in the compiler, but they're not "
"necessarily ready for every-day use. These features are often of \"prototype "
"quality\" or \"almost production ready\", but may not be stable enough to be "
"considered a full-fleged language feature."
msgstr ""

#. type: Plain text
#: doc/rust.md:2023
msgid ""
"For this reason, rust recognizes a special crate-level attribute of the form:"
msgstr ""

#. type: Plain text
#: doc/rust.md:2027
msgid "~~~~ {.xfail-test} #[feature(feature1, feature2, feature3)] ~~~~"
msgstr ""

#. type: Plain text
#: doc/rust.md:2032
msgid ""
"This directive informs the compiler that the feature list: `feature1`, "
"`feature2`, and `feature3` should all be enabled. This is only recognized at "
"a crate-level, not at a module-level. Without this directive, all features "
"are considered off, and using the features will result in a compiler error."
msgstr ""

#. type: Plain text
#: doc/rust.md:2034
msgid "The currently implemented features of the compiler are:"
msgstr ""

#. type: Plain text
#: doc/rust.md:2043
#, no-wrap
msgid ""
"* `macro_rules` - The definition of new macros. This does not encompass\n"
"                  macro-invocation, that is always enabled by default, this only\n"
"                  covers the definition of new macros. There are currently\n"
"                  various problems with invoking macros, how they interact with\n"
"                  their environment, and possibly how they are used outside of\n"
"                  location in which they are defined. Macro definitions are\n"
"                  likely to change slightly in the future, so they are currently\n"
"                  hidden behind this feature.\n"
msgstr ""

#. type: Plain text
#: doc/rust.md:2048
#, no-wrap
msgid ""
"* `globs` - Importing everything in a module through `*`. This is currently a\n"
"            large source of bugs in name resolution for Rust, and it's not clear\n"
"            whether this will continue as a feature or not. For these reasons,\n"
"            the glob import statement has been hidden behind this feature flag.\n"
msgstr ""

#. type: Plain text
#: doc/rust.md:2055
#, no-wrap
msgid ""
"* `struct_variant` - Structural enum variants (those with named fields). It is\n"
"                     currently unknown whether this style of enum variant is as\n"
"                     fully supported as the tuple-forms, and it's not certain\n"
"                     that this style of variant should remain in the language.\n"
"                     For now this style of variant is hidden behind a feature\n"
"                     flag.\n"
msgstr ""

#. type: Plain text
#: doc/rust.md:2059
#, no-wrap
msgid ""
"* `once_fns` - Onceness guarantees a closure is only executed once. Defining a\n"
"               closure as `once` is unlikely to be supported going forward. So\n"
"               they are hidden behind this feature until they are to be removed.\n"
msgstr ""

#. type: Plain text
#: doc/rust.md:2066
#, no-wrap
msgid ""
"* `managed_boxes` - Usage of `@` pointers is gated due to many\n"
"                    planned changes to this feature. In the past, this has meant\n"
"                    \"a GC pointer\", but the current implementation uses\n"
"                    reference counting and will likely change drastically over\n"
"                    time. Additionally, the `@` syntax will no longer be used to\n"
"                    create GC boxes.\n"
msgstr ""

#. type: Plain text
#: doc/rust.md:2070
#, no-wrap
msgid ""
"* `asm` - The `asm!` macro provides a means for inline assembly. This is often\n"
"          useful, but the exact syntax for this feature along with its semantics\n"
"          are likely to change, so this macro usage must be opted into.\n"
msgstr ""

#. type: Plain text
#: doc/rust.md:2076
#, no-wrap
msgid ""
"* `non_ascii_idents` - The compiler supports the use of non-ascii identifiers,\n"
"                       but the implementation is a little rough around the\n"
"                       edges, so this can be seen as an experimental feature for\n"
"                       now until the specification of identifiers is fully\n"
"                       fleshed out.\n"
msgstr ""

#. type: Plain text
#: doc/rust.md:2085
#, no-wrap
msgid ""
"* `thread_local` - The usage of the `#[thread_local]` attribute is experimental\n"
"                   and should be seen as unstable. This attribute is used to\n"
"                   declare a `static` as being unique per-thread leveraging\n"
"                   LLVM's implementation which works in concert with the kernel\n"
"                   loader and dynamic linker. This is not necessarily available\n"
"                   on all platforms, and usage of it is discouraged (rust\n"
"                   focuses more on task-local data instead of thread-local\n"
"                   data).\n"
msgstr ""

#. type: Plain text
#: doc/rust.md:2091
#, no-wrap
msgid ""
"* `link_args` - This attribute is used to specify custom flags to the linker,\n"
"                but usage is strongly discouraged. The compiler's usage of the\n"
"                system linker is not guaranteed to continue in the future, and\n"
"                if the system linker is not used then specifying custom flags\n"
"                doesn't have much meaning.\n"
msgstr ""

#. type: Plain text
#: doc/rust.md:2099
msgid ""
"If a feature is promoted to a language feature, then all existing programs "
"will start to receive compilation warnings about #[feature] directives which "
"enabled the new feature (because the directive is no longer necessary). "
"However, if a feature is decided to be removed from the language, errors "
"will be issued (if there isn't a parser error first). The directive in this "
"case is no longer necessary, and it's likely that existing code will break "
"if the feature isn't removed."
msgstr ""

#. type: Plain text
#: doc/rust.md:2102
msgid ""
"If a unknown feature is found in a directive, it results in a compiler "
"error. An unknown feature is one which has never been recognized by the "
"compiler."
msgstr ""

#. type: Plain text
#: doc/rust.md:2104
msgid "# Statements and expressions"
msgstr ""

#. type: Plain text
#: doc/rust.md:2111
msgid ""
"Rust is _primarily_ an expression language. This means that most forms of "
"value-producing or effect-causing evaluation are directed by the uniform "
"syntax category of _expressions_. Each kind of expression can typically "
"_nest_ within each other kind of expression, and rules for evaluation of "
"expressions involve specifying both the value produced by the expression and "
"the order in which its sub-expressions are themselves evaluated."
msgstr ""

#. type: Plain text
#: doc/rust.md:2114
msgid ""
"In contrast, statements in Rust serve _mostly_ to contain and explicitly "
"sequence expression evaluation."
msgstr ""

#. type: Plain text
#: doc/rust.md:2116
msgid "## Statements"
msgstr ""

#. type: Plain text
#: doc/rust.md:2119
msgid ""
"A _statement_ is a component of a block, which is in turn a component of an "
"outer [expression](#expressions) or [function](#functions)."
msgstr ""

#. type: Plain text
#: doc/rust.md:2123
msgid ""
"Rust has two kinds of statement: [declaration statements](#declaration-"
"statements) and [expression statements](#expression-statements)."
msgstr ""

#. type: Plain text
#: doc/rust.md:2125
msgid "### Declaration statements"
msgstr ""

#. type: Plain text
#: doc/rust.md:2128
msgid ""
"A _declaration statement_ is one that introduces one or more *names* into "
"the enclosing statement block.  The declared names may denote new slots or "
"new items."
msgstr ""

#. type: Plain text
#: doc/rust.md:2130
msgid "#### Item declarations"
msgstr ""

#. type: Plain text
#: doc/rust.md:2137
msgid ""
"An _item declaration statement_ has a syntactic form identical to an [item]"
"(#items) declaration within a module. Declaring an item -- a function, "
"enumeration, structure, type, static, trait, implementation or module -- "
"locally within a statement block is simply a way of restricting its scope to "
"a narrow region containing all of its uses; it is otherwise identical in "
"meaning to declaring the item outside the statement block."
msgstr ""

#. type: Plain text
#: doc/rust.md:2140
msgid ""
"Note: there is no implicit capture of the function's dynamic environment "
"when declaring a function-local item."
msgstr ""

#. type: Plain text
#: doc/rust.md:2142
msgid "#### Slot declarations"
msgstr ""

#. type: Plain text
#: doc/rust.md:2147
msgid ""
"~~~~ {.ebnf .gram} let_decl : \"let\" pat [':' type ] ? [ init ] ? ';' ; "
"init : [ '=' ] expr ; ~~~~"
msgstr ""

#. type: Plain text
#: doc/rust.md:2153
msgid ""
"A _slot declaration_ introduces a new set of slots, given by a pattern.  The "
"pattern may be followed by a type annotation, and/or an initializer "
"expression.  When no type annotation is given, the compiler will infer the "
"type, or signal an error if insufficient type information is available for "
"definite inference.  Any slots introduced by a slot declaration are visible "
"from the point of declaration until the end of the enclosing block scope."
msgstr ""

#. type: Plain text
#: doc/rust.md:2155
msgid "### Expression statements"
msgstr ""

#. type: Plain text
#: doc/rust.md:2160
msgid ""
"An _expression statement_ is one that evaluates an [expression]"
"(#expressions)  and ignores its result.  The type of an expression statement "
"`e;` is always `()`, regardless of the type of `e`.  As a rule, an "
"expression statement's purpose is to trigger the effects of evaluating its "
"expression."
msgstr ""

#. type: Plain text
#: doc/rust.md:2162
msgid "## Expressions"
msgstr ""

#. type: Plain text
#: doc/rust.md:2171
#, no-wrap
msgid ""
"An expression may have two roles: it always produces a *value*, and it may have *effects*\n"
"(otherwise known as \"side effects\").\n"
"An expression *evaluates to* a value, and has effects during *evaluation*.\n"
"Many expressions contain sub-expressions (operands).\n"
"The meaning of each kind of expression dictates several things:\n"
"  * Whether or not to evaluate the sub-expressions when evaluating the expression\n"
"  * The order in which to evaluate the sub-expressions\n"
"  * How to combine the sub-expressions' values to obtain the value of the expression.\n"
msgstr ""

#. type: Plain text
#: doc/rust.md:2176
msgid ""
"In this way, the structure of expressions dictates the structure of "
"execution.  Blocks are just another kind of expression, so blocks, "
"statements, expressions, and blocks again can recursively nest inside each "
"other to an arbitrary depth."
msgstr ""

#. type: Plain text
#: doc/rust.md:2178
msgid "#### Lvalues, rvalues and temporaries"
msgstr ""

#. type: Plain text
#: doc/rust.md:2182
msgid ""
"Expressions are divided into two main categories: _lvalues_ and _rvalues_.  "
"Likewise within each expression, sub-expressions may occur in _lvalue "
"context_ or _rvalue context_.  The evaluation of an expression depends both "
"on its own category and the context it occurs within."
msgstr ""

#. type: Plain text
#: doc/rust.md:2189
msgid ""
"An lvalue is an expression that represents a memory location. These "
"expressions are [paths](#path-expressions) (which refer to local variables, "
"function and method arguments, or static variables), dereferences (`*expr`), "
"[indexing expressions](#index-expressions)  (`expr[expr]`), and [field "
"references](#field-expressions) (`expr.f`).  All other expressions are "
"rvalues."
msgstr ""

#. type: Plain text
#: doc/rust.md:2197
msgid ""
"The left operand of an [assignment](#assignment-expressions), [binary move]"
"(#binary-move-expressions) or [compound-assignment](#compound-assignment-"
"expressions) expression is an lvalue context, as is the single operand of a "
"unary [borrow](#unary-operator-expressions), or [move](#unary-move-"
"expressions) expression, and _both_ operands of a [swap](#swap-expressions) "
"expression.  All other expression contexts are rvalue contexts."
msgstr ""

#. type: Plain text
#: doc/rust.md:2200
msgid ""
"When an lvalue is evaluated in an _lvalue context_, it denotes a memory "
"location; when evaluated in an _rvalue context_, it denotes the value held "
"_in_ that memory location."
msgstr ""

#. type: Plain text
#: doc/rust.md:2203
msgid ""
"When an rvalue is used in lvalue context, a temporary un-named lvalue is "
"created and used instead.  A temporary's lifetime equals the largest "
"lifetime of any borrowed pointer that points to it."
msgstr ""

#. type: Plain text
#: doc/rust.md:2205
msgid "#### Moved and copied types"
msgstr ""

#. type: Plain text
#: doc/rust.md:2214
msgid ""
"When a [local variable](#memory-slots) is used as an [rvalue](#lvalues-"
"rvalues-and-temporaries)  the variable will either be [moved](#move-"
"expressions) or copied, depending on its type.  For types that contain "
"[owning pointers](#owning-pointers)  or values that implement the special "
"trait `Drop`, the variable is moved.  All other types are copied."
msgstr ""

#. type: Plain text
#: doc/rust.md:2216
msgid "### Literal expressions"
msgstr ""

#. type: Plain text
#: doc/rust.md:2220
msgid ""
"A _literal expression_ consists of one of the [literal](#literals)  forms "
"described earlier. It directly describes a number, character, string, "
"boolean value, or the unit value."
msgstr ""

#. type: Plain text
#: doc/rust.md:2227
#, no-wrap
msgid ""
"~~~~ {.literals}\n"
"();        // unit type\n"
"\"hello\";   // string type\n"
"'5';       // character type\n"
"5;         // integer type\n"
"~~~~\n"
msgstr ""

#. type: Plain text
#: doc/rust.md:2229
msgid "### Path expressions"
msgstr ""

#. type: Plain text
#: doc/rust.md:2232
msgid ""
"A [path](#paths) used as an expression context denotes either a local "
"variable or an item.  Path expressions are [lvalues](#lvalues-rvalues-and-"
"temporaries)."
msgstr ""

#. type: Plain text
#: doc/rust.md:2234
msgid "### Tuple expressions"
msgstr ""

#. type: Plain text
#: doc/rust.md:2238
msgid ""
"Tuples are written by enclosing one or more comma-separated expressions in "
"parentheses. They are used to create [tuple-typed](#tuple-types)  values."
msgstr ""

#. type: Plain text
#: doc/rust.md:2244
msgid "~~~~ {.tuple} (0,); (0.0, 4.5); (\"a\", 4u, true); ~~~~"
msgstr ""

#. type: Plain text
#: doc/rust.md:2246
msgid "### Structure expressions"
msgstr ""

#. type: Plain text
#: doc/rust.md:2255
#, no-wrap
msgid ""
"~~~~ {.ebnf .gram}\n"
"struct_expr : expr_path '{' ident ':' expr\n"
"                      [ ',' ident ':' expr ] *\n"
"                      [ \"..\" expr ] '}' |\n"
"              expr_path '(' expr\n"
"                      [ ',' expr ] * ')' |\n"
"              expr_path\n"
"~~~~\n"
msgstr ""

#. type: Plain text
#: doc/rust.md:2262
msgid ""
"There are several forms of structure expressions.  A _structure expression_ "
"consists of the [path](#paths) of a [structure item](#structures), followed "
"by a brace-enclosed list of one or more comma-separated name-value pairs, "
"providing the field values of a new instance of the structure.  A field name "
"can be any identifier, and is separated from its value expression by a "
"colon.  The location denoted by a structure field is mutable if and only if "
"the enclosing structure is mutable."
msgstr ""

#. type: Plain text
#: doc/rust.md:2267
msgid ""
"A _tuple structure expression_ consists of the [path](#paths) of a "
"[structure item](#structures), followed by a parenthesized list of one or "
"more comma-separated expressions (in other words, the path of a structure "
"item followed by a tuple expression).  The structure item must be a tuple "
"structure item."
msgstr ""

#. type: Plain text
#: doc/rust.md:2269
msgid ""
"A _unit-like structure expression_ consists only of the [path](#paths) of a "
"[structure item](#structures)."
msgstr ""

#. type: Plain text
#: doc/rust.md:2271
msgid "The following are examples of structure expressions:"
msgstr ""

#. type: Plain text
#: doc/rust.md:2282
msgid ""
"~~~~ # struct Point { x: f64, y: f64 } # struct TuplePoint(f64, f64); # mod "
"game { pub struct User<'a> { name: &'a str, age: uint, score: uint } } # "
"struct Cookie; fn some_fn<T>(t: T) {} Point {x: 10.0, y: 20.0}; "
"TuplePoint(10.0, 20.0); let u = game::User {name: \"Joe\", age: 35, score: "
"100_000}; some_fn::<Cookie>(Cookie); ~~~~"
msgstr ""

#. type: Plain text
#: doc/rust.md:2285
msgid ""
"A structure expression forms a new value of the named structure type.  Note "
"that for a given *unit-like* structure type, this will always be the same "
"value."
msgstr ""

#. type: Plain text
#: doc/rust.md:2292
msgid ""
"A structure expression can terminate with the syntax `..` followed by an "
"expression to denote a functional update.  The expression following `..` "
"(the base) must have the same structure type as the new structure type being "
"formed.  The entire expression denotes the result of allocating a new "
"structure (with the same type as the base expression)  with the given values "
"for the fields that were explicitly specified and the values in the base "
"record for all other fields."
msgstr ""

#. type: Plain text
#: doc/rust.md:2298
msgid ""
"~~~~ # struct Point3d { x: int, y: int, z: int } let base = Point3d {x: 1, "
"y: 2, z: 3}; Point3d {y: 0, z: 10, .. base}; ~~~~"
msgstr ""

#. type: Plain text
#: doc/rust.md:2300
msgid "### Record expressions"
msgstr ""

#. type: Plain text
#: doc/rust.md:2306
#, no-wrap
msgid ""
"~~~~ {.ebnf .gram}\n"
"rec_expr : '{' ident ':' expr\n"
"               [ ',' ident ':' expr ] *\n"
"               [ \"..\" expr ] '}'\n"
"~~~~\n"
msgstr ""

#. type: Plain text
#: doc/rust.md:2308
msgid "### Method-call expressions"
msgstr ""

#. type: Plain text
#: doc/rust.md:2312
msgid ""
"~~~~ {.ebnf .gram} method_call_expr : expr '.' ident paren_expr_list ; ~~~~"
msgstr ""

#. type: Plain text
#: doc/rust.md:2317
msgid ""
"A _method call_ consists of an expression followed by a single dot, an "
"identifier, and a parenthesized expression-list.  Method calls are resolved "
"to methods on specific traits, either statically dispatching to a method if "
"the exact `self`-type of the left-hand-side is known, or dynamically "
"dispatching if the left-hand-side expression is an indirect [object type]"
"(#object-types)."
msgstr ""

#. type: Plain text
#: doc/rust.md:2319
msgid "### Field expressions"
msgstr ""

#. type: Plain text
#: doc/rust.md:2323
msgid "~~~~ {.ebnf .gram} field_expr : expr '.' ident ~~~~"
msgstr ""

#. type: Plain text
#: doc/rust.md:2327
msgid ""
"A _field expression_ consists of an expression followed by a single dot and "
"an identifier, when not immediately followed by a parenthesized expression-"
"list (the latter is a [method call expression](#method-call-expressions)).  "
"A field expression denotes a field of a [structure](#structure-types)."
msgstr ""

#. type: Plain text
#: doc/rust.md:2332
msgid "~~~~ {.field} myrecord.myfield; {a: 10, b: 20}.a; ~~~~"
msgstr ""

#. type: Plain text
#: doc/rust.md:2335
msgid ""
"A field access on a record is an [lvalue](#lvalues-rvalues-and-temporaries) "
"referring to the value of that field.  When the field is mutable, it can be "
"[assigned](#assignment-expressions) to."
msgstr ""

#. type: Plain text
#: doc/rust.md:2338
msgid ""
"When the type of the expression to the left of the dot is a pointer to a "
"record or structure, it is automatically dereferenced to make the field "
"access possible."
msgstr ""

#. type: Plain text
#: doc/rust.md:2340
msgid "### Vector expressions"
msgstr ""

#. type: Plain text
#: doc/rust.md:2343
msgid "~~~~ {.ebnf .gram} vec_expr : '[' \"mut\" ? vec_elems? ']'"
msgstr ""

#. type: Plain text
#: doc/rust.md:2346
msgid "vec_elems : [expr [',' expr]*] | [expr ',' \"..\" expr] ~~~~"
msgstr ""

#. type: Plain text
#: doc/rust.md:2349
msgid ""
"A [_vector_](#vector-types) _expression_ is written by enclosing zero or "
"more comma-separated expressions of uniform type in square brackets."
msgstr ""

#. type: Plain text
#: doc/rust.md:2353
msgid ""
"In the `[expr ',' \"..\" expr]` form, the expression after the `\"..\"` must "
"be a constant expression that can be evaluated at compile time, such as a "
"[literal](#literals) or a [static item](#static-items)."
msgstr ""

#. type: Plain text
#: doc/rust.md:2360
#, no-wrap
msgid ""
"~~~~\n"
"[1, 2, 3, 4];\n"
"[\"a\", \"b\", \"c\", \"d\"];\n"
"[0, ..128];             // vector with 128 zeros\n"
"[0u8, 0u8, 0u8, 0u8];\n"
"~~~~\n"
msgstr ""

#. type: Plain text
#: doc/rust.md:2362
msgid "### Index expressions"
msgstr ""

#. type: Plain text
#: doc/rust.md:2366
msgid "~~~~ {.ebnf .gram} idx_expr : expr '[' expr ']' ~~~~"
msgstr ""

#. type: Plain text
#: doc/rust.md:2370
msgid ""
"[Vector](#vector-types)-typed expressions can be indexed by writing a square-"
"bracket-enclosed expression (the index) after them. When the vector is "
"mutable, the resulting [lvalue](#lvalues-rvalues-and-temporaries) can be "
"assigned to."
msgstr ""

#. type: Plain text
#: doc/rust.md:2374
msgid ""
"Indices are zero-based, and may be of any integral type. Vector access is "
"bounds-checked at run-time. When the check fails, it will put the task in a "
"_failing state_."
msgstr ""

#. type: Plain text
#: doc/rust.md:2378
msgid "~~~~ {.xfail-test} # use std::task; # do task::spawn {"
msgstr ""

#. type: Plain text
#: doc/rust.md:2381
msgid "([1, 2, 3, 4])[0]; ([\"a\", \"b\"])[10]; // fails"
msgstr ""

#. type: Plain text
#: doc/rust.md:2386
msgid "### Unary operator expressions"
msgstr ""

#. type: Plain text
#: doc/rust.md:2390
msgid ""
"Rust defines six symbolic unary operators.  They are all written as prefix "
"operators, before the expression they apply to."
msgstr ""

#. type: Plain text
#: doc/rust.md:2409
#, no-wrap
msgid ""
"`-`\n"
"  : Negation. May only be applied to numeric types.\n"
"`*`\n"
"  : Dereference. When applied to a [pointer](#pointer-types) it denotes the pointed-to location.\n"
"    For pointers to mutable locations, the resulting [lvalue](#lvalues-rvalues-and-temporaries) can be assigned to.\n"
"    For [enums](#enumerated-types) that have only a single variant, containing a single parameter,\n"
"    the dereference operator accesses this parameter.\n"
"`!`\n"
"  : Logical negation. On the boolean type, this flips between `true` and\n"
"    `false`. On integer types, this inverts the individual bits in the\n"
"    two's complement representation of the value.\n"
"`@` and `~`\n"
"  :  [Boxing](#pointer-types) operators. Allocate a box to hold the value they are applied to,\n"
"     and store the value in it. `@` creates a managed box, whereas `~` creates an owned box.\n"
"`&`\n"
"  : Borrow operator. Returns a borrowed pointer, pointing to its operand.\n"
"    The operand of a borrowed pointer is statically proven to outlive the resulting pointer.\n"
"    If the borrow-checker cannot prove this, it is a compilation error.\n"
msgstr ""

#. type: Plain text
#: doc/rust.md:2411
msgid "### Binary operator expressions"
msgstr ""

#. type: Plain text
#: doc/rust.md:2415
msgid "~~~~ {.ebnf .gram} binop_expr : expr binop expr ; ~~~~"
msgstr ""

#. type: Plain text
#: doc/rust.md:2418
msgid ""
"Binary operators expressions are given in terms of [operator precedence]"
"(#operator-precedence)."
msgstr ""

#. type: Plain text
#: doc/rust.md:2420
msgid "#### Arithmetic operators"
msgstr ""

#. type: Plain text
#: doc/rust.md:2425
msgid ""
"Binary arithmetic expressions are syntactic sugar for calls to built-in "
"traits, defined in the `std::ops` module of the `std` library.  This means "
"that arithmetic operators can be overridden for user-defined types.  The "
"default meaning of the operators on standard types is given here."
msgstr ""

#. type: Plain text
#: doc/rust.md:2441
#, no-wrap
msgid ""
"`+`\n"
"  : Addition and vector/string concatenation.\n"
"    Calls the `add` method on the `std::ops::Add` trait.\n"
"`-`\n"
"  : Subtraction.\n"
"    Calls the `sub` method on the `std::ops::Sub` trait.\n"
"`*`\n"
"  : Multiplication.\n"
"    Calls the `mul` method on the `std::ops::Mul` trait.\n"
"`/`\n"
"  : Quotient.\n"
"    Calls the `div` method on the `std::ops::Div` trait.\n"
"`%`\n"
"  : Remainder.\n"
"    Calls the `rem` method on the `std::ops::Rem` trait.\n"
msgstr ""

#. type: Plain text
#: doc/rust.md:2443
msgid "#### Bitwise operators"
msgstr ""

#. type: Plain text
#: doc/rust.md:2448
msgid ""
"Like the [arithmetic operators](#arithmetic-operators), bitwise operators "
"are syntactic sugar for calls to methods of built-in traits.  This means "
"that bitwise operators can be overridden for user-defined types.  The "
"default meaning of the operators on standard types is given here."
msgstr ""

#. type: Plain text
#: doc/rust.md:2464
#, no-wrap
msgid ""
"`&`\n"
"  : And.\n"
"    Calls the `bitand` method of the `std::ops::BitAnd` trait.\n"
"`|`\n"
"  : Inclusive or.\n"
"    Calls the `bitor` method of the `std::ops::BitOr` trait.\n"
"`^`\n"
"  : Exclusive or.\n"
"    Calls the `bitxor` method of the `std::ops::BitXor` trait.\n"
"`<<`\n"
"  : Logical left shift.\n"
"    Calls the `shl` method of the `std::ops::Shl` trait.\n"
"`>>`\n"
"  : Logical right shift.\n"
"    Calls the `shr` method of the `std::ops::Shr` trait.\n"
msgstr ""

#. type: Plain text
#: doc/rust.md:2466
msgid "#### Lazy boolean operators"
msgstr ""

#. type: Plain text
#: doc/rust.md:2473
msgid ""
"The operators `||` and `&&` may be applied to operands of boolean type.  The "
"`||` operator denotes logical 'or', and the `&&` operator denotes logical "
"'and'.  They differ from `|` and `&` in that the right-hand operand is only "
"evaluated when the left-hand operand does not already determine the result "
"of the expression.  That is, `||` only evaluates its right-hand operand when "
"the left-hand operand evaluates to `false`, and `&&` only when it evaluates "
"to `true`."
msgstr ""

#. type: Plain text
#: doc/rust.md:2475
msgid "#### Comparison operators"
msgstr ""

#. type: Plain text
#: doc/rust.md:2481
msgid ""
"Comparison operators are, like the [arithmetic operators](#arithmetic-"
"operators), and [bitwise operators](#bitwise-operators), syntactic sugar for "
"calls to built-in traits.  This means that comparison operators can be "
"overridden for user-defined types.  The default meaning of the operators on "
"standard types is given here."
msgstr ""

#. type: Plain text
#: doc/rust.md:2500
#, no-wrap
msgid ""
"`==`\n"
"  : Equal to.\n"
"    Calls the `eq` method on the `std::cmp::Eq` trait.\n"
"`!=`\n"
"  : Unequal to.\n"
"    Calls the `ne` method on the `std::cmp::Eq` trait.\n"
"`<`\n"
"  : Less than.\n"
"    Calls the `lt` method on the `std::cmp::Ord` trait.\n"
"`>`\n"
"  : Greater than.\n"
"    Calls the `gt` method on the `std::cmp::Ord` trait.\n"
"`<=`\n"
"  : Less than or equal.\n"
"    Calls the `le` method on the `std::cmp::Ord` trait.\n"
"`>=`\n"
"  : Greater than or equal.\n"
"    Calls the `ge` method on the `std::cmp::Ord` trait.\n"
msgstr ""

#. type: Plain text
#: doc/rust.md:2502
msgid "#### Type cast expressions"
msgstr ""

#. type: Plain text
#: doc/rust.md:2504
msgid "A type cast expression is denoted with the binary operator `as`."
msgstr ""

#. type: Plain text
#: doc/rust.md:2507
msgid ""
"Executing an `as` expression casts the value on the left-hand side to the "
"type on the right-hand side."
msgstr ""

#. type: Plain text
#: doc/rust.md:2511
msgid ""
"A numeric value can be cast to any numeric type.  A raw pointer value can be "
"cast to or from any integral type or raw pointer type.  Any other cast is "
"unsupported and will fail to compile."
msgstr ""

#. type: Plain text
#: doc/rust.md:2513
msgid "An example of an `as` expression:"
msgstr ""

#. type: Plain text
#: doc/rust.md:2517
msgid ""
"~~~~ # fn sum(v: &[f64]) -> f64 { 0.0 } # fn len(v: &[f64]) -> int { 0 }"
msgstr ""

#. type: Plain text
#: doc/rust.md:2524
#, no-wrap
msgid ""
"fn avg(v: &[f64]) -> f64 {\n"
"  let sum: f64 = sum(v);\n"
"  let sz: f64 = len(v) as f64;\n"
"  return sum / sz;\n"
"}\n"
"~~~~\n"
msgstr ""

#. type: Plain text
#: doc/rust.md:2526
msgid "#### Assignment expressions"
msgstr ""

#. type: Plain text
#: doc/rust.md:2529
msgid ""
"An _assignment expression_ consists of an [lvalue](#lvalues-rvalues-and-"
"temporaries) expression followed by an equals sign (`=`) and an [rvalue]"
"(#lvalues-rvalues-and-temporaries) expression."
msgstr ""

#. type: Plain text
#: doc/rust.md:2531
msgid ""
"Evaluating an assignment expression [either copies or moves](#moved-and-"
"copied-types) its right-hand operand to its left-hand operand."
msgstr ""

#. type: Plain text
#: doc/rust.md:2535
msgid "~~~~ # let mut x = 0; # let y = 0;"
msgstr ""

#. type: Plain text
#: doc/rust.md:2538
msgid "x = y; ~~~~"
msgstr ""

#. type: Plain text
#: doc/rust.md:2540
msgid "#### Compound assignment expressions"
msgstr ""

#. type: Plain text
#: doc/rust.md:2545
msgid ""
"The `+`, `-`, `*`, `/`, `%`, `&`, `|`, `^`, `<<`, and `>>` operators may be "
"composed with the `=` operator. The expression `lval OP= val` is equivalent "
"to `lval = lval OP val`. For example, `x = x + 1` may be written as `x += 1`."
msgstr ""

#. type: Plain text
#: doc/rust.md:2547
msgid "Any such expression always has the [`unit`](#primitive-types) type."
msgstr ""

#. type: Plain text
#: doc/rust.md:2549
msgid "#### Operator precedence"
msgstr ""

#. type: Plain text
#: doc/rust.md:2552
msgid ""
"The precedence of Rust binary operators is ordered as follows, going from "
"strong to weak:"
msgstr ""

#. type: Plain text
#: doc/rust.md:2565
#, no-wrap
msgid ""
"~~~~ {.precedence}\n"
"* / %\n"
"as\n"
"+ -\n"
"<< >>\n"
"&\n"
"^\n"
"|\n"
"< > <= >=\n"
"== !=\n"
"&&\n"
"||\n"
"=\n"
msgstr ""

#. type: Plain text
#: doc/rust.md:2570
msgid ""
"Operators at the same precedence level are evaluated left-to-right. [Unary "
"operators](#unary-operator-expressions)  have the same precedence level and "
"it is stronger than any of the binary operators'."
msgstr ""

#. type: Plain text
#: doc/rust.md:2572
msgid "### Grouped expressions"
msgstr ""

#. type: Plain text
#: doc/rust.md:2576
msgid ""
"An expression enclosed in parentheses evaluates to the result of the "
"enclosed expression.  Parentheses can be used to explicitly specify "
"evaluation order within an expression."
msgstr ""

#. type: Plain text
#: doc/rust.md:2580
msgid "~~~~ {.ebnf .gram} paren_expr : '(' expr ')' ; ~~~~"
msgstr ""

#. type: Plain text
#: doc/rust.md:2582
msgid "An example of a parenthesized expression:"
msgstr ""

#. type: Plain text
#: doc/rust.md:2586
msgid "~~~~ let x = (2 + 3) * 4; ~~~~"
msgstr ""

#. type: Plain text
#: doc/rust.md:2589
msgid "### Call expressions"
msgstr ""

#. type: Plain text
#: doc/rust.md:2595
msgid ""
"~~~~ {.abnf .gram} expr_list : [ expr [ ',' expr ]* ] ? ; paren_expr_list : "
"'(' expr_list ')' ; call_expr : expr paren_expr_list ; ~~~~"
msgstr ""

#. type: Plain text
#: doc/rust.md:2600
msgid ""
"A _call expression_ invokes a function, providing zero or more input slots "
"and an optional reference slot to serve as the function's output, bound to "
"the `lval` on the right hand side of the call. If the function eventually "
"returns, then the expression completes."
msgstr ""

#. type: Plain text
#: doc/rust.md:2602
msgid "Some examples of call expressions:"
msgstr ""

#. type: Plain text
#: doc/rust.md:2606
msgid ""
"~~~~ # use std::from_str::FromStr; # fn add(x: int, y: int) -> int { 0 }"
msgstr ""

#. type: Plain text
#: doc/rust.md:2610
msgid ""
"let x: int = add(1, 2); let pi: Option<f32> = FromStr::from_str(\"3.14\"); "
"~~~~"
msgstr ""

#. type: Plain text
#: doc/rust.md:2612
msgid "### Lambda expressions"
msgstr ""

#. type: Plain text
#: doc/rust.md:2617
msgid ""
"~~~~ {.abnf .gram} ident_list : [ ident [ ',' ident ]* ] ? ; lambda_expr : "
"'|' ident_list '|' expr ; ~~~~"
msgstr ""

#. type: Plain text
#: doc/rust.md:2621
msgid ""
"A _lambda expression_ (sometimes called an \"anonymous function expression"
"\") defines a function and denotes it as a value, in a single expression.  A "
"lambda expression is a pipe-symbol-delimited (`|`) list of identifiers "
"followed by an expression."
msgstr ""

#. type: Plain text
#: doc/rust.md:2626
msgid ""
"A lambda expression denotes a function that maps a list of parameters "
"(`ident_list`)  onto the expression that follows the `ident_list`.  The "
"identifiers in the `ident_list` are the parameters to the function.  These "
"parameters' types need not be specified, as the compiler infers them from "
"context."
msgstr ""

#. type: Plain text
#: doc/rust.md:2629
msgid ""
"Lambda expressions are most useful when passing functions as arguments to "
"other functions, as an abbreviation for defining and capturing a separate "
"function."
msgstr ""

#. type: Plain text
#: doc/rust.md:2638
msgid ""
"Significantly, lambda expressions _capture their environment_, which regular "
"[function definitions](#functions) do not.  The exact type of capture "
"depends on the [function type](#function-types) inferred for the lambda "
"expression.  In the simplest and least-expensive form (analogous to a ```|| "
"{ }``` expression), the lambda expression captures its environment by "
"reference, effectively borrowing pointers to all outer variables mentioned "
"inside the function.  Alternately, the compiler may infer that a lambda "
"expression should copy or move values (depending on their type.)  from the "
"environment into the lambda expression's captured environment."
msgstr ""

#. type: Plain text
#: doc/rust.md:2641
msgid ""
"In this example, we define a function `ten_times` that takes a higher-order "
"function argument, and call it with a lambda expression as an argument."
msgstr ""

#. type: Plain text
#: doc/rust.md:2650
#, no-wrap
msgid ""
"~~~~\n"
"fn ten_times(f: |int|) {\n"
"    let mut i = 0;\n"
"    while i < 10 {\n"
"        f(i);\n"
"        i += 1;\n"
"    }\n"
"}\n"
msgstr ""

#. type: Plain text
#: doc/rust.md:2653
msgid "ten_times(|j| println!(\"hello, {}\", j)); ~~~~"
msgstr ""

#. type: Plain text
#: doc/rust.md:2655
msgid "### While loops"
msgstr ""

#. type: Plain text
#: doc/rust.md:2659
msgid "~~~~ {.ebnf .gram} while_expr : \"while\" expr '{' block '}' ; ~~~~"
msgstr ""

#. type: Plain text
#: doc/rust.md:2664
msgid ""
"A `while` loop begins by evaluating the boolean loop conditional "
"expression.  If the loop conditional expression evaluates to `true`, the "
"loop body block executes and control returns to the loop conditional "
"expression. If the loop conditional expression evaluates to `false`, the "
"`while` expression completes."
msgstr ""

#. type: Plain text
#: doc/rust.md:2666
msgid "An example:"
msgstr ""

#. type: Plain text
#: doc/rust.md:2669
msgid "~~~~ let mut i = 0;"
msgstr ""

#. type: Plain text
#: doc/rust.md:2675
#, no-wrap
msgid ""
"while i < 10 {\n"
"    println(\"hello\\n\");\n"
"    i = i + 1;\n"
"}\n"
"~~~~\n"
msgstr ""

#. type: Plain text
#: doc/rust.md:2677
msgid "### Infinite loops"
msgstr ""

#. type: Plain text
#: doc/rust.md:2681
msgid ""
"The keyword `loop` in Rust appears both in _loop expressions_ and in "
"_continue expressions_.  A loop expression denotes an infinite loop; see "
"[Continue expressions](#continue-expressions) for continue expressions."
msgstr ""

#. type: Plain text
#: doc/rust.md:2685
msgid ""
"~~~~ {.ebnf .gram} loop_expr : [ lifetime ':' ] \"loop\" '{' block '}'; ~~~~"
msgstr ""

#. type: Plain text
#: doc/rust.md:2690
msgid ""
"A `loop` expression may optionally have a _label_.  If a label is present, "
"then labeled `break` and `loop` expressions nested within this loop may exit "
"out of this loop or return control to its head.  See [Break expressions]"
"(#break-expressions)."
msgstr ""

#. type: Plain text
#: doc/rust.md:2692
msgid "### Break expressions"
msgstr ""

#. type: Plain text
#: doc/rust.md:2696
msgid "~~~~ {.ebnf .gram} break_expr : \"break\" [ lifetime ]; ~~~~"
msgstr ""

#. type: Plain text
#: doc/rust.md:2703
msgid ""
"A `break` expression has an optional `label`.  If the label is absent, then "
"executing a `break` expression immediately terminates the innermost loop "
"enclosing it.  It is only permitted in the body of a loop.  If the label is "
"present, then `break foo` terminates the loop with label `foo`, which need "
"not be the innermost label enclosing the `break` expression, but must "
"enclose it."
msgstr ""

#. type: Plain text
#: doc/rust.md:2705
msgid "### Continue expressions"
msgstr ""

#. type: Plain text
#: doc/rust.md:2709
msgid "~~~~ {.ebnf .gram} continue_expr : \"loop\" [ lifetime ]; ~~~~"
msgstr ""

#. type: Plain text
#: doc/rust.md:2720
msgid ""
"A continue expression, written `loop`, also has an optional `label`.  If the "
"label is absent, then executing a `loop` expression immediately terminates "
"the current iteration of the innermost loop enclosing it, returning control "
"to the loop *head*.  In the case of a `while` loop, the head is the "
"conditional expression controlling the loop.  In the case of a `for` loop, "
"the head is the call-expression controlling the loop.  If the label is "
"present, then `loop foo` returns control to the head of the loop with label "
"`foo`, which need not be the innermost label enclosing the `break` "
"expression, but must enclose it."
msgstr ""

#. type: Plain text
#: doc/rust.md:2722
msgid "A `loop` expression is only permitted in the body of a loop."
msgstr ""

#. type: Plain text
#: doc/rust.md:2724
msgid "### Do expressions"
msgstr ""

#. type: Plain text
#: doc/rust.md:2728
msgid ""
"~~~~ {.ebnf .gram} do_expr : \"do\" expr [ '|' ident_list '|' ] ? '{' block "
"'}' ; ~~~~"
msgstr ""

#. type: Plain text
#: doc/rust.md:2731
msgid ""
"A _do expression_ provides a more-familiar block syntax for invoking a "
"function and passing it a newly-created a procedure."
msgstr ""

#. type: Plain text
#: doc/rust.md:2735
msgid ""
"The optional `ident_list` and `block` provided in a `do` expression are "
"parsed as though they constitute a procedure expression; if the `ident_list` "
"is missing, an empty `ident_list` is implied."
msgstr ""

#. type: Plain text
#: doc/rust.md:2742
msgid ""
"The procedure expression is then provided as a _trailing argument_ to the "
"outermost [call](#call-expressions) or [method call](#method-call-"
"expressions) expression in the `expr` following `do`.  If the `expr` is a "
"[path expression](#path-expressions), it is parsed as though it is a call "
"expression.  If the `expr` is a [field expression](#field-expressions), it "
"is parsed as though it is a method call expression."
msgstr ""

#. type: Plain text
#: doc/rust.md:2744
msgid "In this example, both calls to `f` are equivalent:"
msgstr ""

#. type: Plain text
#: doc/rust.md:2748
msgid "~~~~ # fn f(f: proc(int)) { } # fn g(i: int) { }"
msgstr ""

#. type: Plain text
#: doc/rust.md:2750
msgid "f(proc(j) { g(j) });"
msgstr ""

#. type: Plain text
#: doc/rust.md:2755
#, no-wrap
msgid ""
"do f |j| {\n"
"    g(j);\n"
"}\n"
"~~~~\n"
msgstr ""

#. type: Plain text
#: doc/rust.md:2757
msgid ""
"In this example, both calls to the (binary) function `k` are equivalent:"
msgstr ""

#. type: Plain text
#: doc/rust.md:2761
msgid "~~~~ # fn k(x:int, f: proc(int)) { } # fn l(i: int) { }"
msgstr ""

#. type: Plain text
#: doc/rust.md:2763
msgid "k(3, proc(j) { l(j) });"
msgstr ""

#. type: Plain text
#: doc/rust.md:2768
#, no-wrap
msgid ""
"do k(3) |j| {\n"
"   l(j);\n"
"}\n"
"~~~~\n"
msgstr ""

#. type: Plain text
#: doc/rust.md:2770
msgid "### For expressions"
msgstr ""

#. type: Plain text
#: doc/rust.md:2774
msgid ""
"~~~~ {.ebnf .gram} for_expr : \"for\" pat \"in\" expr '{' block '}' ; ~~~~"
msgstr ""

#. type: Plain text
#: doc/rust.md:2777
msgid ""
"A `for` expression is a syntactic construct for looping over elements "
"provided by an implementation of `std::iter::Iterator`."
msgstr ""

#. type: Plain text
#: doc/rust.md:2779
msgid "An example of a for loop over the contents of a vector:"
msgstr ""

#. type: Plain text
#: doc/rust.md:2786
msgid ""
"~~~~ # type foo = int; # fn bar(f: foo) { } # let a = 0; # let b = 0; # let "
"c = 0;"
msgstr ""

#. type: Plain text
#: doc/rust.md:2788
msgid "let v: &[foo] = &[a, b, c];"
msgstr ""

#. type: Plain text
#: doc/rust.md:2793
#, no-wrap
msgid ""
"for e in v.iter() {\n"
"    bar(*e);\n"
"}\n"
"~~~~\n"
msgstr ""

#. type: Plain text
#: doc/rust.md:2795
msgid "An example of a for loop over a series of integers:"
msgstr ""

#. type: Plain text
#: doc/rust.md:2802
#, no-wrap
msgid ""
"~~~~\n"
"# fn bar(b:uint) { }\n"
"for i in range(0u, 256) {\n"
"    bar(i);\n"
"}\n"
"~~~~\n"
msgstr ""

#. type: Plain text
#: doc/rust.md:2804
msgid "### If expressions"
msgstr ""

#. type: Plain text
#: doc/rust.md:2808
#, no-wrap
msgid ""
"~~~~ {.ebnf .gram}\n"
"if_expr : \"if\" expr '{' block '}'\n"
"          else_tail ? ;\n"
msgstr ""

#. type: Plain text
#: doc/rust.md:2812
#, no-wrap
msgid ""
"else_tail : \"else\" [ if_expr\n"
"                   | '{' block '}' ] ;\n"
"~~~~\n"
msgstr ""

#. type: Plain text
#: doc/rust.md:2823
msgid ""
"An `if` expression is a conditional branch in program control. The form of "
"an `if` expression is a condition expression, followed by a consequent "
"block, any number of `else if` conditions and blocks, and an optional "
"trailing `else` block. The condition expressions must have type `bool`. If a "
"condition expression evaluates to `true`, the consequent block is executed "
"and any subsequent `else if` or `else` block is skipped. If a condition "
"expression evaluates to `false`, the consequent block is skipped and any "
"subsequent `else if` condition is evaluated. If all `if` and `else if` "
"conditions evaluate to `false` then any `else` block is executed."
msgstr ""

#. type: Plain text
#: doc/rust.md:2825
msgid "### Match expressions"
msgstr ""

#. type: Plain text
#: doc/rust.md:2828
msgid ""
"~~~~ {.ebnf .gram} match_expr : \"match\" expr '{' match_arm [ '|' "
"match_arm ] * '}' ;"
msgstr ""

#. type: Plain text
#: doc/rust.md:2830
msgid "match_arm : match_pat '=>' [ expr \",\" | '{' block '}' ] ;"
msgstr ""

#. type: Plain text
#: doc/rust.md:2833
msgid "match_pat : pat [ \"..\" pat ] ? [ \"if\" expr ] ; ~~~~"
msgstr ""

#. type: Plain text
#: doc/rust.md:2840
msgid ""
"A `match` expression branches on a *pattern*. The exact form of matching "
"that occurs depends on the pattern. Patterns consist of some combination of "
"literals, destructured enum constructors, structures, records and tuples, "
"variable binding specifications, wildcards (`*`), and placeholders (`_`). A "
"`match` expression has a *head expression*, which is the value to compare to "
"the patterns. The type of the patterns must equal the type of the head "
"expression."
msgstr ""

#. type: Plain text
#: doc/rust.md:2844
msgid ""
"In a pattern whose head expression has an `enum` type, a placeholder (`_`) "
"stands for a *single* data field, whereas a wildcard `..` stands for *all* "
"the fields of a particular variant. For example:"
msgstr ""

#. type: Plain text
#: doc/rust.md:2847
msgid "~~~~ enum List<X> { Nil, Cons(X, @List<X>) }"
msgstr ""

#. type: Plain text
#: doc/rust.md:2849 doc/rust.md:2877
msgid "let x: List<int> = Cons(10, @Cons(11, @Nil));"
msgstr ""

#. type: Plain text
#: doc/rust.md:2856
#, no-wrap
msgid ""
"match x {\n"
"    Cons(_, @Nil) => fail!(\"singleton list\"),\n"
"    Cons(..)      => return,\n"
"    Nil           => fail!(\"empty list\")\n"
"}\n"
"~~~~\n"
msgstr ""

#. type: Plain text
#: doc/rust.md:2861
msgid ""
"The first pattern matches lists constructed by applying `Cons` to any head "
"value, and a tail value of `@Nil`. The second pattern matches _any_ list "
"constructed with `Cons`, ignoring the values of its arguments. The "
"difference between `_` and `*` is that the pattern `C(_)` is only type-"
"correct if `C` has exactly one argument, while the pattern `C(..)` is type-"
"correct for any enum variant `C`, regardless of how many arguments `C` has."
msgstr ""

#. type: Plain text
#: doc/rust.md:2867
msgid ""
"To execute an `match` expression, first the head expression is evaluated, "
"then its value is sequentially compared to the patterns in the arms until a "
"match is found. The first arm with a matching pattern is chosen as the "
"branch target of the `match`, any variables bound by the pattern are "
"assigned to local variables in the arm's block, and control enters the block."
msgstr ""

#. type: Plain text
#: doc/rust.md:2869
msgid "An example of an `match` expression:"
msgstr ""

#. type: Plain text
#: doc/rust.md:2873
msgid "~~~~ # fn process_pair(a: int, b: int) { } # fn process_ten() { }"
msgstr ""

#. type: Plain text
#: doc/rust.md:2875
msgid "enum List<X> { Nil, Cons(X, @List<X>) }"
msgstr ""

#. type: Plain text
#: doc/rust.md:2893
#, no-wrap
msgid ""
"match x {\n"
"    Cons(a, @Cons(b, _)) => {\n"
"        process_pair(a,b);\n"
"    }\n"
"    Cons(10, _) => {\n"
"        process_ten();\n"
"    }\n"
"    Nil => {\n"
"        return;\n"
"    }\n"
"    _ => {\n"
"        fail!();\n"
"    }\n"
"}\n"
"~~~~\n"
msgstr ""

#. type: Plain text
#: doc/rust.md:2900
msgid ""
"Patterns that bind variables default to binding to a copy or move of the "
"matched value (depending on the matched value's type).  This can be changed "
"to bind to a borrowed pointer by using the ```ref``` keyword, or to a "
"mutable borrowed pointer using ```ref mut```."
msgstr ""

#. type: Plain text
#: doc/rust.md:2911
msgid ""
"A pattern that's just an identifier, like `Nil` in the previous answer, "
"could either refer to an enum variant that's in scope, or bind a new "
"variable.  The compiler resolves this ambiguity by forbidding variable "
"bindings that occur in ```match``` patterns from shadowing names of variants "
"that are in scope.  For example, wherever ```List``` is in scope, a "
"```match``` pattern would not be able to bind ```Nil``` as a new name.  The "
"compiler interprets a variable pattern `x` as a binding _only_ if there is "
"no variant named `x` in scope.  A convention you can use to avoid conflicts "
"is simply to name variants with upper-case letters, and local variables with "
"lower-case letters."
msgstr ""

#. type: Plain text
#: doc/rust.md:2915
msgid ""
"Multiple match patterns may be joined with the `|` operator.  A range of "
"values may be specified with `..`.  For example:"
msgstr ""

#. type: Plain text
#: doc/rust.md:2918
msgid "~~~~ # let x = 2;"
msgstr ""

#. type: Plain text
#: doc/rust.md:2925
#, no-wrap
msgid ""
"let message = match x {\n"
"  0 | 1  => \"not many\",\n"
"  2 .. 9 => \"a few\",\n"
"  _      => \"lots\"\n"
"};\n"
"~~~~\n"
msgstr ""

#. type: Plain text
#: doc/rust.md:2929
msgid ""
"Range patterns only work on scalar types (like integers and characters; not "
"like vectors and structs, which have sub-components).  A range pattern may "
"not be a sub-range of another range pattern inside the same `match`."
msgstr ""

#. type: Plain text
#: doc/rust.md:2934
msgid ""
"Finally, match patterns can accept *pattern guards* to further refine the "
"criteria for matching a case. Pattern guards appear after the pattern and "
"consist of a bool-typed expression following the `if` keyword. A pattern "
"guard may refer to the variables bound within the pattern they follow."
msgstr ""

#. type: Plain text
#: doc/rust.md:2939
msgid ""
"~~~~ # let maybe_digit = Some(0); # fn process_digit(i: int) { } # fn "
"process_other(i: int) { }"
msgstr ""

#. type: Plain text
#: doc/rust.md:2946
#, no-wrap
msgid ""
"let message = match maybe_digit {\n"
"  Some(x) if x < 10 => process_digit(x),\n"
"  Some(x) => process_other(x),\n"
"  None => fail!()\n"
"};\n"
"~~~~\n"
msgstr ""

#. type: Plain text
#: doc/rust.md:2948
msgid "### Return expressions"
msgstr ""

#. type: Plain text
#: doc/rust.md:2952
msgid "~~~~ {.ebnf .gram} return_expr : \"return\" expr ? ; ~~~~"
msgstr ""

#. type: Plain text
#: doc/rust.md:2957
msgid ""
"Return expressions are denoted with the keyword `return`. Evaluating a "
"`return` expression moves its argument into the output slot of the current "
"function, destroys the current function activation frame, and transfers "
"control to the caller frame."
msgstr ""

#. type: Plain text
#: doc/rust.md:2959
msgid "An example of a `return` expression:"
msgstr ""

#. type: Plain text
#: doc/rust.md:2968
#, no-wrap
msgid ""
"~~~~\n"
"fn max(a: int, b: int) -> int {\n"
"   if a > b {\n"
"      return a;\n"
"   }\n"
"   return b;\n"
"}\n"
"~~~~\n"
msgstr ""

#. type: Plain text
#: doc/rust.md:2972
msgid "## Types"
msgstr ""

#. type: Plain text
#: doc/rust.md:2975
msgid ""
"Every slot, item and value in a Rust program has a type. The _type_ of a "
"*value* defines the interpretation of the memory holding it."
msgstr ""

#. type: Plain text
#: doc/rust.md:2979
msgid ""
"Built-in types and type-constructors are tightly integrated into the "
"language, in nontrivial ways that are not possible to emulate in user-"
"defined types. User-defined types have limited capabilities."
msgstr ""

#. type: Plain text
#: doc/rust.md:2981
msgid "### Primitive types"
msgstr ""

#. type: Plain text
#: doc/rust.md:2983
msgid "The primitive types are the following:"
msgstr ""

#. type: Bullet: '* '
#: doc/rust.md:2989
msgid ""
"The \"unit\" type `()`, having the single \"unit\" value `()` (occasionally "
"called \"nil\").  ^[The \"unit\" value `()` is *not* a sentinel \"null "
"pointer\" value for reference slots; the \"unit\" type is the implicit "
"return type from functions otherwise lacking a return type, and can be used "
"in other contexts (such as message-sending or type-parametric code) as a "
"zero-size type.]"
msgstr ""

#. type: Bullet: '* '
#: doc/rust.md:2989
msgid "The boolean type `bool` with values `true` and `false`."
msgstr ""

#. type: Bullet: '* '
#: doc/rust.md:2989
msgid "The machine types."
msgstr ""

#. type: Bullet: '* '
#: doc/rust.md:2989
msgid "The machine-dependent integer and floating-point types."
msgstr ""

#. type: Plain text
#: doc/rust.md:2991
msgid "#### Machine types"
msgstr ""

#. type: Plain text
#: doc/rust.md:2993
msgid "The machine types are the following:"
msgstr ""

#. type: Bullet: '* '
#: doc/rust.md:2997
msgid ""
"The unsigned word types `u8`, `u16`, `u32` and `u64`, with values drawn from "
"the integer intervals $[0, 2^8 - 1]$, $[0, 2^{16} - 1]$, $[0, 2^{32} - 1]$ "
"and $[0, 2^{64} - 1]$ respectively."
msgstr ""

#. type: Bullet: '* '
#: doc/rust.md:3002
msgid ""
"The signed two's complement word types `i8`, `i16`, `i32` and `i64`, with "
"values drawn from the integer intervals $[-(2^7), 2^7 - 1]$, $[-(2^{15}), "
"2^{15} - 1]$, $[-(2^{31}), 2^{31} - 1]$, $[-(2^{63}), 2^{63} - 1]$ "
"respectively."
msgstr ""

#. type: Bullet: '* '
#: doc/rust.md:3005
msgid ""
"The IEEE 754-2008 `binary32` and `binary64` floating-point types: `f32` and "
"`f64`, respectively."
msgstr ""

#. type: Plain text
#: doc/rust.md:3007
msgid "#### Machine-dependent integer types"
msgstr ""

#. type: Plain text
#: doc/rust.md:3012
msgid ""
"The Rust type `uint`^[A Rust `uint` is analogous to a C99 `uintptr_t`.] is "
"an unsigned integer type with target-machine-dependent size. Its size, in "
"bits, is equal to the number of bits required to hold any memory address on "
"the target machine."
msgstr ""

#. type: Plain text
#: doc/rust.md:3017
msgid ""
"The Rust type `int`^[A Rust `int` is analogous to a C99 `intptr_t`.] is a "
"two's complement signed integer type with target-machine-dependent size. Its "
"size, in bits, is equal to the size of the rust type `uint` on the same "
"target machine."
msgstr ""

#. type: Plain text
#: doc/rust.md:3019
msgid "### Textual types"
msgstr ""

#. type: Plain text
#: doc/rust.md:3021
msgid "The types `char` and `str` hold textual data."
msgstr ""

#. type: Plain text
#: doc/rust.md:3024
msgid ""
"A value of type `char` is a Unicode character, represented as a 32-bit "
"unsigned word holding a UCS-4 codepoint."
msgstr ""

#. type: Plain text
#: doc/rust.md:3030
msgid ""
"A value of type `str` is a Unicode string, represented as a vector of 8-bit "
"unsigned bytes holding a sequence of UTF-8 codepoints.  Since `str` is of "
"unknown size, it is not a _first class_ type, but can only be instantiated "
"through a pointer type, such as `&str`, `@str` or `~str`."
msgstr ""

#. type: Plain text
#: doc/rust.md:3032
msgid "### Tuple types"
msgstr ""

#. type: Plain text
#: doc/rust.md:3035
msgid ""
"The tuple type-constructor forms a new heterogeneous product of values "
"similar to the record type-constructor. The differences are as follows:"
msgstr ""

#. type: Bullet: '* '
#: doc/rust.md:3038
msgid "tuple elements cannot be mutable, unlike record fields"
msgstr ""

#. type: Bullet: '* '
#: doc/rust.md:3038
msgid ""
"tuple elements are not named and can be accessed only by pattern-matching"
msgstr ""

#. type: Plain text
#: doc/rust.md:3042
msgid ""
"Tuple types and values are denoted by listing the types or values of their "
"elements, respectively, in a parenthesized, comma-separated list."
msgstr ""

#. type: Plain text
#: doc/rust.md:3045
msgid ""
"The members of a tuple are laid out in memory contiguously, like a record, "
"in order specified by the tuple type."
msgstr ""

#. type: Plain text
#: doc/rust.md:3047
msgid "An example of a tuple type and its use:"
msgstr ""

#. type: Plain text
#: doc/rust.md:3054
msgid ""
"~~~~ type Pair<'a> = (int,&'a str); let p: Pair<'static> = (10,\"hello\"); "
"let (a, b) = p; assert!(b != \"world\"); ~~~~"
msgstr ""

#. type: Plain text
#: doc/rust.md:3056
msgid "### Vector types"
msgstr ""

#. type: Plain text
#: doc/rust.md:3068
msgid ""
"The vector type constructor represents a homogeneous array of values of a "
"given type.  A vector has a fixed size.  (Operations like `vec.push` operate "
"solely on owned vectors.)  A vector type can be annotated with a _definite_ "
"size, such as `[int, ..10]`.  Such a definite-sized vector type is a first-"
"class type, since its size is known statically.  A vector without such a "
"size is said to be of _indefinite_ size, and is therefore not a _first-"
"class_ type.  An indefinite-size vector can only be instantiated through a "
"pointer type, such as `&[T]`, `@[T]` or `~[T]`.  The kind of a vector type "
"depends on the kind of its element type, as with other simple structural "
"types."
msgstr ""

#. type: Plain text
#: doc/rust.md:3072
msgid ""
"Expressions producing vectors of definite size cannot be evaluated in a "
"context expecting a vector of indefinite size; one must copy the definite-"
"sized vector contents into a distinct vector of indefinite size."
msgstr ""

#. type: Plain text
#: doc/rust.md:3074
msgid "An example of a vector type and its use:"
msgstr ""

#. type: Plain text
#: doc/rust.md:3080
msgid ""
"~~~~ let v: &[int] = &[7, 5, 3]; let i: int = v[2]; assert!(i == 3); ~~~~"
msgstr ""

#. type: Plain text
#: doc/rust.md:3083
msgid ""
"All in-bounds elements of a vector are always initialized, and access to a "
"vector is always bounds-checked."
msgstr ""

#. type: Plain text
#: doc/rust.md:3085
msgid "### Structure types"
msgstr ""

#. type: Plain text
#: doc/rust.md:3090
msgid ""
"A `struct` *type* is a heterogeneous product of other types, called the "
"*fields* of the type.  ^[`struct` types are analogous `struct` types in C, "
"the *record* types of the ML family, or the *structure* types of the Lisp "
"family.]"
msgstr ""

#. type: Plain text
#: doc/rust.md:3092
msgid ""
"New instances of a `struct` can be constructed with a [struct expression]"
"(#struct-expressions)."
msgstr ""

#. type: Plain text
#: doc/rust.md:3096
msgid ""
"The memory order of fields in a `struct` is given by the item defining it.  "
"Fields may be given in any order in a corresponding struct *expression*; the "
"resulting `struct` value will always be laid out in memory in the order "
"specified by the corresponding *item*."
msgstr ""

#. type: Plain text
#: doc/rust.md:3099
msgid ""
"The fields of a `struct` may be qualified by [visibility modifiers]"
"(#visibility-modifiers), to restrict access to implementation-private data "
"in a structure."
msgstr ""

#. type: Plain text
#: doc/rust.md:3101
msgid ""
"A _tuple struct_ type is just like a structure type, except that the fields "
"are anonymous."
msgstr ""

#. type: Plain text
#: doc/rust.md:3104
msgid ""
"A _unit-like struct_ type is like a structure type, except that it has no "
"fields.  The one value constructed by the associated [structure expression]"
"(#structure-expression) is the only value that inhabits such a type."
msgstr ""

#. type: Plain text
#: doc/rust.md:3106
msgid "### Enumerated types"
msgstr ""

#. type: Plain text
#: doc/rust.md:3111
msgid ""
"An *enumerated type* is a nominal, heterogeneous disjoint union type, "
"denoted by the name of an [`enum` item](#enumerations).  ^[The `enum` type "
"is analogous to a `data` constructor declaration in ML, or a *pick ADT* in "
"Limbo.]"
msgstr ""

#. type: Plain text
#: doc/rust.md:3114
msgid ""
"An [`enum` item](#enumerations) declares both the type and a number of "
"*variant constructors*, each of which is independently named and takes an "
"optional tuple of arguments."
msgstr ""

#. type: Plain text
#: doc/rust.md:3117
msgid ""
"New instances of an `enum` can be constructed by calling one of the variant "
"constructors, in a [call expression](#call-expressions)."
msgstr ""

#. type: Plain text
#: doc/rust.md:3119
msgid ""
"Any `enum` value consumes as much memory as the largest variant constructor "
"for its corresponding `enum` type."
msgstr ""

#. type: Plain text
#: doc/rust.md:3122
msgid ""
"Enum types cannot be denoted *structurally* as types, but must be denoted by "
"named reference to an [`enum` item](#enumerations)."
msgstr ""

#. type: Plain text
#: doc/rust.md:3124
msgid "### Recursive types"
msgstr ""

#. type: Plain text
#: doc/rust.md:3128
msgid ""
"Nominal types -- [enumerations](#enumerated-types) and [structures]"
"(#structure-types) -- may be recursive.  That is, each `enum` constructor or "
"`struct` field may refer, directly or indirectly, to the enclosing `enum` or "
"`struct` type itself.  Such recursion has restrictions:"
msgstr ""

#. type: Plain text
#: doc/rust.md:3138
#, no-wrap
msgid ""
"* Recursive types must include a nominal type in the recursion\n"
"  (not mere [type definitions](#type-definitions),\n"
"   or other structural types such as [vectors](#vector-types) or [tuples](#tuple-types)).\n"
"* A recursive `enum` item must have at least one non-recursive constructor\n"
"  (in order to give the recursion a basis case).\n"
"* The size of a recursive type must be finite;\n"
"  in other words the recursive fields of the type must be [pointer types](#pointer-types).\n"
"* Recursive type definitions can cross module boundaries, but not module *visibility* boundaries,\n"
"  or crate boundaries (in order to simplify the module system and type checker).\n"
msgstr ""

#. type: Plain text
#: doc/rust.md:3140
msgid "An example of a *recursive* type and its use:"
msgstr ""

#. type: Plain text
#: doc/rust.md:3146
#, no-wrap
msgid ""
"~~~~\n"
"enum List<T> {\n"
"  Nil,\n"
"  Cons(T, @List<T>)\n"
"}\n"
msgstr ""

#. type: Plain text
#: doc/rust.md:3149
msgid "let a: List<int> = Cons(7, @Cons(13, @Nil)); ~~~~"
msgstr ""

#. type: Plain text
#: doc/rust.md:3151
msgid "### Pointer types"
msgstr ""

#. type: Plain text
#: doc/rust.md:3155
msgid ""
"All pointers in Rust are explicit first-class values.  They can be copied, "
"stored into data structures, and returned from functions.  There are four "
"varieties of pointer in Rust:"
msgstr ""

#. type: Plain text
#: doc/rust.md:3165
#, no-wrap
msgid ""
"Managed pointers (`@`)\n"
"  : These point to managed heap allocations (or \"boxes\") in the task-local, managed heap.\n"
"    Managed pointers are written `@content`,\n"
"    for example `@int` means a managed pointer to a managed box containing an integer.\n"
"    Copying a managed pointer is a \"shallow\" operation:\n"
"    it involves only copying the pointer itself\n"
"    (as well as any reference-count or GC-barriers required by the managed heap).\n"
"    Dropping a managed pointer does not necessarily release the box it points to;\n"
"    the lifecycles of managed boxes are subject to an unspecified garbage collection algorithm.\n"
msgstr ""

#. type: Plain text
#: doc/rust.md:3174
#, no-wrap
msgid ""
"Owning pointers (`~`)\n"
"  : These point to owned heap allocations (or \"boxes\") in the shared, inter-task heap.\n"
"    Each owned box has a single owning pointer; pointer and pointee retain a 1:1 relationship at all times.\n"
"    Owning pointers are written `~content`,\n"
"    for example `~int` means an owning pointer to an owned box containing an integer.\n"
"    Copying an owned box is a \"deep\" operation:\n"
"    it involves allocating a new owned box and copying the contents of the old box into the new box.\n"
"    Releasing an owning pointer immediately releases its corresponding owned box.\n"
msgstr ""

#. type: Plain text
#: doc/rust.md:3187
#, no-wrap
msgid ""
"Borrowed pointers (`&`)\n"
"  : These point to memory _owned by some other value_.\n"
"    Borrowed pointers arise by (automatic) conversion from owning pointers, managed pointers,\n"
"    or by applying the borrowing operator `&` to some other value,\n"
"    including [lvalues, rvalues or temporaries](#lvalues-rvalues-and-temporaries).\n"
"    Borrowed pointers are written `&content`, or in some cases `&'f content` for some lifetime-variable `f`,\n"
"    for example `&int` means a borrowed pointer to an integer.\n"
"    Copying a borrowed pointer is a \"shallow\" operation:\n"
"    it involves only copying the pointer itself.\n"
"    Releasing a borrowed pointer typically has no effect on the value it points to,\n"
"    with the exception of temporary values,\n"
"    which are released when the last borrowed pointer to them is released.\n"
msgstr ""

#. type: Plain text
#: doc/rust.md:3197
#, no-wrap
msgid ""
"Raw pointers (`*`)\n"
"  : Raw pointers are pointers without safety or liveness guarantees.\n"
"    Raw pointers are written `*content`,\n"
"    for example `*int` means a raw pointer to an integer.\n"
"    Copying or dropping a raw pointer has no effect on the lifecycle of any other value.\n"
"    Dereferencing a raw pointer or converting it to any other pointer type is an [`unsafe` operation](#unsafe-functions).\n"
"    Raw pointers are generally discouraged in Rust code;\n"
"    they exist to support interoperability with foreign code,\n"
"    and writing performance-critical or low-level functions.\n"
msgstr ""

#. type: Plain text
#: doc/rust.md:3199
msgid "### Function types"
msgstr ""

#. type: Plain text
#: doc/rust.md:3203
msgid ""
"The function type constructor `fn` forms new function types.  A function "
"type consists of a possibly-empty set of function-type modifiers (such as "
"`unsafe` or `extern`), a sequence of input types and an output type."
msgstr ""

#. type: Plain text
#: doc/rust.md:3205
msgid "An example of a `fn` type:"
msgstr ""

#. type: Plain text
#: doc/rust.md:3210
#, no-wrap
msgid ""
"~~~~\n"
"fn add(x: int, y: int) -> int {\n"
"  return x + y;\n"
"}\n"
msgstr ""

#. type: Plain text
#: doc/rust.md:3212
msgid "let mut x = add(5,7);"
msgstr ""

#. type: Plain text
#: doc/rust.md:3217
msgid ""
"type Binop<'a> = 'a |int,int| -> int; let bo: Binop = add; x = bo(5,7); ~~~~"
msgstr ""

#. type: Plain text
#: doc/rust.md:3219
msgid "### Closure types"
msgstr ""

#. type: Plain text
#: doc/rust.md:3221
msgid ""
"The type of a closure mapping an input of type `A` to an output of type `B` "
"is `|A| -> B`. A closure with no arguments or return values has type `||`."
msgstr ""

#. type: Plain text
#: doc/rust.md:3224
msgid "An example of creating and calling a closure:"
msgstr ""

#. type: Plain text
#: doc/rust.md:3227
msgid "```rust let captured_var = 10;"
msgstr ""

#. type: Plain text
#: doc/rust.md:3229
msgid "let closure_no_args = || println!(\"captured_var={}\", captured_var);"
msgstr ""

#. type: Plain text
#: doc/rust.md:3234
#, no-wrap
msgid ""
"let closure_args = |arg: int| -> int {\n"
"  println!(\"captured_var={}, arg={}\", captured_var, arg); \n"
"  arg // Note lack of semicolon after 'arg'\n"
"};\n"
msgstr ""

#. type: Plain text
#: doc/rust.md:3239
#, no-wrap
msgid ""
"fn call_closure(c1: ||, c2: |int| -> int) {\n"
"  c1();\n"
"  c2(2);\n"
"}\n"
msgstr ""

#. type: Plain text
#: doc/rust.md:3241
msgid "call_closure(closure_no_args, closure_args);"
msgstr ""

#. type: Plain text
#: doc/rust.md:3243
msgid "```"
msgstr ""

#. type: Plain text
#: doc/rust.md:3245
msgid "### Object types"
msgstr ""

#. type: Plain text
#: doc/rust.md:3252
msgid ""
"Every trait item (see [traits](#traits)) defines a type with the same name "
"as the trait.  This type is called the _object type_ of the trait.  Object "
"types permit \"late binding\" of methods, dispatched using _virtual method "
"tables_ (\"vtables\").  Whereas most calls to trait methods are \"early bound"
"\" (statically resolved) to specific implementations at compile time, a call "
"to a method on an object type is only resolved to a vtable entry at compile "
"time.  The actual implementation for each vtable entry can vary on an object-"
"by-object basis."
msgstr ""

#. type: Plain text
#: doc/rust.md:3257
msgid ""
"Given a pointer-typed expression `E` of type `&T`, `~T` or `@T`, where `T` "
"implements trait `R`, casting `E` to the corresponding pointer type `&R`, "
"`~R` or `@R` results in a value of the _object type_ `R`.  This result is "
"represented as a pair of pointers: the vtable pointer for the `T` "
"implementation of `R`, and the pointer value of `E`."
msgstr ""

#. type: Plain text
#: doc/rust.md:3259
msgid "An example of an object type:"
msgstr ""

#. type: Plain text
#: doc/rust.md:3264
#, no-wrap
msgid ""
"~~~~\n"
"trait Printable {\n"
"  fn to_string(&self) -> ~str;\n"
"}\n"
msgstr ""

#. type: Plain text
#: doc/rust.md:3268
#, no-wrap
msgid ""
"impl Printable for int {\n"
"  fn to_string(&self) -> ~str { self.to_str() }\n"
"}\n"
msgstr ""

#. type: Plain text
#: doc/rust.md:3272
#, no-wrap
msgid ""
"fn print(a: @Printable) {\n"
"   println(a.to_string());\n"
"}\n"
msgstr ""

#. type: Plain text
#: doc/rust.md:3277
#, no-wrap
msgid ""
"fn main() {\n"
"   print(@10 as @Printable);\n"
"}\n"
"~~~~\n"
msgstr ""

#. type: Plain text
#: doc/rust.md:3280
msgid ""
"In this example, the trait `Printable` occurs as an object type in both the "
"type signature of `print`, and the cast expression in `main`."
msgstr ""

#. type: Plain text
#: doc/rust.md:3282
msgid "### Type parameters"
msgstr ""

#. type: Plain text
#: doc/rust.md:3284
msgid ""
"Within the body of an item that has type parameter declarations, the names "
"of its type parameters are types:"
msgstr ""

#. type: Plain text
#: doc/rust.md:3295
#, no-wrap
msgid ""
"~~~~\n"
"fn map<A: Clone, B: Clone>(f: |A| -> B, xs: &[A]) -> ~[B] {\n"
"    if xs.len() == 0 {\n"
"       return ~[];\n"
"    }\n"
"    let first: B = f(xs[0].clone());\n"
"    let rest: ~[B] = map(f, xs.slice(1, xs.len()));\n"
"    return ~[first] + rest;\n"
"}\n"
"~~~~\n"
msgstr ""

#. type: Plain text
#: doc/rust.md:3298
msgid ""
"Here, `first` has type `B`, referring to `map`'s `B` type parameter; and "
"`rest` has type `~[B]`, a vector type with element type `B`."
msgstr ""

#. type: Plain text
#: doc/rust.md:3300
msgid "### Self types"
msgstr ""

#. type: Plain text
#: doc/rust.md:3304
msgid ""
"The special type `self` has a meaning within methods inside an impl item. It "
"refers to the type of the implicit `self` argument. For example, in:"
msgstr ""

#. type: Plain text
#: doc/rust.md:3309
#, no-wrap
msgid ""
"~~~~\n"
"trait Printable {\n"
"  fn make_string(&self) -> ~str;\n"
"}\n"
msgstr ""

#. type: Plain text
#: doc/rust.md:3316
#, no-wrap
msgid ""
"impl Printable for ~str {\n"
"    fn make_string(&self) -> ~str {\n"
"        (*self).clone()\n"
"    }\n"
"}\n"
"~~~~\n"
msgstr ""

#. type: Plain text
#: doc/rust.md:3319
msgid ""
"`self` refers to the value of type `~str` that is the receiver for a call to "
"the method `make_string`."
msgstr ""

#. type: Plain text
#: doc/rust.md:3321
msgid "## Type kinds"
msgstr ""

#. type: Plain text
#: doc/rust.md:3324
msgid ""
"Types in Rust are categorized into kinds, based on various properties of the "
"components of the type.  The kinds are:"
msgstr ""

#. type: Plain text
#: doc/rust.md:3356
#, no-wrap
msgid ""
"`Freeze`\n"
"  : Types of this kind are deeply immutable;\n"
"    they contain no mutable memory locations\n"
"    directly or indirectly via pointers.\n"
"`Send`\n"
"  : Types of this kind can be safely sent between tasks.\n"
"    This kind includes scalars, owning pointers, owned closures, and\n"
"    structural types containing only other owned types.\n"
"    All `Send` types are `'static`.\n"
"`Pod`\n"
"  : Types of this kind consist of \"Plain Old Data\"\n"
"    which can be copied by simply moving bits.\n"
"    All values of this kind can be implicitly copied.\n"
"    This kind includes scalars and immutable references,\n"
"    as well as structural types containing other `Pod` types.\n"
"`'static`\n"
"  : Types of this kind do not contain any borrowed pointers;\n"
"    this can be a useful guarantee for code\n"
"    that breaks borrowing assumptions\n"
"    using [`unsafe` operations](#unsafe-functions).\n"
"`Drop`\n"
"  : This is not strictly a kind,\n"
"    but its presence interacts with kinds:\n"
"    the `Drop` trait provides a single method `drop`\n"
"    that takes no parameters,\n"
"    and is run when values of the type are dropped.\n"
"    Such a method is called a \"destructor\",\n"
"    and are always executed in \"top-down\" order:\n"
"    a value is completely destroyed\n"
"    before any of the values it owns run their destructors.\n"
"    Only `Send` types can implement `Drop`.\n"
msgstr ""

#. type: Plain text
#: doc/rust.md:3363
#, no-wrap
msgid ""
"_Default_\n"
"  : Types with destructors, closure environments,\n"
"    and various other _non-first-class_ types,\n"
"    are not copyable at all.\n"
"    Such types can usually only be accessed through pointers,\n"
"    or in some cases, moved between mutable locations.\n"
msgstr ""

#. type: Plain text
#: doc/rust.md:3366
msgid ""
"Kinds can be supplied as _bounds_ on type parameters, like traits, in which "
"case the parameter is constrained to types satisfying that kind."
msgstr ""

#. type: Plain text
#: doc/rust.md:3372
msgid ""
"By default, type parameters do not carry any assumed kind-bounds at all.  "
"When instantiating a type parameter, the kind bounds on the parameter are "
"checked to be the same or narrower than the kind of the type that it is "
"instantiated with."
msgstr ""

#. type: Plain text
#: doc/rust.md:3377
msgid ""
"Sending operations are not part of the Rust language, but are implemented in "
"the library.  Generic functions that send values bound the kind of these "
"values to sendable."
msgstr ""

#. type: Plain text
#: doc/rust.md:3379
msgid "# Memory and concurrency models"
msgstr ""

#. type: Plain text
#: doc/rust.md:3384
msgid ""
"Rust has a memory model centered around concurrently-executing _tasks_. Thus "
"its memory model and its concurrency model are best discussed "
"simultaneously, as parts of each only make sense when considered from the "
"perspective of the other."
msgstr ""

#. type: Plain text
#: doc/rust.md:3389
msgid ""
"When reading about the memory model, keep in mind that it is partitioned in "
"order to support tasks; and when reading about tasks, keep in mind that "
"their isolation and communication mechanisms are only possible due to the "
"ownership and lifetime semantics of the memory model."
msgstr ""

#. type: Plain text
#: doc/rust.md:3391
msgid "## Memory model"
msgstr ""

#. type: Plain text
#: doc/rust.md:3395
msgid ""
"A Rust program's memory consists of a static set of *items*, a set of [tasks]"
"(#tasks) each with its own *stack*, and a *heap*. Immutable portions of the "
"heap may be shared between tasks, mutable portions may not."
msgstr ""

#. type: Plain text
#: doc/rust.md:3398
msgid ""
"Allocations in the stack consist of *slots*, and allocations in the heap "
"consist of *boxes*."
msgstr ""

#. type: Plain text
#: doc/rust.md:3400
msgid "### Memory allocation and lifetime"
msgstr ""

#. type: Plain text
#: doc/rust.md:3405
msgid ""
"The _items_ of a program are those functions, modules and types that have "
"their value calculated at compile-time and stored uniquely in the memory "
"image of the rust process. Items are neither dynamically allocated nor freed."
msgstr ""

#. type: Plain text
#: doc/rust.md:3409
msgid ""
"A task's _stack_ consists of activation frames automatically allocated on "
"entry to each function as the task executes. A stack allocation is reclaimed "
"when control leaves the frame containing it."
msgstr ""

#. type: Plain text
#: doc/rust.md:3416
msgid ""
"The _heap_ is a general term that describes two separate sets of boxes: "
"managed boxes -- which may be subject to garbage collection -- and owned "
"boxes.  The lifetime of an allocation in the heap depends on the lifetime of "
"the box values pointing to it. Since box values may themselves be passed in "
"and out of frames, or stored in the heap, heap allocations may outlive the "
"frame they are allocated within."
msgstr ""

#. type: Plain text
#: doc/rust.md:3418
msgid "### Memory ownership"
msgstr ""

#. type: Plain text
#: doc/rust.md:3421
msgid ""
"A task owns all memory it can *safely* reach through local variables, as "
"well as managed, owning and borrowed pointers."
msgstr ""

#. type: Plain text
#: doc/rust.md:3428
msgid ""
"When a task sends a value that has the `Send` trait to another task, it "
"loses ownership of the value sent and can no longer refer to it.  This is "
"statically guaranteed by the combined use of \"move semantics\", and the "
"compiler-checked _meaning_ of the `Send` trait: it is only instantiated for "
"(transitively) sendable kinds of data constructor and pointers, never "
"including managed or borrowed pointers."
msgstr ""

#. type: Plain text
#: doc/rust.md:3431
msgid ""
"When a stack frame is exited, its local allocations are all released, and "
"its references to boxes (both managed and owned) are dropped."
msgstr ""

#. type: Plain text
#: doc/rust.md:3437
msgid ""
"A managed box may (in the case of a recursive, mutable managed type) be "
"cyclic; in this case the release of memory inside the managed structure may "
"be deferred until task-local garbage collection can reclaim it. Code can "
"ensure no such delayed deallocation occurs by restricting itself to owned "
"boxes and similar unmanaged kinds of data."
msgstr ""

#. type: Plain text
#: doc/rust.md:3440
msgid ""
"When a task finishes, its stack is necessarily empty and it therefore has no "
"references to any boxes; the remainder of its heap is immediately freed."
msgstr ""

#. type: Plain text
#: doc/rust.md:3442
msgid "### Memory slots"
msgstr ""

#. type: Plain text
#: doc/rust.md:3444
msgid "A task's stack contains slots."
msgstr ""

#. type: Plain text
#: doc/rust.md:3447
msgid ""
"A _slot_ is a component of a stack frame, either a function parameter, a "
"[temporary](#lvalues-rvalues-and-temporaries), or a local variable."
msgstr ""

#. type: Plain text
#: doc/rust.md:3450
msgid ""
"A _local variable_ (or *stack-local* allocation) holds a value directly, "
"allocated within the stack's memory. The value is a part of the stack frame."
msgstr ""

#. type: Plain text
#: doc/rust.md:3452
msgid ""
"Local variables are immutable unless declared otherwise like: `let mut x "
"= ...`."
msgstr ""

#. type: Plain text
#: doc/rust.md:3457
msgid ""
"Function parameters are immutable unless declared with `mut`. The `mut` "
"keyword applies only to the following parameter (so `|mut x, y|` and `fn "
"f(mut x: ~int, y: ~int)` declare one mutable variable `x` and one immutable "
"variable `y`)."
msgstr ""

#. type: Plain text
#: doc/rust.md:3460
msgid ""
"Methods that take either `self` or `~self` can optionally place them in a "
"mutable slot by prefixing them with `mut` (similar to regular arguments):"
msgstr ""

#. type: Plain text
#: doc/rust.md:3467
#, no-wrap
msgid ""
"~~~\n"
"trait Changer {\n"
"    fn change(mut self) -> Self;\n"
"    fn modify(mut ~self) -> ~Self;\n"
"}\n"
"~~~\n"
msgstr ""

#. type: Plain text
#: doc/rust.md:3473
msgid ""
"Local variables are not initialized when allocated; the entire frame worth "
"of local variables are allocated at once, on frame-entry, in an "
"uninitialized state. Subsequent statements within a function may or may not "
"initialize the local variables. Local variables can be used only after they "
"have been initialized; this is enforced by the compiler."
msgstr ""

#. type: Plain text
#: doc/rust.md:3475
msgid "### Memory boxes"
msgstr ""

#. type: Plain text
#: doc/rust.md:3478
msgid ""
"A _box_ is a reference to a heap allocation holding another value. There are "
"two kinds of boxes: *managed boxes* and *owned boxes*."
msgstr ""

#. type: Plain text
#: doc/rust.md:3480
msgid ""
"A _managed box_ type or value is constructed by the prefix *at* sigil `@`."
msgstr ""

#. type: Plain text
#: doc/rust.md:3482
msgid ""
"An _owned box_ type or value is constructed by the prefix *tilde* sigil `~`."
msgstr ""

#. type: Plain text
#: doc/rust.md:3487
msgid ""
"Multiple managed box values can point to the same heap allocation; copying a "
"managed box value makes a shallow copy of the pointer (optionally "
"incrementing a reference count, if the managed box is implemented through "
"reference-counting)."
msgstr ""

#. type: Plain text
#: doc/rust.md:3489
msgid ""
"Owned box values exist in 1:1 correspondence with their heap allocation."
msgstr ""

#. type: Plain text
#: doc/rust.md:3492
msgid ""
"An example of constructing one managed box type and value, and one owned box "
"type and value:"
msgstr ""

#. type: Plain text
#: doc/rust.md:3497
msgid "~~~~ let x: @int = @10; let x: ~int = ~10; ~~~~"
msgstr ""

#. type: Plain text
#: doc/rust.md:3500
msgid ""
"Some operations (such as field selection) implicitly dereference boxes. An "
"example of an _implicit dereference_ operation performed on box values:"
msgstr ""

#. type: Plain text
#: doc/rust.md:3506
msgid ""
"~~~~ struct Foo { y: int } let x = @Foo{y: 10}; assert!(x.y == 10); ~~~~"
msgstr ""

#. type: Plain text
#: doc/rust.md:3512
msgid ""
"Other operations act on box values as single-word-sized address values. For "
"these operations, to access the value held in the box requires an explicit "
"dereference of the box value. Explicitly dereferencing a box is indicated "
"with the unary *star* operator `*`. Examples of such _explicit dereference_ "
"operations are:"
msgstr ""

#. type: Bullet: '* '
#: doc/rust.md:3515
msgid "copying box values (`x = y`)"
msgstr ""

#. type: Bullet: '* '
#: doc/rust.md:3515
msgid "passing box values to functions (`f(x,y)`)"
msgstr ""

#. type: Plain text
#: doc/rust.md:3517
msgid ""
"An example of an explicit-dereference operation performed on box values:"
msgstr ""

#. type: Plain text
#: doc/rust.md:3521
msgid "~~~~ fn takes_boxed(b: @int) { }"
msgstr ""

#. type: Plain text
#: doc/rust.md:3524
msgid "fn takes_unboxed(b: int) { }"
msgstr ""

#. type: Plain text
#: doc/rust.md:3531
#, no-wrap
msgid ""
"fn main() {\n"
"    let x: @int = @10;\n"
"    takes_boxed(x);\n"
"    takes_unboxed(*x);\n"
"}\n"
"~~~~\n"
msgstr ""

#. type: Plain text
#: doc/rust.md:3533
msgid "## Tasks"
msgstr ""

#. type: Plain text
#: doc/rust.md:3541
msgid ""
"An executing Rust program consists of a tree of tasks.  A Rust _task_ "
"consists of an entry function, a stack, a set of outgoing communication "
"channels and incoming communication ports, and ownership of some portion of "
"the heap of a single operating-system process.  (We expect that many "
"programs will not use channels and ports directly, but will instead use "
"higher-level abstractions provided in standard libraries, such as pipes.)"
msgstr ""

#. type: Plain text
#: doc/rust.md:3556
msgid ""
"Multiple Rust tasks may coexist in a single operating-system process.  The "
"runtime scheduler maps tasks to a certain number of operating-system "
"threads.  By default, the scheduler chooses the number of threads based on "
"the number of concurrent physical CPUs detected at startup.  It's also "
"possible to override this choice at runtime.  When the number of tasks "
"exceeds the number of threads -- which is likely -- the scheduler "
"multiplexes the tasks onto threads.^[ This is an M:N scheduler, which is "
"known to give suboptimal results for CPU-bound concurrency problems.  In "
"such cases, running with the same number of threads and tasks can yield "
"better results.  Rust has M:N scheduling in order to support very large "
"numbers of tasks in contexts where threads are too resource-intensive to use "
"in large number.  The cost of threads varies substantially per operating "
"system, and is sometimes quite low, so this flexibility is not always worth "
"exploiting.]"
msgstr ""

#. type: Plain text
#: doc/rust.md:3558
msgid "### Communication between tasks"
msgstr ""

#. type: Plain text
#: doc/rust.md:3563
msgid ""
"Rust tasks are isolated and generally unable to interfere with one another's "
"memory directly, except through [`unsafe` code](#unsafe-functions).  All "
"contact between tasks is mediated by safe forms of ownership transfer, and "
"data races on memory are prohibited by the type system."
msgstr ""

#. type: Plain text
#: doc/rust.md:3566
msgid ""
"Inter-task communication and co-ordination facilities are provided in the "
"standard library.  These include:"
msgstr ""

#. type: Bullet: '  - '
#: doc/rust.md:3570
msgid ""
"synchronous and asynchronous communication channels with various "
"communication topologies"
msgstr ""

#. type: Bullet: '  - '
#: doc/rust.md:3570
msgid ""
"read-only and read-write shared variables with various safe mutual exclusion "
"patterns"
msgstr ""

#. type: Bullet: '  - '
#: doc/rust.md:3570
msgid "simple locks and semaphores"
msgstr ""

#. type: Plain text
#: doc/rust.md:3575
msgid ""
"When such facilities carry values, the values are restricted to the [`Send` "
"type-kind](#type-kinds).  Restricting communication interfaces to this kind "
"ensures that no borrowed or managed pointers move between tasks.  Thus "
"access to an entire data structure can be mediated through its owning \"root"
"\" value; no further locking or copying is required to avoid data races "
"within the substructure of such a value."
msgstr ""

#. type: Plain text
#: doc/rust.md:3577
msgid "### Task lifecycle"
msgstr ""

#. type: Plain text
#: doc/rust.md:3580
msgid ""
"The _lifecycle_ of a task consists of a finite set of states and events that "
"cause transitions between the states. The lifecycle states of a task are:"
msgstr ""

#. type: Bullet: '* '
#: doc/rust.md:3585
msgid "running"
msgstr ""

#. type: Bullet: '* '
#: doc/rust.md:3585
msgid "blocked"
msgstr ""

#. type: Bullet: '* '
#: doc/rust.md:3585
msgid "failing"
msgstr ""

#. type: Bullet: '* '
#: doc/rust.md:3585
msgid "dead"
msgstr ""

#. type: Plain text
#: doc/rust.md:3589
msgid ""
"A task begins its lifecycle -- once it has been spawned -- in the *running* "
"state. In this state it executes the statements of its entry function, and "
"any functions called by the entry function."
msgstr ""

#. type: Plain text
#: doc/rust.md:3595
msgid ""
"A task may transition from the *running* state to the *blocked* state any "
"time it makes a blocking communication call. When the call can be completed "
"-- when a message arrives at a sender, or a buffer opens to receive a "
"message -- then the blocked task will unblock and transition back to "
"*running*."
msgstr ""

#. type: Plain text
#: doc/rust.md:3612
msgid ""
"A task may transition to the *failing* state at any time, due being killed "
"by some external event or internally, from the evaluation of a `fail!()` "
"macro. Once *failing*, a task unwinds its stack and transitions to the "
"*dead* state. Unwinding the stack of a task is done by the task itself, on "
"its own control stack. If a value with a destructor is freed during "
"unwinding, the code for the destructor is run, also on the task's control "
"stack. Running the destructor code causes a temporary transition to a "
"*running* state, and allows the destructor code to cause any subsequent "
"state transitions.  The original task of unwinding and failing thereby may "
"suspend temporarily, and may involve (recursive) unwinding of the stack of a "
"failed destructor. Nonetheless, the outermost unwinding activity will "
"continue until the stack is unwound and the task transitions to the *dead* "
"state. There is no way to \"recover\" from task failure.  Once a task has "
"temporarily suspended its unwinding in the *failing* state, failure "
"occurring from within this destructor results in *hard* failure.  A hard "
"failure currently results in the process aborting."
msgstr ""

#. type: Plain text
#: doc/rust.md:3616
msgid ""
"A task in the *dead* state cannot transition to other states; it exists only "
"to have its termination status inspected by other tasks, and/or to await "
"reclamation when the last reference to it drops."
msgstr ""

#. type: Plain text
#: doc/rust.md:3618
msgid "### Task scheduling"
msgstr ""

#. type: Plain text
#: doc/rust.md:3622
msgid ""
"The currently scheduled task is given a finite *time slice* in which to "
"execute, after which it is *descheduled* at a loop-edge or similar "
"preemption point, and another task within is scheduled, pseudo-randomly."
msgstr ""

#. type: Plain text
#: doc/rust.md:3626
msgid ""
"An executing task can yield control at any time, by making a library call to "
"`std::task::yield`, which deschedules it immediately. Entering any other non-"
"executing state (blocked, dead) similarly deschedules the task."
msgstr ""

#. type: Plain text
#: doc/rust.md:3628
msgid "# Runtime services, linkage and debugging"
msgstr ""

#. type: Plain text
#: doc/rust.md:3634
msgid ""
"The Rust _runtime_ is a relatively compact collection of C++ and Rust code "
"that provides fundamental services and datatypes to all Rust tasks at run-"
"time. It is smaller and simpler than many modern language runtimes. It is "
"tightly integrated into the language's execution model of memory, tasks, "
"communication and logging."
msgstr ""

#. type: Plain text
#: doc/rust.md:3636
msgid ""
"> **Note:** The runtime library will merge with the `std` library in future "
"versions of Rust."
msgstr ""

#. type: Plain text
#: doc/rust.md:3638
msgid "### Memory allocation"
msgstr ""

#. type: Plain text
#: doc/rust.md:3644
msgid ""
"The runtime memory-management system is based on a _service-provider "
"interface_, through which the runtime requests blocks of memory from its "
"environment and releases them back to its environment when they are no "
"longer needed.  The default implementation of the service-provider interface "
"consists of the C runtime functions `malloc` and `free`."
msgstr ""

#. type: Plain text
#: doc/rust.md:3648
msgid ""
"The runtime memory-management system, in turn, supplies Rust tasks with "
"facilities for allocating releasing stacks, as well as allocating and "
"freeing heap data."
msgstr ""

#. type: Plain text
#: doc/rust.md:3650
msgid "### Built in types"
msgstr ""

#. type: Plain text
#: doc/rust.md:3654
msgid ""
"The runtime provides C and Rust code to assist with various built-in types, "
"such as vectors, strings, and the low level communication system (ports, "
"channels, tasks)."
msgstr ""

#. type: Plain text
#: doc/rust.md:3657
msgid ""
"Support for other built-in types such as simple types, tuples, records, and "
"enums is open-coded by the Rust compiler."
msgstr ""

#. type: Plain text
#: doc/rust.md:3659
msgid "### Task scheduling and communication"
msgstr ""

#. type: Plain text
#: doc/rust.md:3665
msgid ""
"The runtime provides code to manage inter-task communication.  This includes "
"the system of task-lifecycle state transitions depending on the contents of "
"queues, as well as code to copy values between queues and their recipients "
"and to serialize values for transmission over operating-system inter-process "
"communication facilities."
msgstr ""

#. type: Plain text
#: doc/rust.md:3667
msgid "### Linkage"
msgstr ""

#. type: Plain text
#: doc/rust.md:3672
msgid ""
"The Rust compiler supports various methods to link crates together both "
"statically and dynamically. This section will explore the various methods to "
"link Rust crates together, and more information about native libraries can "
"be found in the [ffi tutorial][ffi]."
msgstr ""

#. type: Plain text
#: doc/rust.md:3675
msgid ""
"In one session of compilation, the compiler can generate multiple artifacts "
"through the usage of command line flags and the `crate_type` attribute."
msgstr ""

#. type: Bullet: '* '
#: doc/rust.md:3680
msgid ""
"`--bin`, `#[crate_type = \"bin\"]` - A runnable executable will be "
"produced.  This requires that there is a `main` function in the crate which "
"will be run when the program begins executing. This will link in all Rust "
"and native dependencies, producing a distributable binary."
msgstr ""

#. type: Bullet: '* '
#: doc/rust.md:3689
msgid ""
"`--lib`, `#[crate_type = \"lib\"]` - A Rust library will be produced. This "
"is an ambiguous concept as to what exactly is produced because a library can "
"manifest itself in several forms. The purpose of this generic `lib` option "
"is to generate the \"compiler recommended\" style of library. The output "
"library will always be usable by rustc, but the actual type of library may "
"change from time-to-time. The remaining output types are all different "
"flavors of libraries, and the `lib` type can be seen as an alias for one of "
"them (but the actual one is compiler-defined)."
msgstr ""

#. type: Bullet: '* '
#: doc/rust.md:3696
msgid ""
"`--dylib`, `#[crate_type = \"dylib\"]` - A dynamic Rust library will be "
"produced. This is different from the `lib` output type in that this forces "
"dynamic library generation. The resulting dynamic library can be used as a "
"dependency for other libraries and/or executables.  This output type will "
"create `*.so` files on linux, `*.dylib` files on osx, and `*.dll` files on "
"windows."
msgstr ""

#. type: Bullet: '* '
#: doc/rust.md:3706
msgid ""
"`--staticlib`, `#[crate_type = \"staticlib\"]` - A static system library "
"will be produced. This is different from other library outputs in that the "
"Rust compiler will never attempt to link to `staticlib` outputs. The purpose "
"of this output type is to create a static library containing all of the "
"local crate's code along with all upstream dependencies. The static library "
"is actually a `*.a` archive on linux and osx and a `*.lib` file on windows. "
"This format is recommended for use in situtations such as linking Rust code "
"into an existing non-Rust application because it will not have dynamic "
"dependencies on other Rust code."
msgstr ""

#. type: Bullet: '* '
#: doc/rust.md:3714
msgid ""
"`--rlib`, `#[crate_type = \"rlib\"]` - A \"Rust library\" file will be "
"produced.  This is used as an intermediate artifact and can be thought of as "
"a \"static Rust library\". These `rlib` files, unlike `staticlib` files, are "
"interpreted by the Rust compiler in future linkage. This essentially means "
"that `rustc` will look for metadata in `rlib` files like it looks for "
"metadata in dynamic libraries. This form of output is used to produce "
"statically linked executables as well as `staticlib` outputs."
msgstr ""

#. type: Plain text
#: doc/rust.md:3718
msgid ""
"Note that these outputs are stackable in the sense that if multiple are "
"specified, then the compiler will produce each form of output at once "
"without having to recompile."
msgstr ""

#. type: Plain text
#: doc/rust.md:3726
msgid ""
"With all these different kinds of outputs, if crate A depends on crate B, "
"then the compiler could find B in various different forms throughout the "
"system. The only forms looked for by the compiler, however, are the `rlib` "
"format and the dynamic library format. With these two options for a "
"dependent library, the compiler must at some point make a choice between "
"these two formats. With this in mind, the compiler follows these rules when "
"determining what format of dependencies will be used:"
msgstr ""

#. type: Bullet: '1. '
#: doc/rust.md:3732
msgid ""
"If a dynamic library is being produced, then it is required for all upstream "
"Rust dependencies to also be dynamic. This is a limitation of the current "
"implementation of the linkage model.  The reason behind this limitation is "
"to prevent multiple copies of the same upstream library from showing up, and "
"in the future it is planned to support a mixture of dynamic and static "
"linking."
msgstr ""

#. type: Plain text
#: doc/rust.md:3737
#, no-wrap
msgid ""
"   When producing a dynamic library, the compiler will generate an error if an\n"
"   upstream dependency could not be found, and also if an upstream dependency\n"
"   could only be found in an `rlib` format. Remember that `staticlib` formats\n"
"   are always ignored by `rustc` for crate-linking purposes.\n"
msgstr ""

#. type: Bullet: '2. '
#: doc/rust.md:3741
msgid ""
"If a static library is being produced, all upstream dependecies are required "
"to be available in `rlib` formats. This requirement stems from the same "
"reasons that a dynamic library must have all dynamic dependencies."
msgstr ""

#. type: Plain text
#: doc/rust.md:3745
#, no-wrap
msgid ""
"   Note that it is impossible to link in native dynamic dependencies to a static\n"
"   library, and in this case warnings will be printed about all unlinked native\n"
"   dynamic dependencies.\n"
msgstr ""

#. type: Bullet: '3. '
#: doc/rust.md:3749
msgid ""
"If an `rlib` file is being produced, then there are no restrictions on what "
"format the upstream dependencies are available in. It is simply required "
"that all upstream dependencies be available for reading metadata from."
msgstr ""

#. type: Plain text
#: doc/rust.md:3753
#, no-wrap
msgid ""
"   The reason for this is that `rlib` files do not contain any of their upstream\n"
"   dependencies. It wouldn't be very efficient for all `rlib` files to contain a\n"
"   copy of `libstd.rlib`!\n"
msgstr ""

#. type: Bullet: '4. '
#: doc/rust.md:3760
msgid ""
"If an executable is being produced, then things get a little interesting. As "
"with the above limitations in dynamic and static libraries, it is required "
"for all upstream dependencies to be in the same format. The next question is "
"whether to prefer a dynamic or a static format. The compiler currently "
"favors static linking over dynamic linking, but this can be inverted with "
"the `-Z prefer-dynamic` flag to the compiler."
msgstr ""

#. type: Plain text
#: doc/rust.md:3766
#, no-wrap
msgid ""
"   What this means is that first the compiler will attempt to find all upstream\n"
"   dependencies as `rlib` files, and if successful, it will create a statically\n"
"   linked executable. If an upstream dependency is missing as an `rlib` file,\n"
"   then the compiler will force all dependencies to be dynamic and will generate\n"
"   errors if dynamic versions could not be found.\n"
msgstr ""

#. type: Plain text
#: doc/rust.md:3770
msgid ""
"In general, `--bin` or `--lib` should be sufficient for all compilation "
"needs, and the other options are just available if more fine-grained control "
"is desired over the output format of a Rust crate."
msgstr ""

#. type: Plain text
#: doc/rust.md:3772
msgid "### Logging system"
msgstr ""

#. type: Plain text
#: doc/rust.md:3776
msgid ""
"The runtime contains a system for directing [logging expressions](#log-"
"expressions) to a logging console and/or internal logging buffers. Logging "
"can be enabled per module."
msgstr ""

#. type: Plain text
#: doc/rust.md:3783
msgid ""
"Logging output is enabled by setting the `RUST_LOG` environment variable.  "
"`RUST_LOG` accepts a logging specification made up of a comma-separated list "
"of paths, with optional log levels. For each module containing log "
"expressions, if `RUST_LOG` contains the path to that module or a parent of "
"that module, then logs of the appropriate level will be output to the "
"console."
msgstr ""

#. type: Plain text
#: doc/rust.md:3793
msgid ""
"The path to a module consists of the crate name, any parent modules, then "
"the module itself, all separated by double colons (`::`).  The optional log "
"level can be appended to the module path with an equals sign (`=`) followed "
"by the log level, from 1 to 4, inclusive. Level 1 is the error level, 2 is "
"warning, 3 info, and 4 debug. You can also use the symbolic constants "
"`error`, `warn`, `info`, and `debug`.  Any logs less than or equal to the "
"specified level will be output. If not specified then log level 4 is "
"assumed.  Debug messages can be omitted by passing `--cfg ndebug` to `rustc`."
msgstr ""

#. type: Plain text
#: doc/rust.md:3799
msgid ""
"As an example, to see all the logs generated by the compiler, you would set "
"`RUST_LOG` to `rustc`, which is the crate name (as specified in its "
"`crate_id` [attribute](#attributes)). To narrow down the logs to just crate "
"resolution, you would set it to `rustc::metadata::creader`. To see just "
"error logging use `rustc=0`."
msgstr ""

#. type: Plain text
#: doc/rust.md:3804
msgid ""
"Note that when compiling source files that don't specify a crate name the "
"crate is given a default name that matches the source file, with the "
"extension removed. In that case, to turn on logging for a program compiled "
"from, e.g. `helloworld.rs`, `RUST_LOG` should be set to `helloworld`."
msgstr ""

#. type: Plain text
#: doc/rust.md:3808
msgid ""
"As a convenience, the logging spec can also be set to a special pseudo-"
"crate, `::help`. In this case, when the application starts, the runtime will "
"simply output a list of loaded modules containing log expressions, then exit."
msgstr ""

#. type: Plain text
#: doc/rust.md:3810
msgid "#### Logging Expressions"
msgstr ""

#. type: Plain text
#: doc/rust.md:3813
msgid ""
"Rust provides several macros to log information. Here's a simple Rust "
"program that demonstrates all four of them:"
msgstr ""

#. type: Plain text
#: doc/rust.md:3822
#, no-wrap
msgid ""
"~~~~\n"
"fn main() {\n"
"    error!(\"This is an error log\")\n"
"    warn!(\"This is a warn log\")\n"
"    info!(\"this is an info log\")\n"
"    debug!(\"This is a debug log\")\n"
"}\n"
"~~~~\n"
msgstr ""

#. type: Plain text
#: doc/rust.md:3824
msgid ""
"These four log levels correspond to levels 1-4, as controlled by `RUST_LOG`:"
msgstr ""

#. type: Plain text
#: doc/rust.md:3831
msgid ""
"```bash $ RUST_LOG=rust=3 ./rust This is an error log This is a warn log "
"this is an info log ```"
msgstr ""

#. type: Plain text
#: doc/rust.md:3833
msgid "# Appendix: Rationales and design tradeoffs"
msgstr ""

#. type: Plain text
#: doc/rust.md:3835
#, no-wrap
msgid "*TODO*.\n"
msgstr ""

#. type: Plain text
#: doc/rust.md:3837
msgid "# Appendix: Influences and further references"
msgstr ""

#. type: Plain text
#: doc/rust.md:3839
msgid "## Influences"
msgstr ""

#. type: Plain text
#: doc/rust.md:3847
msgid ""
"> The essential problem that must be solved in making a fault-tolerant > "
"software system is therefore that of fault-isolation. Different programmers "
"> will write different modules, some modules will be correct, others will "
"have > errors. We do not want the errors in one module to adversely affect "
"the > behaviour of a module which does not have any errors.  > > &mdash; Joe "
"Armstrong"
msgstr ""

#. type: Plain text
#: doc/rust.md:3858
msgid ""
"> In our approach, all data is private to some process, and processes can > "
"only communicate through communications channels. *Security*, as used > in "
"this paper, is the property which guarantees that processes in a system > "
"cannot affect each other except by explicit communication.  > > When "
"security is absent, nothing which can be proven about a single module > in "
"isolation can be guaranteed to hold when that module is embedded in a > "
"system [...] > > &mdash; Robert Strom and Shaula Yemini"
msgstr ""

#. type: Plain text
#: doc/rust.md:3865
msgid ""
"> Concurrent and applicative programming complement each other. The > "
"ability to send messages on channels provides I/O without side effects, > "
"while the avoidance of shared data helps keep concurrent processes from > "
"colliding.  > > &mdash; Rob Pike"
msgstr ""

#. type: Plain text
#: doc/rust.md:3871
msgid ""
"Rust is not a particularly original language. It may however appear unusual "
"by contemporary standards, as its design elements are drawn from a number of "
"\"historical\" languages that have, with a few exceptions, fallen out of "
"favour. Five prominent lineages contribute the most, though their influences "
"have come and gone during the course of Rust's development:"
msgstr ""

#. type: Bullet: '* '
#: doc/rust.md:3875
msgid ""
"The NIL (1981) and Hermes (1990) family. These languages were developed by "
"Robert Strom, Shaula Yemini, David Bacon and others in their group at IBM "
"Watson Research Center (Yorktown Heights, NY, USA)."
msgstr ""

#. type: Bullet: '* '
#: doc/rust.md:3879
msgid ""
"The Erlang (1987) language, developed by Joe Armstrong, Robert Virding, "
"Claes Wikstr&ouml;m, Mike Williams and others in their group at the Ericsson "
"Computer Science Laboratory (&Auml;lvsj&ouml;, Stockholm, Sweden) ."
msgstr ""

#. type: Bullet: '* '
#: doc/rust.md:3884
msgid ""
"The Sather (1990) language, developed by Stephen Omohundro, Chu-Cheow Lim, "
"Heinz Schmidt and others in their group at The International Computer "
"Science Institute of the University of California, Berkeley (Berkeley, CA, "
"USA)."
msgstr ""

#. type: Bullet: '* '
#: doc/rust.md:3889
msgid ""
"The Newsqueak (1988), Alef (1995), and Limbo (1996) family. These languages "
"were developed by Rob Pike, Phil Winterbottom, Sean Dorward and others in "
"their group at Bell Labs Computing Sciences Research Center (Murray Hill, "
"NJ, USA)."
msgstr ""

#. type: Bullet: '* '
#: doc/rust.md:3893
msgid ""
"The Napier (1985) and Napier88 (1988) family. These languages were developed "
"by Malcolm Atkinson, Ron Morrison and others in their group at the "
"University of St. Andrews (St. Andrews, Fife, UK)."
msgstr ""

#. type: Plain text
#: doc/rust.md:3895
msgid ""
"Additional specific influences can be seen from the following languages:"
msgstr ""

#. type: Bullet: '* '
#: doc/rust.md:3903
msgid "The structural algebraic types and compilation manager of SML."
msgstr ""

#. type: Bullet: '* '
#: doc/rust.md:3903
msgid "The attribute and assembly systems of C#."
msgstr ""

#. type: Bullet: '* '
#: doc/rust.md:3903
msgid "The references and deterministic destructor system of C++."
msgstr ""

#. type: Bullet: '* '
#: doc/rust.md:3903
msgid "The memory region systems of the ML Kit and Cyclone."
msgstr ""

#. type: Bullet: '* '
#: doc/rust.md:3903
msgid "The typeclass system of Haskell."
msgstr ""

#. type: Bullet: '* '
#: doc/rust.md:3903
msgid "The lexical identifier rule of Python."
msgstr ""

#. type: Bullet: '* '
#: doc/rust.md:3903
msgid "The block syntax of Ruby."
msgstr ""

#. type: Plain text
#: doc/rust.md:3904
msgid "[ffi]: tutorial-ffi.html"
msgstr ""
