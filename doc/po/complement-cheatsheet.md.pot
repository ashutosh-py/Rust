# SOME DESCRIPTIVE TITLE
# Copyright (C) YEAR The Rust Project Developers
# This file is distributed under the same license as the Rust package.
# FIRST AUTHOR <EMAIL@ADDRESS>, YEAR.
#
#, fuzzy
msgid ""
msgstr ""
"Project-Id-Version: Rust 0.9\n"
"POT-Creation-Date: 2014-01-08 11:30+0900\n"
"PO-Revision-Date: YEAR-MO-DA HO:MI+ZONE\n"
"Last-Translator: FULL NAME <EMAIL@ADDRESS>\n"
"Language-Team: LANGUAGE <LL@li.org>\n"
"Language: \n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=UTF-8\n"
"Content-Transfer-Encoding: 8bit\n"

#. type: Plain text
#: doc/complement-cheatsheet.md:2
msgid "% Rust Cheatsheet"
msgstr ""

#. type: Plain text
#: doc/complement-cheatsheet.md:4
msgid "# How do I convert *X* to *Y*?"
msgstr ""

#. type: Plain text
#: doc/complement-cheatsheet.md:6
#, no-wrap
msgid "**Int to string**\n"
msgstr ""

#. type: Plain text
#: doc/complement-cheatsheet.md:8
msgid ""
"Use [`ToStr`](http://static.rust-lang.org/doc/master/std/to_str/trait.ToStr."
"html)."
msgstr ""

#. type: Plain text
#: doc/complement-cheatsheet.md:13
msgid "```rust let x: int = 42; let y: ~str = x.to_str(); ```"
msgstr ""

#. type: Plain text
#: doc/complement-cheatsheet.md:15
#, no-wrap
msgid "**String to int**\n"
msgstr ""

#. type: Plain text
#: doc/complement-cheatsheet.md:17
msgid ""
"Use [`FromStr`](http://static.rust-lang.org/doc/master/std/from_str/trait."
"FromStr.html), and its helper function, [`from_str`](http://static.rust-lang."
"org/doc/master/std/from_str/fn.from_str.html)."
msgstr ""

#. type: Plain text
#: doc/complement-cheatsheet.md:22
msgid ""
"```rust let x: Option<int> = from_str(\"42\"); let y: int = x.unwrap(); ```"
msgstr ""

#. type: Plain text
#: doc/complement-cheatsheet.md:24
#, no-wrap
msgid "**Int to string, in non-base-10**\n"
msgstr ""

#. type: Plain text
#: doc/complement-cheatsheet.md:26
msgid ""
"Use [`ToStrRadix`](http://static.rust-lang.org/doc/master/std/num/trait."
"ToStrRadix.html)."
msgstr ""

#. type: Plain text
#: doc/complement-cheatsheet.md:29
msgid "```rust use std::num::ToStrRadix;"
msgstr ""

#. type: Plain text
#: doc/complement-cheatsheet.md:33
msgid "let x: int = 42; let y: ~str = x.to_str_radix(16); ```"
msgstr ""

#. type: Plain text
#: doc/complement-cheatsheet.md:35
#, no-wrap
msgid "**String to int, in non-base-10**\n"
msgstr ""

#. type: Plain text
#: doc/complement-cheatsheet.md:37
msgid ""
"Use [`FromStrRadix`](http://static.rust-lang.org/doc/master/std/num/trait."
"FromStrRadix.html), and its helper function, [`from_str_radix`](http://"
"static.rust-lang.org/doc/master/std/num/fn.from_str_radix.html)."
msgstr ""

#. type: Plain text
#: doc/complement-cheatsheet.md:40
msgid "```rust use std::num::from_str_radix;"
msgstr ""

#. type: Plain text
#: doc/complement-cheatsheet.md:44
msgid ""
"let x: Option<int> = from_str_radix(\"deadbeef\", 16); let y: int = x."
"unwrap(); ```"
msgstr ""

#. type: Plain text
#: doc/complement-cheatsheet.md:46
msgid "# File operations"
msgstr ""

#. type: Plain text
#: doc/complement-cheatsheet.md:48
msgid "## How do I read from a file?"
msgstr ""

#. type: Plain text
#: doc/complement-cheatsheet.md:50
msgid ""
"Use [`File::open`](http://static.rust-lang.org/doc/master/std/io/fs/struct."
"File.html#method.open) to create a [`File`](http://static.rust-lang.org/doc/"
"master/std/io/fs/struct.File.html) struct, which implements the [`Reader`]"
"(http://static.rust-lang.org/doc/master/std/io/trait.Reader.html) trait."
msgstr ""

#. type: Plain text
#: doc/complement-cheatsheet.md:54
msgid "```rust use std::path::Path; use std::io::fs::File;"
msgstr ""

#. type: Plain text
#: doc/complement-cheatsheet.md:59
#, no-wrap
msgid ""
"let path : Path   = Path::new(\"Doc-FAQ-Cheatsheet.md\");\n"
"let on_error      = || fail!(\"open of {:?} failed\", path);\n"
"let reader : File = File::open(&path).unwrap_or_else(on_error);\n"
"```\n"
msgstr ""

#. type: Plain text
#: doc/complement-cheatsheet.md:61
msgid "## How do I iterate over the lines in a file?"
msgstr ""

#. type: Plain text
#: doc/complement-cheatsheet.md:63
msgid ""
"Use the [`lines`](http://static.rust-lang.org/doc/master/std/io/trait.Buffer."
"html#method.lines) method on a [`BufferedReader`](http://static.rust-lang."
"org/doc/master/std/io/buffered/struct.BufferedReader.html)."
msgstr ""

#. type: Plain text
#: doc/complement-cheatsheet.md:66
msgid "```rust use std::io::buffered::BufferedReader;"
msgstr ""

#. type: Plain text
#: doc/complement-cheatsheet.md:72
#, no-wrap
msgid ""
"let mut reader = BufferedReader::new(reader);\n"
"for line in reader.lines() {\n"
"    print!(\"line: {}\", line);\n"
"}\n"
"```\n"
msgstr ""

#. type: Plain text
#: doc/complement-cheatsheet.md:74
msgid "# String operations"
msgstr ""

#. type: Plain text
#: doc/complement-cheatsheet.md:76
msgid "## How do I search for a substring?"
msgstr ""

#. type: Plain text
#: doc/complement-cheatsheet.md:78
msgid ""
"Use the [`find_str`](http://static.rust-lang.org/doc/master/std/str/trait."
"StrSlice.html#tymethod.find_str) method."
msgstr ""

#. type: Plain text
#: doc/complement-cheatsheet.md:83
msgid ""
"```rust let str = \"Hello, this is some random string\"; let index: "
"Option<uint> = str.find_str(\"rand\"); ```"
msgstr ""

#. type: Plain text
#: doc/complement-cheatsheet.md:85 doc/guide-container.md:4
msgid "# Containers"
msgstr ""

#. type: Plain text
#: doc/complement-cheatsheet.md:87
msgid "## How do I get the length of a vector?"
msgstr ""

#. type: Plain text
#: doc/complement-cheatsheet.md:89
msgid ""
"The [`Container`](http://static.rust-lang.org/doc/master/std/container/trait."
"Container.html) trait provides the `len` method."
msgstr ""

#. type: Plain text
#: doc/complement-cheatsheet.md:94
msgid ""
"```rust let u: ~[u32] = ~[0, 1, 2]; let v: &[u32] = &[0, 1, 2, 3]; let w: "
"[u32, .. 5] = [0, 1, 2, 3, 4];"
msgstr ""

#. type: Plain text
#: doc/complement-cheatsheet.md:97
msgid ""
"println!(\"u: {}, v: {}, w: {}\", u.len(), v.len(), w.len()); // 3, 4, 5 ```"
msgstr ""

#. type: Plain text
#: doc/complement-cheatsheet.md:99
msgid "## How do I iterate over a vector?"
msgstr ""

#. type: Plain text
#: doc/complement-cheatsheet.md:101
msgid ""
"Use the [`iter`](http://static.rust-lang.org/doc/master/std/vec/trait."
"ImmutableVector.html#tymethod.iter) method."
msgstr ""

#. type: Plain text
#: doc/complement-cheatsheet.md:108
#, no-wrap
msgid ""
"```rust\n"
"let values: ~[int] = ~[1, 2, 3, 4, 5];\n"
"for value in values.iter() {  // value: &int\n"
"    println!(\"{}\", *value);\n"
"}\n"
"```\n"
msgstr ""

#. type: Plain text
#: doc/complement-cheatsheet.md:110
msgid ""
"(See also [`mut_iter`](http://static.rust-lang.org/doc/master/std/vec/trait."
"MutableVector.html#tymethod.mut_iter) which yields `&mut int` and "
"[`move_iter`](http://static.rust-lang.org/doc/master/std/vec/trait."
"OwnedVector.html#tymethod.move_iter) which yields `int` while consuming the "
"`values` vector.)"
msgstr ""

#. type: Plain text
#: doc/complement-cheatsheet.md:112 doc/rust.md:2970
msgid "# Type system"
msgstr ""

#. type: Plain text
#: doc/complement-cheatsheet.md:114
msgid "## How do I store a function in a struct?"
msgstr ""

#. type: Plain text
#: doc/complement-cheatsheet.md:119
#, no-wrap
msgid ""
"```rust\n"
"struct Foo {\n"
"    myfunc: fn(int, uint) -> i32\n"
"}\n"
msgstr ""

#. type: Plain text
#: doc/complement-cheatsheet.md:123
#, no-wrap
msgid ""
"struct FooClosure<'a> {\n"
"    myfunc: 'a |int, uint| -> i32\n"
"}\n"
msgstr ""

#. type: Plain text
#: doc/complement-cheatsheet.md:127
#, no-wrap
msgid ""
"fn a(a: int, b: uint) -> i32 {\n"
"    (a as uint + b) as i32\n"
"}\n"
msgstr ""

#. type: Plain text
#: doc/complement-cheatsheet.md:135
#, no-wrap
msgid ""
"fn main() {\n"
"    let f = Foo { myfunc: a };\n"
"    let g = FooClosure { myfunc: |a, b|  { (a - b as int) as i32 } };\n"
"    println!(\"{}\", (f.myfunc)(1, 2));\n"
"    println!(\"{}\", (g.myfunc)(3, 4));\n"
"}\n"
"```\n"
msgstr ""

#. type: Plain text
#: doc/complement-cheatsheet.md:137
msgid ""
"Note that the parenthesis surrounding `f.myfunc` are necessary: they are how "
"Rust disambiguates field lookup and method call. The `'a` on `FooClosure` is "
"the lifetime of the closure's environment pointer."
msgstr ""

#. type: Plain text
#: doc/complement-cheatsheet.md:139
msgid "## How do I express phantom types?"
msgstr ""

#. type: Plain text
#: doc/complement-cheatsheet.md:141
msgid ""
"[Phantom types](http://www.haskell.org/haskellwiki/Phantom_type) are those "
"that cannot be constructed at compile time. To express these in Rust, zero-"
"variant `enum`s can be used:"
msgstr ""

#. type: Plain text
#: doc/complement-cheatsheet.md:146
msgid "```rust enum Open {} enum Closed {} ```"
msgstr ""

#. type: Plain text
#: doc/complement-cheatsheet.md:148
msgid ""
"Phantom types are useful for enforcing state at compile time. For example:"
msgstr ""

#. type: Plain text
#: doc/complement-cheatsheet.md:151
msgid "```rust struct Door<State>(~str);"
msgstr ""

#. type: Plain text
#: doc/complement-cheatsheet.md:155
#, no-wrap
msgid ""
"fn close(Door(name): Door<Open>) -> Door<Closed> {\n"
"    Door::<Closed>(name)\n"
"}\n"
msgstr ""

#. type: Plain text
#: doc/complement-cheatsheet.md:159
#, no-wrap
msgid ""
"fn open(Door(name): Door<Closed>) -> Door<Open> {\n"
"    Door::<Open>(name)\n"
"}\n"
msgstr ""

#. type: Plain text
#: doc/complement-cheatsheet.md:163
#, no-wrap
msgid ""
"let _ = close(Door::<Open>(~\"front\"));   // ok\n"
"let _ = close(Door::<Closed>(~\"front\")); // error: mismatched types: expected `main::Door<main::Open>` but found `main::Door<main::Closed>`\n"
"```\n"
msgstr ""

#. type: Plain text
#: doc/complement-cheatsheet.md:165
msgid "# FFI (Foreign Function Interface)"
msgstr ""

#. type: Plain text
#: doc/complement-cheatsheet.md:167
msgid "## C function signature conversions"
msgstr ""

#. type: Plain text
#: doc/complement-cheatsheet.md:174
#, no-wrap
msgid ""
"Description           | C signature                                  | Equivalent Rust signature\n"
"----------------------|----------------------------------------------|------------------------------------------\n"
"no parameters         | `void foo(void);`                            | `fn foo();`\n"
"return value          | `int foo(void);`                             | `fn foo() -> c_int;`\n"
"function parameters   | `void foo(int x, int y);`                    | `fn foo(x: int, y: int);`\n"
"in-out pointers       | `void foo(const int* in_ptr, int* out_ptr);` | `fn foo(in_ptr: *c_int, out_ptr: *mut c_int);`\n"
msgstr ""

#. type: Plain text
#: doc/complement-cheatsheet.md:176
msgid ""
"Note: The Rust signatures should be wrapped in an `extern \"ABI\" { ... }` "
"block."
msgstr ""

#. type: Plain text
#: doc/complement-cheatsheet.md:178
msgid "### Representing opaque handles"
msgstr ""

#. type: Plain text
#: doc/complement-cheatsheet.md:180
msgid "You might see things like this in C APIs:"
msgstr ""

#. type: Plain text
#: doc/complement-cheatsheet.md:185
msgid ""
"```c typedef struct Window Window; Window* createWindow(int width, int "
"height); ```"
msgstr ""

#. type: Plain text
#: doc/complement-cheatsheet.md:187
msgid ""
"You can use a zero-element `enum` ([phantom type](#how-do-i-express-phantom-"
"types)) to represent the opaque object handle. The FFI would look like this:"
msgstr ""

#. type: Plain text
#: doc/complement-cheatsheet.md:194
#, no-wrap
msgid ""
"```rust\n"
"enum Window {}\n"
"extern \"C\" {\n"
"    fn createWindow(width: c_int, height: c_int) -> *Window;\n"
"}\n"
"```\n"
msgstr ""

#. type: Plain text
#: doc/complement-cheatsheet.md:196
msgid ""
"Using a phantom type ensures that the handles cannot be (safely) constructed "
"in client code."
msgstr ""

#. type: Plain text
#: doc/complement-cheatsheet.md:198
msgid "# Contributing to this page"
msgstr ""

#. type: Plain text
#: doc/complement-cheatsheet.md:200
msgid ""
"For small examples, have full type annotations, as much as is reasonable, to "
"keep it clear what, exactly, everything is doing. Try to link to the API "
"docs, as well."
msgstr ""

#. type: Plain text
#: doc/complement-cheatsheet.md:202
msgid "Similar documents for other programming languages:"
msgstr ""

#. type: Bullet: '  * '
#: doc/complement-cheatsheet.md:203
msgid "[http://pleac.sourceforge.net/](http://pleac.sourceforge.net)"
msgstr ""
