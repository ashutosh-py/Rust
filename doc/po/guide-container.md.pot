# SOME DESCRIPTIVE TITLE
# Copyright (C) YEAR The Rust Project Developers
# This file is distributed under the same license as the Rust package.
# FIRST AUTHOR <EMAIL@ADDRESS>, YEAR.
#
#, fuzzy
msgid ""
msgstr ""
"Project-Id-Version: Rust 0.9\n"
"POT-Creation-Date: 2014-01-08 11:30+0900\n"
"PO-Revision-Date: YEAR-MO-DA HO:MI+ZONE\n"
"Last-Translator: FULL NAME <EMAIL@ADDRESS>\n"
"Language-Team: LANGUAGE <LL@li.org>\n"
"Language: \n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=UTF-8\n"
"Content-Transfer-Encoding: 8bit\n"

#. type: Plain text
#: doc/complement-cheatsheet.md:85 doc/guide-container.md:4
msgid "# Containers"
msgstr ""

#. type: Plain text
#: doc/guide-container.md:2
msgid "% Containers and Iterators Guide"
msgstr ""

#. type: Plain text
#: doc/guide-container.md:6
msgid "The container traits are defined in the `std::container` module."
msgstr ""

#. type: Plain text
#: doc/guide-container.md:8
msgid "## Unique vectors"
msgstr ""

#. type: Plain text
#: doc/guide-container.md:12
msgid ""
"Vectors have `O(1)` indexing, push (to the end) and pop (from the end). "
"Vectors are the most common container in Rust, and are flexible enough to "
"fit many use cases."
msgstr ""

#. type: Plain text
#: doc/guide-container.md:16
msgid ""
"Vectors can also be sorted and used as efficient lookup tables with the "
"`bsearch()` method, if all the elements are inserted at one time and "
"deletions are unnecessary."
msgstr ""

#. type: Plain text
#: doc/guide-container.md:18
msgid "## Maps and sets"
msgstr ""

#. type: Plain text
#: doc/guide-container.md:22
msgid ""
"Maps are collections of unique keys with corresponding values, and sets are "
"just unique keys without a corresponding value. The `Map` and `Set` traits "
"in `std::container` define the basic interface."
msgstr ""

#. type: Plain text
#: doc/guide-container.md:24
msgid "The standard library provides three owned map/set types:"
msgstr ""

#. type: Bullet: '* '
#: doc/guide-container.md:30
msgid ""
"`std::hashmap::HashMap` and `std::hashmap::HashSet`, requiring the keys to "
"implement `Eq` and `Hash`"
msgstr ""

#. type: Bullet: '* '
#: doc/guide-container.md:30
msgid ""
"`std::trie::TrieMap` and `std::trie::TrieSet`, requiring the keys to be "
"`uint`"
msgstr ""

#. type: Bullet: '* '
#: doc/guide-container.md:30
msgid ""
"`extra::treemap::TreeMap` and `extra::treemap::TreeSet`, requiring the keys "
"to implement `TotalOrd`"
msgstr ""

#. type: Plain text
#: doc/guide-container.md:34
msgid ""
"These maps do not use managed pointers so they can be sent between tasks as "
"long as the key and value types are sendable. Neither the key or value type "
"has to be copyable."
msgstr ""

#. type: Plain text
#: doc/guide-container.md:37
msgid ""
"The `TrieMap` and `TreeMap` maps are ordered, while `HashMap` uses an "
"arbitrary order."
msgstr ""

#. type: Plain text
#: doc/guide-container.md:42
msgid ""
"Each `HashMap` instance has a random 128-bit key to use with a keyed hash, "
"making the order of a set of keys in a given hash table randomized. Rust "
"provides a [SipHash](https://131002.net/siphash/) implementation for any "
"type implementing the `IterBytes` trait."
msgstr ""

#. type: Plain text
#: doc/guide-container.md:44
msgid "## Double-ended queues"
msgstr ""

#. type: Plain text
#: doc/guide-container.md:50
msgid ""
"The `extra::ringbuf` module implements a double-ended queue with `O(1)` "
"amortized inserts and removals from both ends of the container. It also has "
"`O(1)` indexing like a vector. The contained elements are not required to be "
"copyable, and the queue will be sendable if the contained type is sendable.  "
"Its interface `Deque` is defined in `extra::collections`."
msgstr ""

#. type: Plain text
#: doc/guide-container.md:54
msgid ""
"The `extra::dlist` module implements a double-ended linked list, also "
"implementing the `Deque` trait, with `O(1)` removals and inserts at either "
"end, and `O(1)` concatenation."
msgstr ""

#. type: Plain text
#: doc/guide-container.md:56
msgid "## Priority queues"
msgstr ""

#. type: Plain text
#: doc/guide-container.md:60
msgid ""
"The `extra::priority_queue` module implements a queue ordered by a key.  The "
"contained elements are not required to be copyable, and the queue will be "
"sendable if the contained type is sendable."
msgstr ""

#. type: Plain text
#: doc/guide-container.md:66
msgid ""
"Insertions have `O(log n)` time complexity and checking or popping the "
"largest element is `O(1)`. Converting a vector to a priority queue can be "
"done in-place, and has `O(n)` complexity. A priority queue can also be "
"converted to a sorted vector in-place, allowing it to be used for an `O(n "
"log n)` in-place heapsort."
msgstr ""

#. type: Plain text
#: doc/guide-container.md:68
msgid "# Iterators"
msgstr ""

#. type: Plain text
#: doc/guide-container.md:70
msgid "## Iteration protocol"
msgstr ""

#. type: Plain text
#: doc/guide-container.md:74
msgid ""
"The iteration protocol is defined by the `Iterator` trait in the `std::iter` "
"module. The minimal implementation of the trait is a `next` method, yielding "
"the next element from an iterator object:"
msgstr ""

#. type: Plain text
#: doc/guide-container.md:78
msgid "~~~ /// An infinite stream of zeroes struct ZeroStream;"
msgstr ""

#. type: Plain text
#: doc/guide-container.md:85
#, no-wrap
msgid ""
"impl Iterator<int> for ZeroStream {\n"
"    fn next(&mut self) -> Option<int> {\n"
"        Some(0)\n"
"    }\n"
"}\n"
"~~~~\n"
msgstr ""

#. type: Plain text
#: doc/guide-container.md:88
msgid ""
"Reaching the end of the iterator is signalled by returning `None` instead of "
"`Some(item)`:"
msgstr ""

#. type: Plain text
#: doc/guide-container.md:95 doc/guide-container.md:310
#, no-wrap
msgid ""
"~~~\n"
"# fn main() {}\n"
"/// A stream of N zeroes\n"
"struct ZeroStream {\n"
"    priv remaining: uint\n"
"}\n"
msgstr ""

#. type: Plain text
#: doc/guide-container.md:101
#, no-wrap
msgid ""
"impl ZeroStream {\n"
"    fn new(n: uint) -> ZeroStream {\n"
"        ZeroStream { remaining: n }\n"
"    }\n"
"}\n"
msgstr ""

#. type: Plain text
#: doc/guide-container.md:113 doc/guide-container.md:332
#, no-wrap
msgid ""
"impl Iterator<int> for ZeroStream {\n"
"    fn next(&mut self) -> Option<int> {\n"
"        if self.remaining == 0 {\n"
"            None\n"
"        } else {\n"
"            self.remaining -= 1;\n"
"            Some(0)\n"
"        }\n"
"    }\n"
"}\n"
"~~~\n"
msgstr ""

#. type: Plain text
#: doc/guide-container.md:117
msgid ""
"In general, you cannot rely on the behavior of the `next()` method after it "
"has returned `None`. Some iterators may return `None` forever. Others may "
"behave differently."
msgstr ""

#. type: Plain text
#: doc/guide-container.md:119
msgid "## Container iterators"
msgstr ""

#. type: Plain text
#: doc/guide-container.md:122
msgid ""
"Containers implement iteration over the contained elements by returning an "
"iterator object. For example, vector slices several iterators available:"
msgstr ""

#. type: Bullet: '* '
#: doc/guide-container.md:126
msgid "`iter()` and `rev_iter()`, for immutable references to the elements"
msgstr ""

#. type: Bullet: '* '
#: doc/guide-container.md:126
msgid ""
"`mut_iter()` and `mut_rev_iter()`, for mutable references to the elements"
msgstr ""

#. type: Bullet: '* '
#: doc/guide-container.md:126
msgid "`move_iter()` and `move_rev_iter()`, to move the elements out by-value"
msgstr ""

#. type: Plain text
#: doc/guide-container.md:129
msgid ""
"A typical mutable container will implement at least `iter()`, `mut_iter()` "
"and `move_iter()` along with the reverse variants if it maintains an order."
msgstr ""

#. type: Plain text
#: doc/guide-container.md:131
msgid "### Freezing"
msgstr ""

#. type: Plain text
#: doc/guide-container.md:135
msgid ""
"Unlike most other languages with external iterators, Rust has no *iterator "
"invalidation*. As long an iterator is still in scope, the compiler will "
"prevent modification of the container through another handle."
msgstr ""

#. type: Plain text
#: doc/guide-container.md:140
#, no-wrap
msgid ""
"~~~\n"
"let mut xs = [1, 2, 3];\n"
"{\n"
"    let _it = xs.iter();\n"
msgstr ""

#. type: Plain text
#: doc/guide-container.md:146
#, no-wrap
msgid ""
"    // the vector is frozen for this scope, the compiler will statically\n"
"    // prevent modification\n"
"}\n"
"// the vector becomes unfrozen again at the end of the scope\n"
"~~~\n"
msgstr ""

#. type: Plain text
#: doc/guide-container.md:149
msgid ""
"These semantics are due to most container iterators being implemented with "
"`&` and `&mut`."
msgstr ""

#. type: Plain text
#: doc/guide-container.md:151
msgid "## Iterator adaptors"
msgstr ""

#. type: Plain text
#: doc/guide-container.md:155
msgid ""
"The `Iterator` trait provides many common algorithms as default methods. For "
"example, the `fold` method will accumulate the items yielded by an "
"`Iterator` into a single value:"
msgstr ""

#. type: Plain text
#: doc/guide-container.md:161
msgid ""
"~~~ let xs = [1, 9, 2, 3, 14, 12]; let result = xs.iter().fold(0, |"
"accumulator, item| accumulator - *item); assert_eq!(result, -41); ~~~"
msgstr ""

#. type: Plain text
#: doc/guide-container.md:163
msgid ""
"Most adaptors return an adaptor object implementing the `Iterator` trait "
"itself:"
msgstr ""

#. type: Plain text
#: doc/guide-container.md:170
msgid ""
"~~~ let xs = [1, 9, 2, 3, 14, 12]; let ys = [5, 2, 1, 8]; let sum = xs."
"iter().chain(ys.iter()).fold(0, |a, b| a + *b); assert_eq!(sum, 57); ~~~"
msgstr ""

#. type: Plain text
#: doc/guide-container.md:176
msgid ""
"Some iterator adaptors may return `None` before exhausting the underlying "
"iterator. Additionally, if these iterator adaptors are called again after "
"returning `None`, they may call their underlying iterator again even if the "
"adaptor will continue to return `None` forever. This may not be desired if "
"the underlying iterator has side-effects."
msgstr ""

#. type: Plain text
#: doc/guide-container.md:180
msgid ""
"In order to provide a guarantee about behavior once `None` has been "
"returned, an iterator adaptor named `fuse()` is provided. This returns an "
"iterator that will never call its underlying iterator again once `None` has "
"been returned:"
msgstr ""

#. type: Plain text
#: doc/guide-container.md:199
#, no-wrap
msgid ""
"~~~\n"
"let xs = [1,2,3,4,5];\n"
"let mut calls = 0;\n"
"let it = xs.iter().scan((), |_, x| {\n"
"    calls += 1;\n"
"    if *x < 3 { Some(x) } else { None }});\n"
"// the iterator will only yield 1 and 2 before returning None\n"
"// If we were to call it 5 times, calls would end up as 5, despite only 2 values\n"
"// being yielded (and therefore 3 unique calls being made). The fuse() adaptor\n"
"// can fix this.\n"
"let mut it = it.fuse();\n"
"it.next();\n"
"it.next();\n"
"it.next();\n"
"it.next();\n"
"it.next();\n"
"assert_eq!(calls, 3);\n"
"~~~\n"
msgstr ""

#. type: Plain text
#: doc/guide-container.md:201
msgid "## For loops"
msgstr ""

#. type: Plain text
#: doc/guide-container.md:203
msgid ""
"The function `range` (or `range_inclusive`) allows to simply iterate through "
"a given range:"
msgstr ""

#. type: Plain text
#: doc/guide-container.md:208
#, no-wrap
msgid ""
"~~~\n"
"for i in range(0, 5) {\n"
"  print!(\"{} \", i) // prints \"0 1 2 3 4\"\n"
"}\n"
msgstr ""

#. type: Plain text
#: doc/guide-container.md:213
#, no-wrap
msgid ""
"for i in std::iter::range_inclusive(0, 5) { // needs explicit import\n"
"  print!(\"{} \", i) // prints \"0 1 2 3 4 5\"\n"
"}\n"
"~~~\n"
msgstr ""

#. type: Plain text
#: doc/guide-container.md:215
msgid ""
"The `for` keyword can be used as sugar for iterating through any iterator:"
msgstr ""

#. type: Plain text
#: doc/guide-container.md:218
msgid "~~~ let xs = [2u, 3, 5, 7, 11, 13, 17];"
msgstr ""

#. type: Plain text
#: doc/guide-container.md:223
#, no-wrap
msgid ""
"// print out all the elements in the vector\n"
"for x in xs.iter() {\n"
"    println(x.to_str())\n"
"}\n"
msgstr ""

#. type: Plain text
#: doc/guide-container.md:229
#, no-wrap
msgid ""
"// print out all but the first 3 elements in the vector\n"
"for x in xs.iter().skip(3) {\n"
"    println(x.to_str())\n"
"}\n"
"~~~\n"
msgstr ""

#. type: Plain text
#: doc/guide-container.md:232
msgid ""
"For loops are *often* used with a temporary iterator object, as above. They "
"can also advance the state of an iterator in a mutable location:"
msgstr ""

#. type: Plain text
#: doc/guide-container.md:236
msgid ""
"~~~ let xs = [1, 2, 3, 4, 5]; let ys = [\"foo\", \"bar\", \"baz\", \"foobar"
"\"];"
msgstr ""

#. type: Plain text
#: doc/guide-container.md:239
msgid ""
"// create an iterator yielding tuples of elements from both vectors let mut "
"it = xs.iter().zip(ys.iter());"
msgstr ""

#. type: Plain text
#: doc/guide-container.md:243
#, no-wrap
msgid ""
"// print out the pairs of elements up to (&3, &\"baz\")\n"
"for (x, y) in it {\n"
"    println!(\"{} {}\", *x, *y);\n"
msgstr ""

#. type: Plain text
#: doc/guide-container.md:248
#, no-wrap
msgid ""
"    if *x == 3 {\n"
"        break;\n"
"    }\n"
"}\n"
msgstr ""

#. type: Plain text
#: doc/guide-container.md:251
msgid ""
"// yield and print the last pair from the iterator println!(\"last: {:?}\", "
"it.next());"
msgstr ""

#. type: Plain text
#: doc/guide-container.md:255
msgid "// the iterator is now fully consumed assert!(it.next().is_none()); ~~~"
msgstr ""

#. type: Plain text
#: doc/guide-container.md:257
msgid "## Conversion"
msgstr ""

#. type: Plain text
#: doc/guide-container.md:259
msgid ""
"Iterators offer generic conversion to containers with the `collect` adaptor:"
msgstr ""

#. type: Plain text
#: doc/guide-container.md:265
msgid ""
"~~~ let xs = [0, 1, 1, 2, 3, 5, 8]; let ys = xs.rev_iter().skip(1).map(|&x| "
"x * 2).collect::<~[int]>(); assert_eq!(ys, ~[10, 6, 4, 2, 2, 0]); ~~~"
msgstr ""

#. type: Plain text
#: doc/guide-container.md:268
msgid ""
"The method requires a type hint for the container type, if the surrounding "
"code does not provide sufficient information."
msgstr ""

#. type: Plain text
#: doc/guide-container.md:272
msgid ""
"Containers can provide conversion from iterators through `collect` by "
"implementing the `FromIterator` trait. For example, the implementation for "
"vectors is as follows:"
msgstr ""

#. type: Plain text
#: doc/guide-container.md:285
#, no-wrap
msgid ""
"~~~ {.xfail-test}\n"
"impl<A> FromIterator<A> for ~[A] {\n"
"    pub fn from_iterator<T: Iterator<A>>(iterator: &mut T) -> ~[A] {\n"
"        let (lower, _) = iterator.size_hint();\n"
"        let mut xs = with_capacity(lower);\n"
"        for x in iterator {\n"
"            xs.push(x);\n"
"        }\n"
"        xs\n"
"    }\n"
"}\n"
"~~~\n"
msgstr ""

#. type: Plain text
#: doc/guide-container.md:287
msgid "### Size hints"
msgstr ""

#. type: Plain text
#: doc/guide-container.md:290
msgid ""
"The `Iterator` trait provides a `size_hint` default method, returning a "
"lower bound and optionally on upper bound on the length of the iterator:"
msgstr ""

#. type: Plain text
#: doc/guide-container.md:294
msgid ""
"~~~ {.xfail-test} fn size_hint(&self) -> (uint, Option<uint>) { (0, None) } "
"~~~"
msgstr ""

#. type: Plain text
#: doc/guide-container.md:298
msgid ""
"The vector implementation of `FromIterator` from above uses the lower bound "
"to pre-allocate enough space to hold the minimum number of elements the "
"iterator will yield."
msgstr ""

#. type: Plain text
#: doc/guide-container.md:301
msgid ""
"The default implementation is always correct, but it should be overridden if "
"the iterator can provide better information."
msgstr ""

#. type: Plain text
#: doc/guide-container.md:303
msgid ""
"The `ZeroStream` from earlier can provide an exact lower and upper bound:"
msgstr ""

#. type: Plain text
#: doc/guide-container.md:315
#, no-wrap
msgid ""
"impl ZeroStream {\n"
"    fn new(n: uint) -> ZeroStream {\n"
"        ZeroStream { remaining: n }\n"
"    }\n"
msgstr ""

#. type: Plain text
#: doc/guide-container.md:320
#, no-wrap
msgid ""
"    fn size_hint(&self) -> (uint, Option<uint>) {\n"
"        (self.remaining, Some(self.remaining))\n"
"    }\n"
"}\n"
msgstr ""

#. type: Plain text
#: doc/guide-container.md:334
msgid "## Double-ended iterators"
msgstr ""

#. type: Plain text
#: doc/guide-container.md:338
msgid ""
"The `DoubleEndedIterator` trait represents an iterator able to yield "
"elements from either end of a range. It inherits from the `Iterator` trait "
"and extends it with the `next_back` function."
msgstr ""

#. type: Plain text
#: doc/guide-container.md:341
msgid ""
"A `DoubleEndedIterator` can be flipped with the `invert` adaptor, returning "
"another `DoubleEndedIterator` with `next` and `next_back` exchanged."
msgstr ""

#. type: Plain text
#: doc/guide-container.md:348
msgid ""
"~~~ let xs = [1, 2, 3, 4, 5, 6]; let mut it = xs.iter(); println!(\"{:?}\", "
"it.next()); // prints `Some(&1)` println!(\"{:?}\", it.next()); // prints "
"`Some(&2)` println!(\"{:?}\", it.next_back()); // prints `Some(&6)`"
msgstr ""

#. type: Plain text
#: doc/guide-container.md:354
#, no-wrap
msgid ""
"// prints `5`, `4` and `3`\n"
"for &x in it.invert() {\n"
"    println!(\"{}\", x)\n"
"}\n"
"~~~\n"
msgstr ""

#. type: Plain text
#: doc/guide-container.md:357
msgid ""
"The `rev_iter` and `mut_rev_iter` methods on vectors just return an inverted "
"version of the standard immutable and mutable vector iterators."
msgstr ""

#. type: Plain text
#: doc/guide-container.md:360
msgid ""
"The `chain`, `map`, `filter`, `filter_map` and `inspect` adaptors are "
"`DoubleEndedIterator` implementations if the underlying iterators are."
msgstr ""

#. type: Plain text
#: doc/guide-container.md:365
msgid ""
"~~~ let xs = [1, 2, 3, 4]; let ys = [5, 6, 7, 8]; let mut it = xs.iter()."
"chain(ys.iter()).map(|&x| x * 2);"
msgstr ""

#. type: Plain text
#: doc/guide-container.md:367
msgid "println!(\"{:?}\", it.next()); // prints `Some(2)`"
msgstr ""

#. type: Plain text
#: doc/guide-container.md:373
#, no-wrap
msgid ""
"// prints `16`, `14`, `12`, `10`, `8`, `6`, `4`\n"
"for x in it.invert() {\n"
"    println!(\"{}\", x);\n"
"}\n"
"~~~\n"
msgstr ""

#. type: Plain text
#: doc/guide-container.md:377
msgid ""
"The `reverse_` method is also available for any double-ended iterator "
"yielding mutable references. It can be used to reverse a container in-place. "
"Note that the trailing underscore is a workaround for issue #5898 and will "
"be removed."
msgstr ""

#. type: Plain text
#: doc/guide-container.md:383
msgid ""
"~~~ let mut ys = [1, 2, 3, 4, 5]; ys.mut_iter().reverse_(); assert_eq!(ys, "
"[5, 4, 3, 2, 1]); ~~~"
msgstr ""

#. type: Plain text
#: doc/guide-container.md:385
msgid "## Random-access iterators"
msgstr ""

#. type: Plain text
#: doc/guide-container.md:389
msgid ""
"The `RandomAccessIterator` trait represents an iterator offering random "
"access to the whole range. The `indexable` method retrieves the number of "
"elements accessible with the `idx` method."
msgstr ""

#. type: Plain text
#: doc/guide-container.md:392
msgid ""
"The `chain` adaptor is an implementation of `RandomAccessIterator` if the "
"underlying iterators are."
msgstr ""

#. type: Plain text
#: doc/guide-container.md:401
msgid ""
"~~~ let xs = [1, 2, 3, 4, 5]; let ys = ~[7, 9, 11]; let mut it = xs.iter()."
"chain(ys.iter()); println!(\"{:?}\", it.idx(0)); // prints `Some(&1)` "
"println!(\"{:?}\", it.idx(5)); // prints `Some(&7)` println!(\"{:?}\", it."
"idx(7)); // prints `Some(&11)` println!(\"{:?}\", it.idx(8)); // prints "
"`None`"
msgstr ""

#. type: Plain text
#: doc/guide-container.md:406
msgid ""
"// yield two elements from the beginning, and one from the end it.next(); it."
"next(); it.next_back();"
msgstr ""

#. type: Plain text
#: doc/guide-container.md:410
msgid ""
"println!(\"{:?}\", it.idx(0)); // prints `Some(&3)` println!(\"{:?}\", it."
"idx(4)); // prints `Some(&9)` println!(\"{:?}\", it.idx(6)); // prints "
"`None` ~~~"
msgstr ""
