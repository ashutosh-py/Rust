# Japanese translations for Rust package
# Copyright (C) 2014 The Rust Project Developers
# This file is distributed under the same license as the Rust package.
# Automatically generated, 2014.
#
msgid ""
msgstr ""
"Project-Id-Version: Rust 0.9\n"
"POT-Creation-Date: 2014-01-10 12:20+0900\n"
"PO-Revision-Date: 2014-01-10 12:20+0900\n"
"Last-Translator: Automatically generated\n"
"Language-Team: none\n"
"Language: ja\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=UTF-8\n"
"Content-Transfer-Encoding: 8bit\n"
"Plural-Forms: nplurals=1; plural=0;\n"

#. type: Plain text
#: doc/guide-conditions.md:4 doc/guide-ffi.md:4 doc/guide-lifetimes.md:4
#: doc/guide-macros.md:4 doc/guide-rustpkg.md:4 doc/guide-tasks.md:4
#: doc/rust.md:4 doc/rustpkg.md:4 doc/tutorial.md:4
msgid "# Introduction"
msgstr "# イントロダクション"

#. type: Plain text
#: doc/guide-lifetimes.md:2
msgid "% The Rust References and Lifetimes Guide"
msgstr ""

#. type: Plain text
#: doc/guide-lifetimes.md:14
msgid ""
"References are one of the more flexible and powerful tools available in "
"Rust. A reference can point anywhere: into the managed or exchange heap, "
"into the stack, and even into the interior of another data structure. A "
"reference is as flexible as a C pointer or C++ reference. However, unlike C "
"and C++ compilers, the Rust compiler includes special static checks that "
"ensure that programs use references safely. Another advantage of references "
"is that they are invisible to the garbage collector, so working with "
"references helps reduce the overhead of automatic memory management."
msgstr ""

#. type: Plain text
#: doc/guide-lifetimes.md:18
msgid ""
"Despite their complete safety, a reference's representation at runtime is "
"the same as that of an ordinary pointer in a C program. They introduce zero "
"overhead. The compiler does all safety checks at compile time."
msgstr ""

#. type: Plain text
#: doc/guide-lifetimes.md:24
msgid ""
"Although references have rather elaborate theoretical underpinnings (region "
"pointers), the core concepts will be familiar to anyone who has worked with "
"C or C++. Therefore, the best way to explain how they are used—and their "
"limitations—is probably just to work through several examples."
msgstr ""

#. type: Plain text
#: doc/guide-lifetimes.md:26
#, fuzzy
#| msgid "## A minimal example"
msgid "# By example"
msgstr "## 最小限の例"

#. type: Plain text
#: doc/guide-lifetimes.md:31
msgid ""
"References, sometimes known as *borrowed pointers*, are only valid for a "
"limited duration. References never claim any kind of ownership over the data "
"that they point to: instead, they are used for cases where you would like to "
"use data for a short time."
msgstr ""

#. type: Plain text
#: doc/guide-lifetimes.md:33
#, fuzzy
#| msgid "As an example, consider a simple struct type, `Point`:"
msgid "As an example, consider a simple struct type `Point`:"
msgstr "例として、シンプルな構造体型の `Point` について考えます。"

#. type: Plain text
#: doc/guide-lifetimes.md:37
msgid "~~~ struct Point {x: f64, y: f64} ~~~"
msgstr ""

#. type: Plain text
#: doc/guide-lifetimes.md:41
#, fuzzy
#| msgid ""
#| "We can use this simple definition to allocate points in many different "
#| "ways. For example, in this code, each of these three local variables "
#| "contains a point, but allocated in a different location:"
msgid ""
"We can use this simple definition to allocate points in many different ways. "
"For example, in this code, each of these three local variables contains a "
"point, but allocated in a different place:"
msgstr ""
"シンプルな定義ですが、この定義を使って `Point` 型のオブジェクトを様々な方法で"
"割り当てることができます。例えば、このコードの3つのローカル変数は、それぞれ異"
"なった場所に `Point` 型のオブジェクトを割り当てています。"

#. type: Plain text
#: doc/guide-lifetimes.md:48
#, fuzzy, no-wrap
#| msgid "~~~~ {.xfail-test} # struct Point { x: f64, y: f64 } let mut mypoint = Point { x: 1.0, y: 1.0 }; let origin = Point { x: 0.0, y: 0.0 };"
msgid ""
"~~~\n"
"# struct Point {x: f64, y: f64}\n"
"let on_the_stack :  Point =  Point {x: 3.0, y: 4.0};\n"
"let managed_box  : @Point = @Point {x: 5.0, y: 1.0};\n"
"let owned_box    : ~Point = ~Point {x: 7.0, y: 9.0};\n"
"~~~\n"
msgstr ""
"~~~~ {.xfail-test}\n"
"# struct Point { x: f64, y: f64 }\n"
"let mut mypoint = Point { x: 1.0, y: 1.0 };\n"
"let origin = Point { x: 0.0, y: 0.0 };"

#. type: Plain text
#: doc/guide-lifetimes.md:60
#, fuzzy
#| msgid ""
#| "Suppose we want to write a procedure that computes the distance between "
#| "any two points, no matter where they are stored. For example, we might "
#| "like to compute the distance between `on_the_stack` and `managed_box`, or "
#| "between `managed_box` and `owned_box`. One option is to define a function "
#| "that takes two arguments of type point—that is, it takes the points by "
#| "value. But this will cause the points to be copied when we call the "
#| "function. For points, this is probably not so bad, but often copies are "
#| "expensive. So we’d like to define a function that takes the points by "
#| "pointer. We can use borrowed pointers to do this:"
msgid ""
"Suppose we wanted to write a procedure that computed the distance between "
"any two points, no matter where they were stored. For example, we might like "
"to compute the distance between `on_the_stack` and `managed_box`, or between "
"`managed_box` and `owned_box`. One option is to define a function that takes "
"two arguments of type `Point`—that is, it takes the points by value. But if "
"we define it this way, calling the function will cause the points to be "
"copied. For points, this is probably not so bad, but often copies are "
"expensive. Worse, if the data type contains mutable fields, copying can "
"change the semantics of your program in unexpected ways. So we'd like to "
"define a function that takes the points by pointer. We can use references to "
"do this:"
msgstr ""
"`Point` 型のオブジェクトの割り当て先がどこであったとしても利用可能な、任意の "
"2 点間の距離を計算する処理を書きたいとします。例えば、 `on_the_stack`, "
"`managed_box` 間や `managed_box`, `owned_box` 間の距離を計算する処理です。 1"
"つ目の実装方法として、2つの `Point` 型オブジェクトを引数にとる関数を定義する"
"方法、すなわち、オブジェクトを値で受け渡す方法があります。しかし、この方法で"
"は関数呼び出し時に `Point` オブジェクトのコピーが行われます。`Point` オブジェ"
"クトの場合、このような実装はそれほど悪いものではないでしょうが、コピー処理の"
"コストは高い場合もあります。したがって、`Point` オブジェクトをポインタ渡しす"
"る関数を定義する必要があります。そのために、借用ポインタを利用することが可能"
"です。"

#. type: Plain text
#: doc/guide-lifetimes.md:70
#, no-wrap
msgid ""
"~~~\n"
"# struct Point {x: f64, y: f64}\n"
"# fn sqrt(f: f64) -> f64 { 0.0 }\n"
"fn compute_distance(p1: &Point, p2: &Point) -> f64 {\n"
"    let x_d = p1.x - p2.x;\n"
"    let y_d = p1.y - p2.y;\n"
"    sqrt(x_d * x_d + y_d * y_d)\n"
"}\n"
"~~~\n"
msgstr ""

#. type: Plain text
#: doc/guide-lifetimes.md:72 doc/tutorial.md:1394
msgid "Now we can call `compute_distance()` in various ways:"
msgstr ""
"上記の `compute_distance()` 関数は、様々な方法で呼び出すことができます。"

#. type: Plain text
#: doc/guide-lifetimes.md:82
#, no-wrap
msgid ""
"~~~\n"
"# struct Point {x: f64, y: f64}\n"
"# let on_the_stack :  Point =  Point{x: 3.0, y: 4.0};\n"
"# let managed_box  : @Point = @Point{x: 5.0, y: 1.0};\n"
"# let owned_box    : ~Point = ~Point{x: 7.0, y: 9.0};\n"
"# fn compute_distance(p1: &Point, p2: &Point) -> f64 { 0.0 }\n"
"compute_distance(&on_the_stack, managed_box);\n"
"compute_distance(managed_box, owned_box);\n"
"~~~\n"
msgstr ""

#. type: Plain text
#: doc/guide-lifetimes.md:89
#, fuzzy
#| msgid ""
#| "Here the `&` operator is used to take the address of the variable "
#| "`on_the_stack`; this is because `on_the_stack` has the type `Point` (that "
#| "is, a struct value) and we have to take its address to get a value. We "
#| "also call this _borrowing_ the local variable `on_the_stack`, because we "
#| "are creating an alias: that is, another route to the same data."
msgid ""
"Here, the `&` operator takes the address of the variable `on_the_stack`; "
"this is because `on_the_stack` has the type `Point` (that is, a struct "
"value) and we have to take its address to get a value. We also call this "
"_borrowing_ the local variable `on_the_stack`, because we have created an "
"alias: that is, another name for the same data."
msgstr ""
"ここで `&` 演算子は `on_the_stack` 変数のアドレスを取得するために使われていま"
"す。これは、 `on_the_stack` の型は `Point` (つまり、構造体の値) であり、呼び"
"出した関数から値を取得させるため、構造体のアドレスを渡す必要があるからです。"
"値の別名 (エイリアス)、すなわち、同じデータへアクセスするための別の方法を提供"
"するので、このような操作のことをローカル変数 `on_the_stack` の __借用__ "
"(_borrowing_) と呼びます。"

#. type: Plain text
#: doc/guide-lifetimes.md:95
#, fuzzy
#| msgid ""
#| "In the case of the boxes `managed_box` and `owned_box`, however, no "
#| "explicit action is necessary. The compiler will automatically convert a "
#| "box like `@point` or `~point` to a borrowed pointer like `&point`. This "
#| "is another form of borrowing; in this case, the contents of the managed/"
#| "owned box are being lent out."
msgid ""
"In contrast, we can pass the boxes `managed_box` and `owned_box` to "
"`compute_distance` directly. The compiler automatically converts a box like "
"`@Point` or `~Point` to a reference like `&Point`. This is another form of "
"borrowing: in this case, the caller lends the contents of the managed or "
"owned box to the callee."
msgstr ""
"ボックスである `managed_box` と `owned_box` の場合は、特に明示的な操作を行う"
"必要はありません。コンパイラは `@point` や `~point` のようなボックスを自動的"
"に `&point` のような借用ポインタへと変換します。これは、別の形態の借用 "
"(borrowing) です。この場合、マネージド/所有ボックスの内容が貸し出されていま"
"す。"

#. type: Plain text
#: doc/guide-lifetimes.md:105
#, fuzzy
#| msgid ""
#| "Whenever a value is borrowed, there are some limitations on what you can "
#| "do with the original. For example, if the contents of a variable have "
#| "been lent out, you cannot send that variable to another task, nor will "
#| "you be permitted to take actions that might cause the borrowed value to "
#| "be freed or to change its type. This rule should make intuitive sense: "
#| "you must wait for a borrowed value to be returned (that is, for the "
#| "borrowed pointer to go out of scope) before you can make full use of it "
#| "again."
msgid ""
"Whenever a caller lends data to a callee, there are some limitations on what "
"the caller can do with the original. For example, if the contents of a "
"variable have been lent out, you cannot send that variable to another task. "
"In addition, the compiler will reject any code that might cause the borrowed "
"value to be freed or overwrite its component fields with values of different "
"types (I'll get into what kinds of actions those are shortly). This rule "
"should make intuitive sense: you must wait for a borrower to return the "
"value that you lent it (that is, wait for the reference to go out of scope)  "
"before you can make full use of it again."
msgstr ""
"値が借用されている間、借用元の値に対して行える操作がいくらか制限されます。例"
"えば、変数の内容が貸し出された場合、その変数を他のタスクに送信することはでき"
"ませんし、借用された値を解放したり、型が変化させるような操作も行うことができ"
"ません。このルールは理にかなったものでしょう。貸し出した値を最大限に活用する "
"(make full use of it) ためには、貸し出した値の返却 (借用ポインタが存在するス"
"コープを抜ける) を待たなければなりません。"

#. type: Plain text
#: doc/guide-lifetimes.md:107
msgid "# Other uses for the & operator"
msgstr ""

#. type: Plain text
#: doc/guide-lifetimes.md:109
msgid "In the previous example, the value `on_the_stack` was defined like so:"
msgstr ""

#. type: Plain text
#: doc/guide-lifetimes.md:114
#, fuzzy
#| msgid ""
#| "~~~ # struct Point { x: f64, y: f64 } let point = &@~Point { x: 10f, y: "
#| "20f }; println(fmt!(\"%f\", point.x)); ~~~"
msgid ""
"~~~ # struct Point {x: f64, y: f64} let on_the_stack: Point = Point {x: 3.0, "
"y: 4.0}; ~~~"
msgstr ""
"~~~\n"
"# struct Point { x: f64, y: f64 }\n"
"let point = &@~Point { x: 10f, y: 20f };\n"
"println(fmt!(\"%f\", point.x));\n"
"~~~"

#. type: Plain text
#: doc/guide-lifetimes.md:119
msgid ""
"This declaration means that code can only pass `Point` by value to other "
"functions. As a consequence, we had to explicitly take the address of "
"`on_the_stack` to get a reference. Sometimes however it is more convenient "
"to move the & operator into the definition of `on_the_stack`:"
msgstr ""

#. type: Plain text
#: doc/guide-lifetimes.md:124
#, fuzzy
#| msgid ""
#| "~~~ # struct Point { x: f64, y: f64 } let point = &@~Point { x: 10f, y: "
#| "20f }; println(fmt!(\"%f\", point.x)); ~~~"
msgid ""
"~~~ # struct Point {x: f64, y: f64} let on_the_stack2: &Point = &Point {x: "
"3.0, y: 4.0}; ~~~"
msgstr ""
"~~~\n"
"# struct Point { x: f64, y: f64 }\n"
"let point = &@~Point { x: 10f, y: 20f };\n"
"println(fmt!(\"%f\", point.x));\n"
"~~~"

#. type: Plain text
#: doc/guide-lifetimes.md:128
msgid ""
"Applying `&` to an rvalue (non-assignable location) is just a convenient "
"shorthand for creating a temporary and taking its address. A more verbose "
"way to write the same code is:"
msgstr ""

#. type: Plain text
#: doc/guide-lifetimes.md:134
#, fuzzy
#| msgid ""
#| "~~~ # struct Point { x: f64, y: f64 } let point = &@~Point { x: 10f, y: "
#| "20f }; println(fmt!(\"%f\", point.x)); ~~~"
msgid ""
"~~~ # struct Point {x: f64, y: f64} let tmp = Point {x: 3.0, y: 4.0}; let "
"on_the_stack2 : &Point = &tmp; ~~~"
msgstr ""
"~~~\n"
"# struct Point { x: f64, y: f64 }\n"
"let point = &@~Point { x: 10f, y: 20f };\n"
"println(fmt!(\"%f\", point.x));\n"
"~~~"

#. type: Plain text
#: doc/guide-lifetimes.md:136
msgid "# Taking the address of fields"
msgstr ""

#. type: Plain text
#: doc/guide-lifetimes.md:141
msgid ""
"As in C, the `&` operator is not limited to taking the address of local "
"variables. It can also take the address of fields or individual array "
"elements. For example, consider this type definition for `rectangle`:"
msgstr ""

#. type: Plain text
#: doc/guide-lifetimes.md:147
msgid ""
"~~~ struct Point {x: f64, y: f64} // as before struct Size {w: f64, h: "
"f64} // as before struct Rectangle {origin: Point, size: Size} ~~~"
msgstr ""

#. type: Plain text
#: doc/guide-lifetimes.md:149
msgid "Now, as before, we can define rectangles in a few different ways:"
msgstr ""

#. type: Plain text
#: doc/guide-lifetimes.md:161
#, no-wrap
msgid ""
"~~~\n"
"# struct Point {x: f64, y: f64}\n"
"# struct Size {w: f64, h: f64} // as before\n"
"# struct Rectangle {origin: Point, size: Size}\n"
"let rect_stack   = &Rectangle {origin: Point {x: 1.0, y: 2.0},\n"
"                               size: Size {w: 3.0, h: 4.0}};\n"
"let rect_managed = @Rectangle {origin: Point {x: 3.0, y: 4.0},\n"
"                               size: Size {w: 3.0, h: 4.0}};\n"
"let rect_owned   = ~Rectangle {origin: Point {x: 5.0, y: 6.0},\n"
"                               size: Size {w: 3.0, h: 4.0}};\n"
"~~~\n"
msgstr ""

#. type: Plain text
#: doc/guide-lifetimes.md:164
msgid ""
"In each case, we can extract out individual subcomponents with the `&` "
"operator. For example, I could write:"
msgstr ""

#. type: Plain text
#: doc/guide-lifetimes.md:175
msgid ""
"~~~ # struct Point {x: f64, y: f64} // as before # struct Size {w: f64, h: "
"f64} // as before # struct Rectangle {origin: Point, size: Size} # let "
"rect_stack = &Rectangle {origin: Point {x: 1.0, y: 2.0}, size: Size {w: 3.0, "
"h: 4.0}}; # let rect_managed = @Rectangle {origin: Point {x: 3.0, y: 4.0}, "
"size: Size {w: 3.0, h: 4.0}}; # let rect_owned = ~Rectangle {origin: Point "
"{x: 5.0, y: 6.0}, size: Size {w: 3.0, h: 4.0}}; # fn compute_distance(p1: "
"&Point, p2: &Point) -> f64 { 0.0 } compute_distance(&rect_stack.origin, "
"&rect_managed.origin); ~~~"
msgstr ""

#. type: Plain text
#: doc/guide-lifetimes.md:178
msgid ""
"which would borrow the field `origin` from the rectangle on the stack as "
"well as from the managed box, and then compute the distance between them."
msgstr ""

#. type: Plain text
#: doc/guide-lifetimes.md:180
msgid "# Borrowing managed boxes and rooting"
msgstr ""

#. type: Plain text
#: doc/guide-lifetimes.md:186
msgid ""
"We’ve seen a few examples so far of borrowing heap boxes, both managed and "
"owned. Up till this point, we’ve glossed over issues of safety. As stated in "
"the introduction, at runtime a reference is simply a pointer, nothing more. "
"Therefore, avoiding C's problems with dangling pointers requires a compile-"
"time safety check."
msgstr ""

#. type: Plain text
#: doc/guide-lifetimes.md:197
msgid ""
"The basis for the check is the notion of _lifetimes_. A lifetime is a static "
"approximation of the span of execution during which the pointer is valid: it "
"always corresponds to some expression or block within the program. Code "
"inside that expression can use the pointer without restrictions. But if the "
"pointer escapes from that expression (for example, if the expression "
"contains an assignment expression that assigns the pointer to a mutable "
"field of a data structure with a broader scope than the pointer itself), the "
"compiler reports an error. We'll be discussing lifetimes more in the "
"examples to come, and a more thorough introduction is also available."
msgstr ""

#. type: Plain text
#: doc/guide-lifetimes.md:202
msgid ""
"When the `&` operator creates a reference, the compiler must ensure that the "
"pointer remains valid for its entire lifetime. Sometimes this is relatively "
"easy, such as when taking the address of a local variable or a field that is "
"stored on the stack:"
msgstr ""

#. type: Plain text
#: doc/guide-lifetimes.md:211
#, no-wrap
msgid ""
"~~~\n"
"struct X { f: int }\n"
"fn example1() {\n"
"    let mut x = X { f: 3 };\n"
"    let y = &mut x.f;  // -+ L\n"
"    ...                //  |\n"
"}                      // -+\n"
"~~~\n"
msgstr ""

#. type: Plain text
#: doc/guide-lifetimes.md:216
msgid ""
"Here, the lifetime of the reference `y` is simply L, the remainder of the "
"function body. The compiler need not do any other work to prove that code "
"will not free `x.f`. This is true even if the code mutates `x`."
msgstr ""

#. type: Plain text
#: doc/guide-lifetimes.md:218
msgid "The situation gets more complex when borrowing data inside heap boxes:"
msgstr ""

#. type: Plain text
#: doc/guide-lifetimes.md:227
#, no-wrap
msgid ""
"~~~\n"
"# struct X { f: int }\n"
"fn example2() {\n"
"    let mut x = @X { f: 3 };\n"
"    let y = &x.f;      // -+ L\n"
"    ...                //  |\n"
"}                      // -+\n"
"~~~\n"
msgstr ""

#. type: Plain text
#: doc/guide-lifetimes.md:238
msgid ""
"In this example, the value `x` is a heap box, and `y` is therefore a pointer "
"into that heap box. Again the lifetime of `y` is L, the remainder of the "
"function body. But there is a crucial difference: suppose `x` were to be "
"reassigned during the lifetime L? If the compiler isn't careful, the managed "
"box could become *unrooted*, and would therefore be subject to garbage "
"collection. A heap box that is unrooted is one such that no pointer values "
"in the heap point to it. It would violate memory safety for the box that was "
"originally assigned to `x` to be garbage-collected, since a non-heap pointer "
"*`y`* still points into it."
msgstr ""

#. type: Plain text
#: doc/guide-lifetimes.md:241
msgid ""
"> ***Note:*** Our current implementation implements the garbage collector > "
"using reference counting and cycle detection."
msgstr ""

#. type: Plain text
#: doc/guide-lifetimes.md:247
msgid ""
"For this reason, whenever an `&` expression borrows the interior of a "
"managed box stored in a mutable location, the compiler inserts a temporary "
"that ensures that the managed box remains live for the entire lifetime. So, "
"the above example would be compiled as if it were written"
msgstr ""

#. type: Plain text
#: doc/guide-lifetimes.md:257
#, no-wrap
msgid ""
"~~~\n"
"# struct X { f: int }\n"
"fn example2() {\n"
"    let mut x = @X {f: 3};\n"
"    let x1 = x;\n"
"    let y = &x1.f;     // -+ L\n"
"    ...                //  |\n"
"}                      // -+\n"
"~~~\n"
msgstr ""

#. type: Plain text
#: doc/guide-lifetimes.md:260
msgid ""
"Now if `x` is reassigned, the pointer `y` will still remain valid. This "
"process is called *rooting*."
msgstr ""

#. type: Plain text
#: doc/guide-lifetimes.md:262
#, fuzzy
#| msgid "# Borrowed pointers"
msgid "# Borrowing owned boxes"
msgstr "# 借用ポインタ"

#. type: Plain text
#: doc/guide-lifetimes.md:268
msgid ""
"The previous example demonstrated *rooting*, the process by which the "
"compiler ensures that managed boxes remain live for the duration of a "
"borrow. Unfortunately, rooting does not work for borrows of owned boxes, "
"because it is not possible to have two references to a owned box."
msgstr ""

#. type: Plain text
#: doc/guide-lifetimes.md:274
msgid ""
"For owned boxes, therefore, the compiler will only allow a borrow *if the "
"compiler can guarantee that the owned box will not be reassigned or moved "
"for the lifetime of the pointer*. This does not necessarily mean that the "
"owned box is stored in immutable memory. For example, the following function "
"is legal:"
msgstr ""

#. type: Plain text
#: doc/guide-lifetimes.md:289
#, no-wrap
msgid ""
"~~~\n"
"# fn some_condition() -> bool { true }\n"
"# struct Foo { f: int }\n"
"fn example3() -> int {\n"
"    let mut x = ~Foo {f: 3};\n"
"    if some_condition() {\n"
"        let y = &x.f;      // -+ L\n"
"        return *y;         //  |\n"
"    }                      // -+\n"
"    x = ~Foo {f: 4};\n"
"    ...\n"
"# return 0;\n"
"}\n"
"~~~\n"
msgstr ""

#. type: Plain text
#: doc/guide-lifetimes.md:295
msgid ""
"Here, as before, the interior of the variable `x` is being borrowed and `x` "
"is declared as mutable. However, the compiler can prove that `x` is not "
"assigned anywhere in the lifetime L of the variable `y`. Therefore, it "
"accepts the function, even though `x` is mutable and in fact is mutated "
"later in the function."
msgstr ""

#. type: Plain text
#: doc/guide-lifetimes.md:301
msgid ""
"It may not be clear why we are so concerned about mutating a borrowed "
"variable. The reason is that the runtime system frees any owned box _as soon "
"as its owning reference changes or goes out of scope_. Therefore, a program "
"like this is illegal (and would be rejected by the compiler):"
msgstr ""

#. type: Plain text
#: doc/guide-lifetimes.md:310
#, no-wrap
msgid ""
"~~~ {.xfail-test}\n"
"fn example3() -> int {\n"
"    let mut x = ~X {f: 3};\n"
"    let y = &x.f;\n"
"    x = ~X {f: 4};  // Error reported here.\n"
"    *y\n"
"}\n"
"~~~\n"
msgstr ""

#. type: Plain text
#: doc/guide-lifetimes.md:313
msgid ""
"To make this clearer, consider this diagram showing the state of memory "
"immediately before the re-assignment of `x`:"
msgstr ""

#. type: Plain text
#: doc/guide-lifetimes.md:316 doc/guide-lifetimes.md:330
#, no-wrap
msgid ""
"~~~ {.notrust}\n"
"    Stack               Exchange Heap\n"
msgstr ""

#. type: Plain text
#: doc/guide-lifetimes.md:325
#, no-wrap
msgid ""
"  x +----------+\n"
"    | ~{f:int} | ----+\n"
"  y +----------+     |\n"
"    | &int     | ----+\n"
"    +----------+     |    +---------+\n"
"                     +--> |  f: 3   |\n"
"                          +---------+\n"
"~~~\n"
msgstr ""

#. type: Plain text
#: doc/guide-lifetimes.md:327
msgid "Once the reassignment occurs, the memory will look like this:"
msgstr ""

#. type: Plain text
#: doc/guide-lifetimes.md:339
#, no-wrap
msgid ""
"  x +----------+          +---------+\n"
"    | ~{f:int} | -------> |  f: 4   |\n"
"  y +----------+          +---------+\n"
"    | &int     | ----+\n"
"    +----------+     |    +---------+\n"
"                     +--> | (freed) |\n"
"                          +---------+\n"
"~~~\n"
msgstr ""

#. type: Plain text
#: doc/guide-lifetimes.md:342
msgid ""
"Here you can see that the variable `y` still points at the old box, which "
"has been freed."
msgstr ""

#. type: Plain text
#: doc/guide-lifetimes.md:348
msgid ""
"In fact, the compiler can apply the same kind of reasoning to any memory "
"that is _(uniquely) owned by the stack frame_. So we could modify the "
"previous example to introduce additional owned pointers and structs, and the "
"compiler will still be able to detect possible mutations:"
msgstr ""

#. type: Plain text
#: doc/guide-lifetimes.md:353
#, no-wrap
msgid ""
"~~~ {.xfail-test}\n"
"fn example3() -> int {\n"
"    struct R { g: int }\n"
"    struct S { f: ~R }\n"
msgstr ""

#. type: Plain text
#: doc/guide-lifetimes.md:361
#, no-wrap
msgid ""
"    let mut x = ~S {f: ~R {g: 3}};\n"
"    let y = &x.f.g;\n"
"    x = ~S {f: ~R {g: 4}};  // Error reported here.\n"
"    x.f = ~R {g: 5};        // Error reported here.\n"
"    *y\n"
"}\n"
"~~~\n"
msgstr ""

#. type: Plain text
#: doc/guide-lifetimes.md:365
msgid ""
"In this case, two errors are reported, one when the variable `x` is modified "
"and another when `x.f` is modified. Either modification would invalidate the "
"pointer `y`."
msgstr ""

#. type: Plain text
#: doc/guide-lifetimes.md:367
#, fuzzy
#| msgid "# Borrowed pointers"
msgid "# Borrowing and enums"
msgstr "# 借用ポインタ"

#. type: Plain text
#: doc/guide-lifetimes.md:373
msgid ""
"The previous example showed that the type system forbids any borrowing of "
"owned boxes found in aliasable, mutable memory. This restriction prevents "
"pointers from pointing into freed memory. There is one other case where the "
"compiler must be very careful to ensure that pointers remain valid: pointers "
"into the interior of an `enum`."
msgstr ""

#. type: Plain text
#: doc/guide-lifetimes.md:376
msgid ""
"As an example, let’s look at the following `shape` type that can represent "
"both rectangles and circles:"
msgstr ""

#. type: Plain text
#: doc/guide-lifetimes.md:385
#, no-wrap
msgid ""
"~~~\n"
"struct Point {x: f64, y: f64}; // as before\n"
"struct Size {w: f64, h: f64}; // as before\n"
"enum Shape {\n"
"    Circle(Point, f64),   // origin, radius\n"
"    Rectangle(Point, Size)  // upper-left, dimensions\n"
"}\n"
"~~~\n"
msgstr ""

#. type: Plain text
#: doc/guide-lifetimes.md:389
msgid ""
"Now we might write a function to compute the area of a shape. This function "
"takes a reference to a shape, to avoid the need for copying."
msgstr ""

#. type: Plain text
#: doc/guide-lifetimes.md:405
#, no-wrap
msgid ""
"~~~\n"
"# struct Point {x: f64, y: f64}; // as before\n"
"# struct Size {w: f64, h: f64}; // as before\n"
"# enum Shape {\n"
"#     Circle(Point, f64),   // origin, radius\n"
"#     Rectangle(Point, Size)  // upper-left, dimensions\n"
"# }\n"
"# static tau: f64 = 6.28;\n"
"fn compute_area(shape: &Shape) -> f64 {\n"
"    match *shape {\n"
"        Circle(_, radius) => 0.5 * tau * radius * radius,\n"
"        Rectangle(_, ref size) => size.w * size.h\n"
"    }\n"
"}\n"
"~~~\n"
msgstr ""

#. type: Plain text
#: doc/guide-lifetimes.md:410
msgid ""
"The first case matches against circles. Here, the pattern extracts the "
"radius from the shape variant and the action uses it to compute the area of "
"the circle. (Like any up-to-date engineer, we use the [tau circle constant]"
"[tau] and not that dreadfully outdated notion of pi)."
msgstr ""

#. type: Plain text
#: doc/guide-lifetimes.md:412
msgid "[tau]: http://www.math.utah.edu/~palais/pi.html"
msgstr ""

#. type: Plain text
#: doc/guide-lifetimes.md:418
msgid ""
"The second match is more interesting. Here we match against a rectangle and "
"extract its size: but rather than copy the `size` struct, we use a by-"
"reference binding to create a pointer to it. In other words, a pattern "
"binding like `ref size` binds the name `size` to a pointer of type `&size` "
"into the _interior of the enum_."
msgstr ""

#. type: Plain text
#: doc/guide-lifetimes.md:421
msgid ""
"To make this more clear, let's look at a diagram of memory layout in the "
"case where `shape` points at a rectangle:"
msgstr ""

#. type: Plain text
#: doc/guide-lifetimes.md:424 doc/guide-lifetimes.md:449
#, no-wrap
msgid ""
"~~~ {.notrust}\n"
"Stack             Memory\n"
msgstr ""

#. type: Plain text
#: doc/guide-lifetimes.md:433
#, no-wrap
msgid ""
"+-------+         +---------------+\n"
"| shape | ------> | rectangle(    |\n"
"+-------+         |   {x: f64,    |\n"
"| size  | -+      |    y: f64},   |\n"
"+-------+  +----> |   {w: f64,    |\n"
"                  |    h: f64})   |\n"
"                  +---------------+\n"
"~~~\n"
msgstr ""

#. type: Plain text
#: doc/guide-lifetimes.md:440
msgid ""
"Here you can see that rectangular shapes are composed of five words of "
"memory. The first is a tag indicating which variant this enum is "
"(`rectangle`, in this case). The next two words are the `x` and `y` fields "
"for the point and the remaining two are the `w` and `h` fields for the size. "
"The binding `size` is then a pointer into the inside of the shape."
msgstr ""

#. type: Plain text
#: doc/guide-lifetimes.md:446
msgid ""
"Perhaps you can see where the danger lies: if the shape were somehow to be "
"reassigned, perhaps to a circle, then although the memory used to store that "
"shape value would still be valid, _it would have a different type_! The "
"following diagram shows what memory would look like if code overwrote "
"`shape` with a circle:"
msgstr ""

#. type: Plain text
#: doc/guide-lifetimes.md:458
#, no-wrap
msgid ""
"+-------+         +---------------+\n"
"| shape | ------> | circle(       |\n"
"+-------+         |   {x: f64,    |\n"
"| size  | -+      |    y: f64},   |\n"
"+-------+  +----> |   f64)        |\n"
"                  |               |\n"
"                  +---------------+\n"
"~~~\n"
msgstr ""

#. type: Plain text
#: doc/guide-lifetimes.md:463
msgid ""
"As you can see, the `size` pointer would be pointing at a `f64` instead of a "
"struct. This is not good: dereferencing the second field of a `f64` as if it "
"were a struct with two fields would be a memory safety violation."
msgstr ""

#. type: Plain text
#: doc/guide-lifetimes.md:475
msgid ""
"So, in fact, for every `ref` binding, the compiler will impose the same "
"rules as the ones we saw for borrowing the interior of a owned box: it must "
"be able to guarantee that the `enum` will not be overwritten for the "
"duration of the borrow.  In fact, the compiler would accept the example we "
"gave earlier. The example is safe because the shape pointer has type "
"`&Shape`, which means \"reference to immutable memory containing a `shape`"
"\". If, however, the type of that pointer were `&mut Shape`, then the ref "
"binding would be ill-typed.  Just as with owned boxes, the compiler will "
"permit `ref` bindings into data owned by the stack frame even if the data "
"are mutable, but otherwise it requires that the data reside in immutable "
"memory."
msgstr ""

#. type: Plain text
#: doc/guide-lifetimes.md:477
msgid "# Returning references"
msgstr ""

#. type: Plain text
#: doc/guide-lifetimes.md:483
msgid ""
"So far, all of the examples we have looked at, use references in a "
"“downward” direction. That is, a method or code block creates a reference, "
"then uses it within the same scope. It is also possible to return references "
"as the result of a function, but as we'll see, doing so requires some "
"explicit annotation."
msgstr ""

#. type: Plain text
#: doc/guide-lifetimes.md:485
msgid "For example, we could write a subroutine like this:"
msgstr ""

#. type: Plain text
#: doc/guide-lifetimes.md:490
msgid ""
"~~~ struct Point {x: f64, y: f64} fn get_x<'r>(p: &'r Point) -> &'r f64 { &p."
"x } ~~~"
msgstr ""

#. type: Plain text
#: doc/guide-lifetimes.md:498
msgid ""
"Here, the function `get_x()` returns a pointer into the structure it was "
"given. The type of the parameter (`&'r Point`) and return type (`&'r f64`) "
"both use a new syntactic form that we have not seen so far.  Here the "
"identifier `r` names the lifetime of the pointer explicitly. So in effect, "
"this function declares that it takes a pointer with lifetime `r` and returns "
"a pointer with that same lifetime."
msgstr ""

#. type: Plain text
#: doc/guide-lifetimes.md:504
msgid ""
"In general, it is only possible to return references if they are derived "
"from a parameter to the procedure. In that case, the pointer result will "
"always have the same lifetime as one of the parameters; named lifetimes "
"indicate which parameter that is."
msgstr ""

#. type: Plain text
#: doc/guide-lifetimes.md:510
msgid ""
"In the previous examples, function parameter types did not include a "
"lifetime name. In those examples, the compiler simply creates a fresh name "
"for the lifetime automatically: that is, the lifetime name is guaranteed to "
"refer to a distinct lifetime from the lifetimes of all other parameters."
msgstr ""

#. type: Plain text
#: doc/guide-lifetimes.md:518
msgid ""
"Named lifetimes that appear in function signatures are conceptually the same "
"as the other lifetimes we have seen before, but they are a bit abstract: "
"they don’t refer to a specific expression within `get_x()`, but rather to "
"some expression within the *caller of `get_x()`*.  The lifetime `r` is "
"actually a kind of *lifetime parameter*: it is defined by the caller to "
"`get_x()`, just as the value for the parameter `p` is defined by that caller."
msgstr ""

#. type: Plain text
#: doc/guide-lifetimes.md:523
msgid ""
"In any case, whatever the lifetime of `r` is, the pointer produced by `&p.x` "
"always has the same lifetime as `p` itself: a pointer to a field of a struct "
"is valid as long as the struct is valid. Therefore, the compiler accepts the "
"function `get_x()`."
msgstr ""

#. type: Plain text
#: doc/guide-lifetimes.md:526
msgid ""
"To emphasize this point, let’s look at a variation on the example, this time "
"one that does not compile:"
msgstr ""

#. type: Plain text
#: doc/guide-lifetimes.md:533
#, no-wrap
msgid ""
"~~~ {.xfail-test}\n"
"struct Point {x: f64, y: f64}\n"
"fn get_x_sh(p: @Point) -> &f64 {\n"
"    &p.x // Error reported here\n"
"}\n"
"~~~\n"
msgstr ""

#. type: Plain text
#: doc/guide-lifetimes.md:541
msgid ""
"Here, the function `get_x_sh()` takes a managed box as input and returns a "
"reference. As before, the lifetime of the reference that will be returned is "
"a parameter (specified by the caller). That means that `get_x_sh()` promises "
"to return a reference that is valid for as long as the caller would like: "
"this is subtly different from the first example, which promised to return a "
"pointer that was valid for as long as its pointer argument was valid."
msgstr ""

#. type: Plain text
#: doc/guide-lifetimes.md:552
msgid ""
"Within `get_x_sh()`, we see the expression `&p.x` which takes the address of "
"a field of a managed box. The presence of this expression implies that the "
"compiler must guarantee that, so long as the resulting pointer is valid, the "
"managed box will not be reclaimed by the garbage collector. But recall that "
"`get_x_sh()` also promised to return a pointer that was valid for as long as "
"the caller wanted it to be. Clearly, `get_x_sh()` is not in a position to "
"make both of these guarantees; in fact, it cannot guarantee that the pointer "
"will remain valid at all once it returns, as the parameter `p` may or may "
"not be live in the caller. Therefore, the compiler will report an error here."
msgstr ""

#. type: Plain text
#: doc/guide-lifetimes.md:559
msgid ""
"In general, if you borrow a managed (or owned) box to create a reference, it "
"will only be valid within the function and cannot be returned. This is why "
"the typical way to return references is to take references as input (the "
"only other case in which it can be legal to return a reference is if it "
"points at a static constant)."
msgstr ""

#. type: Plain text
#: doc/guide-lifetimes.md:561
msgid "# Named lifetimes"
msgstr ""

#. type: Plain text
#: doc/guide-lifetimes.md:565
msgid ""
"Let's look at named lifetimes in more detail. Named lifetimes allow for "
"grouping of parameters by lifetime. For example, consider this function:"
msgstr ""

#. type: Plain text
#: doc/guide-lifetimes.md:579
#, no-wrap
msgid ""
"~~~\n"
"# struct Point {x: f64, y: f64}; // as before\n"
"# struct Size {w: f64, h: f64}; // as before\n"
"# enum Shape {\n"
"#     Circle(Point, f64),   // origin, radius\n"
"#     Rectangle(Point, Size)  // upper-left, dimensions\n"
"# }\n"
"# fn compute_area(shape: &Shape) -> f64 { 0.0 }\n"
"fn select<'r, T>(shape: &'r Shape, threshold: f64,\n"
"                 a: &'r T, b: &'r T) -> &'r T {\n"
"    if compute_area(shape) > threshold {a} else {b}\n"
"}\n"
"~~~\n"
msgstr ""

#. type: Plain text
#: doc/guide-lifetimes.md:585
msgid ""
"This function takes three references and assigns each the same lifetime "
"`r`.  In practice, this means that, in the caller, the lifetime `r` will be "
"the *intersection of the lifetime of the three region parameters*. This may "
"be overly conservative, as in this example:"
msgstr ""

#. type: Plain text
#: doc/guide-lifetimes.md:607
#, no-wrap
msgid ""
"~~~\n"
"# struct Point {x: f64, y: f64}; // as before\n"
"# struct Size {w: f64, h: f64}; // as before\n"
"# enum Shape {\n"
"#     Circle(Point, f64),   // origin, radius\n"
"#     Rectangle(Point, Size)  // upper-left, dimensions\n"
"# }\n"
"# fn compute_area(shape: &Shape) -> f64 { 0.0 }\n"
"# fn select<'r, T>(shape: &Shape, threshold: f64,\n"
"#                  a: &'r T, b: &'r T) -> &'r T {\n"
"#     if compute_area(shape) > threshold {a} else {b}\n"
"# }\n"
"                                                     // -+ r\n"
"fn select_based_on_unit_circle<'r, T>(               //  |-+ B\n"
"    threshold: f64, a: &'r T, b: &'r T) -> &'r T { //  | |\n"
"                                                     //  | |\n"
"    let shape = Circle(Point {x: 0., y: 0.}, 1.);    //  | |\n"
"    select(&shape, threshold, a, b)                  //  | |\n"
"}                                                    //  |-+\n"
"                                                     // -+\n"
"~~~\n"
msgstr ""

#. type: Plain text
#: doc/guide-lifetimes.md:617
msgid ""
"In this call to `select()`, the lifetime of the first parameter shape is B, "
"the function body. Both of the second two parameters `a` and `b` share the "
"same lifetime, `r`, which is a lifetime parameter of "
"`select_based_on_unit_circle()`. The caller will infer the intersection of "
"these two lifetimes as the lifetime of the returned value, and hence the "
"return value of `select()` will be assigned a lifetime of B. This will in "
"turn lead to a compilation error, because `select_based_on_unit_circle()` is "
"supposed to return a value with the lifetime `r`."
msgstr ""

#. type: Plain text
#: doc/guide-lifetimes.md:622
msgid ""
"To address this, we can modify the definition of `select()` to distinguish "
"the lifetime of the first parameter from the lifetime of the latter two. "
"After all, the first parameter is not being returned. Here is how the new "
"`select()` might look:"
msgstr ""

#. type: Plain text
#: doc/guide-lifetimes.md:636
#, no-wrap
msgid ""
"~~~\n"
"# struct Point {x: f64, y: f64}; // as before\n"
"# struct Size {w: f64, h: f64}; // as before\n"
"# enum Shape {\n"
"#     Circle(Point, f64),   // origin, radius\n"
"#     Rectangle(Point, Size)  // upper-left, dimensions\n"
"# }\n"
"# fn compute_area(shape: &Shape) -> f64 { 0.0 }\n"
"fn select<'r, 'tmp, T>(shape: &'tmp Shape, threshold: f64,\n"
"                       a: &'r T, b: &'r T) -> &'r T {\n"
"    if compute_area(shape) > threshold {a} else {b}\n"
"}\n"
"~~~\n"
msgstr ""

#. type: Plain text
#: doc/guide-lifetimes.md:641
msgid ""
"Here you can see that `shape`'s lifetime is now named `tmp`. The parameters "
"`a`, `b`, and the return value all have the lifetime `r`.  However, since "
"the lifetime `tmp` is not returned, it would be more concise to just omit "
"the named lifetime for `shape` altogether:"
msgstr ""

#. type: Plain text
#: doc/guide-lifetimes.md:655
#, no-wrap
msgid ""
"~~~\n"
"# struct Point {x: f64, y: f64}; // as before\n"
"# struct Size {w: f64, h: f64}; // as before\n"
"# enum Shape {\n"
"#     Circle(Point, f64),   // origin, radius\n"
"#     Rectangle(Point, Size)  // upper-left, dimensions\n"
"# }\n"
"# fn compute_area(shape: &Shape) -> f64 { 0.0 }\n"
"fn select<'r, T>(shape: &Shape, threshold: f64,\n"
"                 a: &'r T, b: &'r T) -> &'r T {\n"
"    if compute_area(shape) > threshold {a} else {b}\n"
"}\n"
"~~~\n"
msgstr ""

#. type: Plain text
#: doc/guide-lifetimes.md:657
msgid "This is equivalent to the previous definition."
msgstr ""

#. type: Plain text
#: doc/guide-lifetimes.md:659
#, fuzzy
#| msgid "## Conventions"
msgid "# Conclusion"
msgstr "## 本書の表記について"

#. type: Plain text
#: doc/guide-lifetimes.md:663
msgid ""
"So there you have it: a (relatively) brief tour of the lifetime system. For "
"more details, we refer to the (yet to be written) reference document on "
"references, which will explain the full notation and give more examples."
msgstr ""
