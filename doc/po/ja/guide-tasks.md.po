# Japanese translations for Rust package
# Copyright (C) 2014 The Rust Project Developers
# This file is distributed under the same license as the Rust package.
# Automatically generated, 2014.
#
msgid ""
msgstr ""
"Project-Id-Version: Rust 0.9\n"
"POT-Creation-Date: 2014-01-10 12:20+0900\n"
"PO-Revision-Date: 2014-01-10 12:20+0900\n"
"Last-Translator: Automatically generated\n"
"Language-Team: none\n"
"Language: ja\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=UTF-8\n"
"Content-Transfer-Encoding: 8bit\n"
"Plural-Forms: nplurals=1; plural=0;\n"

#. type: Plain text
#: doc/guide-conditions.md:4 doc/guide-ffi.md:4 doc/guide-lifetimes.md:4
#: doc/guide-macros.md:4 doc/guide-rustpkg.md:4 doc/guide-tasks.md:4
#: doc/rust.md:4 doc/rustpkg.md:4 doc/tutorial.md:4
msgid "# Introduction"
msgstr "# イントロダクション"

#. type: Plain text
#: doc/guide-tasks.md:2
#, fuzzy
#| msgid "[Tasks and communication][tasks]"
msgid "% The Rust Tasks and Communication Guide"
msgstr "[タスクと通信][tasks]"

#. type: Plain text
#: doc/guide-tasks.md:10
msgid ""
"Rust provides safe concurrency through a combination of lightweight, memory-"
"isolated tasks and message passing.  This guide will describe the "
"concurrency model in Rust, how it relates to the Rust type system, and "
"introduce the fundamental library abstractions for constructing concurrent "
"programs."
msgstr ""

#. type: Plain text
#: doc/guide-tasks.md:19
msgid ""
"Rust tasks are not the same as traditional threads: rather, they are "
"considered _green threads_, lightweight units of execution that the Rust "
"runtime schedules cooperatively onto a small number of operating system "
"threads.  On a multi-core system Rust tasks will be scheduled in parallel by "
"default.  Because tasks are significantly cheaper to create than traditional "
"threads, Rust can create hundreds of thousands of concurrent tasks on a "
"typical 32-bit system.  In general, all Rust code executes inside a task, "
"including the `main` function."
msgstr ""

#. type: Plain text
#: doc/guide-tasks.md:26
msgid ""
"In order to make efficient use of memory Rust tasks have dynamically sized "
"stacks.  A task begins its life with a small amount of stack space "
"(currently in the low thousands of bytes, depending on platform), and "
"acquires more stack as needed.  Unlike in languages such as C, a Rust task "
"cannot accidentally write to memory beyond the end of the stack, causing "
"crashes or worse."
msgstr ""

#. type: Plain text
#: doc/guide-tasks.md:32
msgid ""
"Tasks provide failure isolation and recovery. When a fatal error occurs in "
"Rust code as a result of an explicit call to `fail!()`, an assertion "
"failure, or another invalid operation, the runtime system destroys the "
"entire task. Unlike in languages such as Java and C++, there is no way to "
"`catch` an exception. Instead, tasks may monitor each other for failure."
msgstr ""

#. type: Plain text
#: doc/guide-tasks.md:37
msgid ""
"Tasks use Rust's type system to provide strong memory safety guarantees. In "
"particular, the type system guarantees that tasks cannot share mutable state "
"with each other. Tasks communicate with each other by transferring _owned_ "
"data through the global _exchange heap_."
msgstr ""

#. type: Plain text
#: doc/guide-tasks.md:39
msgid "## A note about the libraries"
msgstr ""

#. type: Plain text
#: doc/guide-tasks.md:44
msgid ""
"While Rust's type system provides the building blocks needed for safe and "
"efficient tasks, all of the task functionality itself is implemented in the "
"standard and extra libraries, which are still under development and do not "
"always present a consistent or complete interface."
msgstr ""

#. type: Plain text
#: doc/guide-tasks.md:47
msgid ""
"For your reference, these are the standard modules involved in Rust "
"concurrency at this writing:"
msgstr ""

#. type: Bullet: '* '
#: doc/guide-tasks.md:55
msgid "[`std::task`] - All code relating to tasks and task scheduling,"
msgstr ""

#. type: Bullet: '* '
#: doc/guide-tasks.md:55
msgid "[`std::comm`] - The message passing interface,"
msgstr ""

#. type: Bullet: '* '
#: doc/guide-tasks.md:55
msgid "[`extra::comm`] - Additional messaging types based on `std::comm`,"
msgstr ""

#. type: Bullet: '* '
#: doc/guide-tasks.md:55
msgid "[`extra::sync`] - More exotic synchronization tools, including locks,"
msgstr ""

#. type: Bullet: '* '
#: doc/guide-tasks.md:55
msgid ""
"[`extra::arc`] - The Arc (atomically reference counted) type, for safely "
"sharing immutable data,"
msgstr ""

#. type: Bullet: '* '
#: doc/guide-tasks.md:55
msgid ""
"[`extra::future`] - A type representing values that may be computed "
"concurrently and retrieved at a later time."
msgstr ""

#. type: Plain text
#: doc/guide-tasks.md:62
msgid ""
"[`std::task`]: std/task/index.html [`std::comm`]: std/comm/index.html "
"[`extra::comm`]: extra/comm/index.html [`extra::sync`]: extra/sync/index."
"html [`extra::arc`]: extra/arc/index.html [`extra::future`]: extra/future/"
"index.html"
msgstr ""

#. type: Plain text
#: doc/guide-tasks.md:64
#, fuzzy
#| msgid "# Syntax basics"
msgid "# Basics"
msgstr "# 基本的な構文"

#. type: Plain text
#: doc/guide-tasks.md:70
msgid ""
"The programming interface for creating and managing tasks lives in the "
"`task` module of the `std` library, and is thus available to all Rust code "
"by default. At its simplest, creating a task is a matter of calling the "
"`spawn` function with a closure argument. `spawn` executes the closure in "
"the new task."
msgstr ""

#. type: Plain text
#: doc/guide-tasks.md:73 doc/guide-tasks.md:132
#, fuzzy
#| msgid "~~~~ use std::task::spawn;"
msgid "~~~~ # use std::task::spawn;"
msgstr ""
"~~~~\n"
"use std::task::spawn;"

#. type: Plain text
#: doc/guide-tasks.md:77
msgid ""
"// Print something profound in a different task using a named function fn "
"print_message() { println(\"I am running in a different task!\"); } "
"spawn(print_message);"
msgstr ""

#. type: Plain text
#: doc/guide-tasks.md:80
msgid ""
"// Print something more profound in a different task using a lambda "
"expression spawn(proc() println(\"I am also running in a different task!"
"\") );"
msgstr ""

#. type: Plain text
#: doc/guide-tasks.md:86
#, no-wrap
msgid ""
"// The canonical way to spawn is using `do` notation\n"
"do spawn {\n"
"    println(\"I too am running in a different task!\");\n"
"}\n"
"~~~~\n"
msgstr ""

#. type: Plain text
#: doc/guide-tasks.md:92
msgid ""
"In Rust, there is nothing special about creating tasks: a task is not a "
"concept that appears in the language semantics. Instead, Rust's type system "
"provides all the tools necessary to implement safe concurrency: "
"particularly, _owned types_. The language leaves the implementation details "
"to the standard library."
msgstr ""

#. type: Plain text
#: doc/guide-tasks.md:99
msgid ""
"The `spawn` function has a very simple type signature: `fn spawn(f: "
"proc())`. Because it accepts only owned closures, and owned closures contain "
"only owned data, `spawn` can safely move the entire closure and all its "
"associated state into an entirely different task for execution. Like any "
"closure, the function passed to `spawn` may capture an environment that it "
"carries across tasks."
msgstr ""

#. type: Plain text
#: doc/guide-tasks.md:105
msgid ""
"~~~ # use std::task::spawn; # fn generate_task_number() -> int { 0 } // "
"Generate some state locally let child_task_number = generate_task_number();"
msgstr ""

#. type: Plain text
#: doc/guide-tasks.md:111
#, no-wrap
msgid ""
"do spawn {\n"
"    // Capture it in the remote task\n"
"    println!(\"I am child number {}\", child_task_number);\n"
"}\n"
"~~~\n"
msgstr ""

#. type: Plain text
#: doc/guide-tasks.md:113
#, fuzzy
#| msgid "## Conditionals"
msgid "## Communication"
msgstr "## 条件式"

#. type: Plain text
#: doc/guide-tasks.md:118
msgid ""
"Now that we have spawned a new task, it would be nice if we could "
"communicate with it. Recall that Rust does not have shared mutable state, so "
"one task may not manipulate variables owned by another task.  Instead we use "
"*pipes*."
msgstr ""

#. type: Plain text
#: doc/guide-tasks.md:123
msgid ""
"A pipe is simply a pair of endpoints: one for sending messages and another "
"for receiving messages. Pipes are low-level communication building-blocks "
"and so come in a variety of forms, each one appropriate for a different use "
"case. In what follows, we cover the most commonly used varieties."
msgstr ""

#. type: Plain text
#: doc/guide-tasks.md:129
msgid ""
"The simplest way to create a pipe is to use `Chan::new` function to create a "
"`(Port, Chan)` pair. In Rust parlance, a *channel* is a sending endpoint of "
"a pipe, and a *port* is the receiving endpoint. Consider the following "
"example of calculating two results concurrently:"
msgstr ""

#. type: Plain text
#: doc/guide-tasks.md:134
msgid "let (port, chan): (Port<int>, Chan<int>) = Chan::new();"
msgstr ""

#. type: Plain text
#: doc/guide-tasks.md:139
#, no-wrap
msgid ""
"do spawn || {\n"
"    let result = some_expensive_computation();\n"
"    chan.send(result);\n"
"}\n"
msgstr ""

#. type: Plain text
#: doc/guide-tasks.md:145
msgid ""
"some_other_expensive_computation(); let result = port.recv(); # fn "
"some_expensive_computation() -> int { 42 } # fn "
"some_other_expensive_computation() {} ~~~~"
msgstr ""

#. type: Plain text
#: doc/guide-tasks.md:150
msgid ""
"Let's examine this example in detail. First, the `let` statement creates a "
"stream for sending and receiving integers (the left-hand side of the `let`, "
"`(chan, port)`, is an example of a *destructuring let*: the pattern "
"separates a tuple into its component parts)."
msgstr ""

#. type: Plain text
#: doc/guide-tasks.md:154
msgid "~~~~ let (port, chan): (Port<int>, Chan<int>) = Chan::new(); ~~~~"
msgstr ""

#. type: Plain text
#: doc/guide-tasks.md:158
msgid ""
"The child task will use the channel to send data to the parent task, which "
"will wait to receive the data on the port. The next statement spawns the "
"child task."
msgstr ""

#. type: Plain text
#: doc/guide-tasks.md:168
#, no-wrap
msgid ""
"~~~~\n"
"# use std::task::spawn;\n"
"# fn some_expensive_computation() -> int { 42 }\n"
"# let (port, chan) = Chan::new();\n"
"do spawn || {\n"
"    let result = some_expensive_computation();\n"
"    chan.send(result);\n"
"}\n"
"~~~~\n"
msgstr ""

#. type: Plain text
#: doc/guide-tasks.md:174
msgid ""
"Notice that the creation of the task closure transfers `chan` to the child "
"task implicitly: the closure captures `chan` in its environment. Both `Chan` "
"and `Port` are sendable types and may be captured into tasks or otherwise "
"transferred between them. In the example, the child task runs an expensive "
"computation, then sends the result over the captured channel."
msgstr ""

#. type: Plain text
#: doc/guide-tasks.md:178
msgid ""
"Finally, the parent continues with some other expensive computation, then "
"waits for the child's result to arrive on the port:"
msgstr ""

#. type: Plain text
#: doc/guide-tasks.md:186
msgid ""
"~~~~ # fn some_other_expensive_computation() {} # let (port, chan) = Chan::"
"<int>::new(); # chan.send(0); some_other_expensive_computation(); let result "
"= port.recv(); ~~~~"
msgstr ""

#. type: Plain text
#: doc/guide-tasks.md:192
msgid ""
"The `Port` and `Chan` pair created by `Chan::new` enables efficient "
"communication between a single sender and a single receiver, but multiple "
"senders cannot use a single `Chan`, and multiple receivers cannot use a "
"single `Port`.  What if our example needed to compute multiple results "
"across a number of tasks? The following program is ill-typed:"
msgstr ""

#. type: Plain text
#: doc/guide-tasks.md:197
msgid ""
"~~~ {.xfail-test} # use std::task::{spawn}; # fn "
"some_expensive_computation() -> int { 42 } let (port, chan) = Chan::new();"
msgstr ""

#. type: Plain text
#: doc/guide-tasks.md:201
#, no-wrap
msgid ""
"do spawn {\n"
"    chan.send(some_expensive_computation());\n"
"}\n"
msgstr ""

#. type: Plain text
#: doc/guide-tasks.md:208
#, no-wrap
msgid ""
"// ERROR! The previous spawn statement already owns the channel,\n"
"// so the compiler will not allow it to be captured again\n"
"do spawn {\n"
"    chan.send(some_expensive_computation());\n"
"}\n"
"~~~\n"
msgstr ""

#. type: Plain text
#: doc/guide-tasks.md:211
msgid ""
"Instead we can use a `SharedChan`, a type that allows a single `Chan` to be "
"shared by multiple senders."
msgstr ""

#. type: Plain text
#: doc/guide-tasks.md:214
#, fuzzy
#| msgid "~~~~ use std::task::spawn;"
msgid "~~~ # use std::task::spawn;"
msgstr ""
"~~~~\n"
"use std::task::spawn;"

#. type: Plain text
#: doc/guide-tasks.md:216
msgid "let (port, chan) = SharedChan::new();"
msgstr ""

#. type: Plain text
#: doc/guide-tasks.md:224
#, no-wrap
msgid ""
"for init_val in range(0u, 3) {\n"
"    // Create a new channel handle to distribute to the child task\n"
"    let child_chan = chan.clone();\n"
"    do spawn {\n"
"        child_chan.send(some_expensive_computation(init_val));\n"
"    }\n"
"}\n"
msgstr ""

#. type: Plain text
#: doc/guide-tasks.md:228
msgid ""
"let result = port.recv() + port.recv() + port.recv(); # fn "
"some_expensive_computation(_i: uint) -> int { 42 } ~~~"
msgstr ""

#. type: Plain text
#: doc/guide-tasks.md:237
msgid ""
"Here we transfer ownership of the channel into a new `SharedChan` value.  "
"Like `Chan`, `SharedChan` is a non-copyable, owned type (sometimes also "
"referred to as an *affine* or *linear* type). Unlike with `Chan`, though, "
"the programmer may duplicate a `SharedChan`, with the `clone()` method.  A "
"cloned `SharedChan` produces a new handle to the same channel, allowing "
"multiple tasks to send data to a single port.  Between `spawn`, `Chan` and "
"`SharedChan`, we have enough tools to implement many useful concurrency "
"patterns."
msgstr ""

#. type: Plain text
#: doc/guide-tasks.md:242
msgid ""
"Note that the above `SharedChan` example is somewhat contrived since you "
"could also simply use three `Chan` pairs, but it serves to illustrate the "
"point. For reference, written with multiple streams, it might look like the "
"example below."
msgstr ""

#. type: Plain text
#: doc/guide-tasks.md:246
#, fuzzy
#| msgid "~~~~ use std::task::spawn;"
msgid "~~~ # use std::task::spawn; # use std::vec;"
msgstr ""
"~~~~\n"
"use std::task::spawn;"

#. type: Plain text
#: doc/guide-tasks.md:255
#, no-wrap
msgid ""
"// Create a vector of ports, one for each child task\n"
"let ports = vec::from_fn(3, |init_val| {\n"
"    let (port, chan) = Chan::new();\n"
"    do spawn {\n"
"        chan.send(some_expensive_computation(init_val));\n"
"    }\n"
"    port\n"
"});\n"
msgstr ""

#. type: Plain text
#: doc/guide-tasks.md:260
msgid ""
"// Wait on each port, accumulating the results let result = ports.iter()."
"fold(0, |accum, port| accum + port.recv() ); # fn "
"some_expensive_computation(_i: uint) -> int { 42 } ~~~"
msgstr ""

#. type: Plain text
#: doc/guide-tasks.md:264
msgid ""
"## Backgrounding computations: Futures With `extra::future`, rust has a "
"mechanism for requesting a computation and getting the result later."
msgstr ""

#. type: Plain text
#: doc/guide-tasks.md:266
msgid "The basic example below illustrates this."
msgstr ""

#. type: Plain text
#: doc/guide-tasks.md:273
#, no-wrap
msgid ""
"~~~\n"
"# fn make_a_sandwich() {};\n"
"fn fib(n: u64) -> u64 {\n"
"    // lengthy computation returning an uint\n"
"    12586269025\n"
"}\n"
msgstr ""

#. type: Plain text
#: doc/guide-tasks.md:278
msgid ""
"let mut delayed_fib = extra::future::Future::spawn(proc() fib(50)); "
"make_a_sandwich(); println!(\"fib(50) = {:?}\", delayed_fib.get())  ~~~"
msgstr ""

#. type: Plain text
#: doc/guide-tasks.md:284
msgid ""
"The call to `future::spawn` returns immediately a `future` object regardless "
"of how long it takes to run `fib(50)`. You can then make yourself a sandwich "
"while the computation of `fib` is running. The result of the execution of "
"the method is obtained by calling `get` on the future.  This call will block "
"until the value is available (*i.e.* the computation is complete). Note that "
"the future needs to be mutable so that it can save the result for next time "
"`get` is called."
msgstr ""

#. type: Plain text
#: doc/guide-tasks.md:287
msgid ""
"Here is another example showing how futures allow you to background "
"computations. The workload will be distributed on the available cores."
msgstr ""

#. type: Plain text
#: doc/guide-tasks.md:297
#, no-wrap
msgid ""
"~~~\n"
"# use std::vec;\n"
"fn partial_sum(start: uint) -> f64 {\n"
"    let mut local_sum = 0f64;\n"
"    for num in range(start*100000, (start+1)*100000) {\n"
"        local_sum += (num as f64 + 1.0).pow(&-2.0);\n"
"    }\n"
"    local_sum\n"
"}\n"
msgstr ""

#. type: Plain text
#: doc/guide-tasks.md:300
#, no-wrap
msgid ""
"fn main() {\n"
"    let mut futures = vec::from_fn(1000, |ind| do extra::future::Future::spawn { partial_sum(ind) });\n"
msgstr ""

#. type: Plain text
#: doc/guide-tasks.md:308
#, no-wrap
msgid ""
"    let mut final_res = 0f64;\n"
"    for ft in futures.mut_iter()  {\n"
"        final_res += ft.get();\n"
"    }\n"
"    println!(\"π^2/6 is not far from : {}\", final_res);\n"
"}\n"
"~~~\n"
msgstr ""

#. type: Plain text
#: doc/guide-tasks.md:310
msgid "## Sharing immutable data without copy: Arc"
msgstr ""

#. type: Plain text
#: doc/guide-tasks.md:315
msgid ""
"To share immutable data between tasks, a first approach would be to only use "
"pipes as we have seen previously. A copy of the data to share would then be "
"made for each task. In some cases, this would add up to a significant amount "
"of wasted memory and would require copying the same data more than necessary."
msgstr ""

#. type: Plain text
#: doc/guide-tasks.md:319
msgid ""
"To tackle this issue, one can use an Atomically Reference Counted wrapper "
"(`Arc`) as implemented in the `extra` library of Rust. With an Arc, the data "
"will no longer be copied for each task. The Arc acts as a reference to the "
"shared data and only this reference is shared and cloned."
msgstr ""

#. type: Plain text
#: doc/guide-tasks.md:322
msgid ""
"Here is a small example showing how to use Arcs. We wish to run concurrently "
"several computations on a single large vector of floats. Each task needs the "
"full vector to perform its duty."
msgstr ""

#. type: Plain text
#: doc/guide-tasks.md:327
msgid "~~~ # use std::vec; # use std::rand; use extra::arc::Arc;"
msgstr ""

#. type: Plain text
#: doc/guide-tasks.md:331
#, no-wrap
msgid ""
"fn pnorm(nums: &~[f64], p: uint) -> f64 {\n"
"    nums.iter().fold(0.0, |a,b| a+(*b).pow(&(p as f64)) ).pow(&(1.0 / (p as f64)))\n"
"}\n"
msgstr ""

#. type: Plain text
#: doc/guide-tasks.md:335
#, no-wrap
msgid ""
"fn main() {\n"
"    let numbers = vec::from_fn(1000000, |_| rand::random::<f64>());\n"
"    println!(\"Inf-norm = {}\",  *numbers.iter().max().unwrap());\n"
msgstr ""

#. type: Plain text
#: doc/guide-tasks.md:337
#, no-wrap
msgid "    let numbers_arc = Arc::new(numbers);\n"
msgstr ""

#. type: Plain text
#: doc/guide-tasks.md:341
#, no-wrap
msgid ""
"    for num in range(1u, 10) {\n"
"        let (port, chan)  = Chan::new();\n"
"        chan.send(numbers_arc.clone());\n"
msgstr ""

#. type: Plain text
#: doc/guide-tasks.md:350
#, no-wrap
msgid ""
"        do spawn {\n"
"            let local_arc : Arc<~[f64]> = port.recv();\n"
"            let task_numbers = local_arc.get();\n"
"            println!(\"{}-norm = {}\", num, pnorm(task_numbers, num));\n"
"        }\n"
"    }\n"
"}\n"
"~~~\n"
msgstr ""

#. type: Plain text
#: doc/guide-tasks.md:354
msgid ""
"The function `pnorm` performs a simple computation on the vector (it "
"computes the sum of its items at the power given as argument and takes the "
"inverse power of this value). The Arc on the vector is created by the line"
msgstr ""

#. type: Plain text
#: doc/guide-tasks.md:362
msgid ""
"~~~ # use extra::arc::Arc; # use std::vec; # use std::rand; # let numbers = "
"vec::from_fn(1000000, |_| rand::random::<f64>()); let numbers_arc=Arc::"
"new(numbers); ~~~"
msgstr ""

#. type: Plain text
#: doc/guide-tasks.md:364
msgid "and a clone of it is sent to each task"
msgstr ""

#. type: Plain text
#: doc/guide-tasks.md:374
msgid ""
"~~~ # use extra::arc::Arc; # use std::vec; # use std::rand; # let "
"numbers=vec::from_fn(1000000, |_| rand::random::<f64>()); # let numbers_arc "
"= Arc::new(numbers); # let (port, chan)  = Chan::new(); chan."
"send(numbers_arc.clone()); ~~~"
msgstr ""

#. type: Plain text
#: doc/guide-tasks.md:376
msgid "copying only the wrapper and not its contents."
msgstr ""

#. type: Plain text
#: doc/guide-tasks.md:378
msgid "Each task recovers the underlying data by"
msgstr ""

#. type: Plain text
#: doc/guide-tasks.md:390
msgid ""
"~~~ # use extra::arc::Arc; # use std::vec; # use std::rand; # let "
"numbers=vec::from_fn(1000000, |_| rand::random::<f64>()); # let "
"numbers_arc=Arc::new(numbers); # let (port, chan)  = Chan::new(); # chan."
"send(numbers_arc.clone()); # let local_arc : Arc<~[f64]> = port.recv(); let "
"task_numbers = local_arc.get(); ~~~"
msgstr ""

#. type: Plain text
#: doc/guide-tasks.md:392
msgid "and can use it as if it were local."
msgstr ""

#. type: Plain text
#: doc/guide-tasks.md:394
msgid ""
"The `arc` module also implements Arcs around mutable data that are not "
"covered here."
msgstr ""

#. type: Plain text
#: doc/guide-tasks.md:396
msgid "# Handling task failure"
msgstr ""

#. type: Plain text
#: doc/guide-tasks.md:405
msgid ""
"Rust has a built-in mechanism for raising exceptions. The `fail!()` macro "
"(which can also be written with an error string as an argument: `fail!"
"( ~reason)`) and the `assert!` construct (which effectively calls `fail!()` "
"if a boolean expression is false) are both ways to raise exceptions. When a "
"task raises an exception the task unwinds its stack---running destructors "
"and freeing memory along the way---and then exits. Unlike exceptions in C++, "
"exceptions in Rust are unrecoverable within a single task: once a task "
"fails, there is no way to \"catch\" the exception."
msgstr ""

#. type: Plain text
#: doc/guide-tasks.md:415
msgid ""
"While it isn't possible for a task to recover from failure, tasks may notify "
"each other of failure. The simplest way of handling task failure is with the "
"`try` function, which is similar to `spawn`, but immediately blocks waiting "
"for the child task to finish. `try` returns a value of type `Result<T, ()>`. "
"`Result` is an `enum` type with two variants: `Ok` and `Err`. In this case, "
"because the type arguments to `Result` are `int` and `()`, callers can "
"pattern-match on a result to check whether it's an `Ok` result with an `int` "
"field (representing a successful result) or an `Err` result (representing "
"termination with an error)."
msgstr ""

#. type: Plain text
#: doc/guide-tasks.md:429
#, no-wrap
msgid ""
"~~~{.xfail-test .linked-failure}\n"
"# use std::task;\n"
"# fn some_condition() -> bool { false }\n"
"# fn calculate_result() -> int { 0 }\n"
"let result: Result<int, ()> = do task::try {\n"
"    if some_condition() {\n"
"        calculate_result()\n"
"    } else {\n"
"        fail!(\"oops!\");\n"
"    }\n"
"};\n"
"assert!(result.is_err());\n"
"~~~\n"
msgstr ""

#. type: Plain text
#: doc/guide-tasks.md:435
msgid ""
"Unlike `spawn`, the function spawned using `try` may return a value, which "
"`try` will dutifully propagate back to the caller in a [`Result`] enum. If "
"the child task terminates successfully, `try` will return an `Ok` result; if "
"the child task fails, `try` will return an `Error` result."
msgstr ""

#. type: Plain text
#: doc/guide-tasks.md:437
msgid "[`Result`]: std/result/index.html"
msgstr ""

#. type: Plain text
#: doc/guide-tasks.md:442
msgid ""
"> ***Note:*** A failed task does not currently produce a useful error > "
"value (`try` always returns `Err(())`). In the > future, it may be possible "
"for tasks to intercept the value passed to > `fail!()`."
msgstr ""

#. type: Plain text
#: doc/guide-tasks.md:445
msgid ""
"TODO: Need discussion of `future_result` in order to make failure modes "
"useful."
msgstr ""

#. type: Plain text
#: doc/guide-tasks.md:453
msgid ""
"But not all failures are created equal. In some cases you might need to "
"abort the entire program (perhaps you're writing an assert which, if it "
"trips, indicates an unrecoverable logic error); in other cases you might "
"want to contain the failure at a certain boundary (perhaps a small piece of "
"input from the outside world, which you happen to be processing in parallel, "
"is malformed and its processing task can't proceed)."
msgstr ""

#. type: Plain text
#: doc/guide-tasks.md:455
msgid "## Creating a task with a bi-directional communication path"
msgstr ""

#. type: Plain text
#: doc/guide-tasks.md:460
msgid ""
"A very common thing to do is to spawn a child task where the parent and "
"child both need to exchange messages with each other. The function `extra::"
"comm::DuplexStream()` supports this pattern.  We'll look briefly at how to "
"use it."
msgstr ""

#. type: Plain text
#: doc/guide-tasks.md:465
msgid ""
"To see how `DuplexStream()` works, we will create a child task that "
"repeatedly receives a `uint` message, converts it to a string, and sends the "
"string in response.  The child terminates when it receives `0`.  Here is the "
"function that implements the child task:"
msgstr ""

#. type: Plain text
#: doc/guide-tasks.md:478
#, no-wrap
msgid ""
"~~~{.xfail-test .linked-failure}\n"
"# use extra::comm::DuplexStream;\n"
"# use std::uint;\n"
"fn stringifier(channel: &DuplexStream<~str, uint>) {\n"
"    let mut value: uint;\n"
"    loop {\n"
"        value = channel.recv();\n"
"        channel.send(uint::to_str(value));\n"
"        if value == 0 { break; }\n"
"    }\n"
"}\n"
"~~~~\n"
msgstr ""

#. type: Plain text
#: doc/guide-tasks.md:486
msgid ""
"The implementation of `DuplexStream` supports both sending and receiving. "
"The `stringifier` function takes a `DuplexStream` that can send strings (the "
"first type parameter) and receive `uint` messages (the second type "
"parameter). The body itself simply loops, reading from the channel and then "
"sending its response back.  The actual response itself is simply the "
"stringified version of the received value, `uint::to_str(value)`."
msgstr ""

#. type: Plain text
#: doc/guide-tasks.md:488
msgid "Here is the code for the parent task:"
msgstr ""

#. type: Plain text
#: doc/guide-tasks.md:502
#, no-wrap
msgid ""
"~~~{.xfail-test .linked-failure}\n"
"# use std::task::spawn;\n"
"# use std::uint;\n"
"# use extra::comm::DuplexStream;\n"
"# fn stringifier(channel: &DuplexStream<~str, uint>) {\n"
"#     let mut value: uint;\n"
"#     loop {\n"
"#         value = channel.recv();\n"
"#         channel.send(uint::to_str(value));\n"
"#         if value == 0u { break; }\n"
"#     }\n"
"# }\n"
"# fn main() {\n"
msgstr ""

#. type: Plain text
#: doc/guide-tasks.md:504
msgid "let (from_child, to_child) = DuplexStream::new();"
msgstr ""

#. type: Plain text
#: doc/guide-tasks.md:508
#, no-wrap
msgid ""
"do spawn {\n"
"    stringifier(&to_child);\n"
"};\n"
msgstr ""

#. type: Plain text
#: doc/guide-tasks.md:511
msgid "from_child.send(22); assert!(from_child.recv() == ~\"22\");"
msgstr ""

#. type: Plain text
#: doc/guide-tasks.md:514
msgid "from_child.send(23); from_child.send(0);"
msgstr ""

#. type: Plain text
#: doc/guide-tasks.md:517
msgid ""
"assert!(from_child.recv() == ~\"23\"); assert!(from_child.recv() == ~\"0\");"
msgstr ""

#. type: Plain text
#: doc/guide-tasks.md:520 doc/rust.md:2384
msgid "# } ~~~~"
msgstr ""

#. type: Plain text
#: doc/guide-tasks.md:524
msgid ""
"The parent task first calls `DuplexStream` to create a pair of bidirectional "
"endpoints. It then uses `task::spawn` to create the child task, which "
"captures one end of the communication channel.  As a result, both parent and "
"child can send and receive data to and from the other."
msgstr ""
