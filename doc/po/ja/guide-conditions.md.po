# Japanese translations for Rust package
# Copyright (C) 2014 The Rust Project Developers
# This file is distributed under the same license as the Rust package.
# Automatically generated, 2014.
#
msgid ""
msgstr ""
"Project-Id-Version: Rust 0.9\n"
"POT-Creation-Date: 2014-01-10 12:20+0900\n"
"PO-Revision-Date: 2014-01-10 12:20+0900\n"
"Last-Translator: Automatically generated\n"
"Language-Team: none\n"
"Language: ja\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=UTF-8\n"
"Content-Transfer-Encoding: 8bit\n"
"Plural-Forms: nplurals=1; plural=0;\n"

#. type: Plain text
#: doc/guide-conditions.md:2
msgid "% The Rust Condition and Error-handling Guide"
msgstr ""

#. type: Plain text
#: doc/guide-conditions.md:4 doc/guide-ffi.md:4 doc/guide-lifetimes.md:4
#: doc/guide-macros.md:4 doc/guide-rustpkg.md:4 doc/guide-tasks.md:4
#: doc/rust.md:4 doc/rustpkg.md:4 doc/tutorial.md:4
msgid "# Introduction"
msgstr "# イントロダクション"

#. type: Plain text
#: doc/guide-conditions.md:9
msgid ""
"Rust does not provide exception handling[^why-no-exceptions] in the form "
"most commonly seen in other programming languages such as C++ or Java.  "
"Instead, it provides four mechanisms that work together to handle errors or "
"other rare events.  The four mechanisms are:"
msgstr ""

#. type: Bullet: '  - '
#: doc/guide-conditions.md:14
msgid "Options"
msgstr ""

#. type: Bullet: '  - '
#: doc/guide-conditions.md:14
msgid "Results"
msgstr ""

#. type: Bullet: '  - '
#: doc/guide-conditions.md:14
msgid "Failure"
msgstr ""

#. type: Bullet: '  - '
#: doc/guide-conditions.md:14
#, fuzzy
#| msgid "## Conditionals"
msgid "Conditions"
msgstr "## 条件式"

#. type: Plain text
#: doc/guide-conditions.md:17
msgid ""
"This guide will lead you through use of these mechanisms in order to "
"understand the trade-offs of each and relationships between them."
msgstr ""

#. type: Plain text
#: doc/guide-conditions.md:19
msgid "# Example program"
msgstr ""

#. type: Plain text
#: doc/guide-conditions.md:25
msgid ""
"This guide will be based around an example program that attempts to read "
"lines from a file consisting of pairs of numbers, and then print them back "
"out with slightly different formatting.  The input to the program might look "
"like this:"
msgstr ""

#. type: Plain text
#: doc/guide-conditions.md:33
msgid "~~~~ {.notrust} $ cat numbers.txt 1 2 34 56 789 123 45 67 ~~~~"
msgstr ""

#. type: Plain text
#: doc/guide-conditions.md:35
msgid "For which the intended output looks like this:"
msgstr ""

#. type: Plain text
#: doc/guide-conditions.md:43
msgid ""
"~~~~ {.notrust} $ ./example numbers.txt 0001, 0002 0034, 0056 0789, 0123 "
"0045, 0067 ~~~~"
msgstr ""

#. type: Plain text
#: doc/guide-conditions.md:45
msgid "An example program that does this task reads like this:"
msgstr ""

#. type: Plain text
#: doc/guide-conditions.md:64 doc/guide-conditions.md:368
#: doc/guide-conditions.md:438 doc/guide-conditions.md:514
#: doc/guide-conditions.md:600 doc/guide-conditions.md:725
#, no-wrap
msgid ""
"~~~~\n"
"# #[allow(unused_imports)];\n"
"# extern mod extra;\n"
"use std::io::buffered::BufferedReader;\n"
"use std::io::File;\n"
"# mod BufferedReader {\n"
"#     use std::io::File;\n"
"#     use std::io::mem::MemReader;\n"
"#     use std::io::buffered::BufferedReader;\n"
"#     static s : &'static [u8] = bytes!(\"1 2\\n\\\n"
"#                                        34 56\\n\\\n"
"#                                        789 123\\n\\\n"
"#                                        45 67\\n\\\n"
"#                                        \");\n"
"#     pub fn new(_inner: Option<File>) -> BufferedReader<MemReader> {\n"
"#           BufferedReader::new(MemReader::new(s.to_owned()))\n"
"#     }\n"
"# }\n"
msgstr ""

#. type: Plain text
#: doc/guide-conditions.md:71 doc/guide-conditions.md:380
#, no-wrap
msgid ""
"fn main() {\n"
"    let pairs = read_int_pairs();\n"
"    for &(a,b) in pairs.iter() {\n"
"        println!(\"{:4.4d}, {:4.4d}\", a, b);\n"
"    }\n"
"}\n"
msgstr ""

#. type: Plain text
#: doc/guide-conditions.md:74
#, no-wrap
msgid ""
"fn read_int_pairs() -> ~[(int,int)] {\n"
"    let mut pairs = ~[];\n"
msgstr ""

#. type: Plain text
#: doc/guide-conditions.md:79
#, no-wrap
msgid ""
"    // Path takes a generic by-value, rather than by reference\n"
"#    let _g = std::io::ignore_io_error();\n"
"    let path = Path::new(&\"foo.txt\");\n"
"    let mut reader = BufferedReader::new(File::open(&path));\n"
msgstr ""

#. type: Plain text
#: doc/guide-conditions.md:86
#, no-wrap
msgid ""
"    // 1. Iterate over the lines of our file.\n"
"    for line in reader.lines() {\n"
"        // 2. Split the line into fields (\"words\").\n"
"        let fields = line.words().to_owned_vec();\n"
"        // 3. Match the vector of fields against a vector pattern.\n"
"        match fields {\n"
msgstr ""

#. type: Plain text
#: doc/guide-conditions.md:91
#, no-wrap
msgid ""
"            // 4. When the line had two fields:\n"
"            [a, b] => {\n"
"                // 5. Try parsing both fields as ints.\n"
"                match (from_str::<int>(a), from_str::<int>(b)) {\n"
msgstr ""

#. type: Plain text
#: doc/guide-conditions.md:105
#, no-wrap
msgid ""
"                    // 6. If parsing succeeded for both, push both.\n"
"                    (Some(a), Some(b)) => pairs.push((a,b)),\n"
"                    // 7. Ignore non-int fields.\n"
"                    _ => ()\n"
"                }\n"
"            }\n"
"            // 8. Ignore lines that don't have 2 fields.\n"
"            _ => ()\n"
"        }\n"
"    }\n"
"    pairs\n"
"}\n"
"~~~~\n"
msgstr ""

#. type: Plain text
#: doc/guide-conditions.md:110
msgid ""
"This example shows the use of `Option`, along with some other forms of error-"
"handling (and non-handling).  We will look at these mechanisms and then "
"modify parts of the example to perform \"better\" error handling."
msgstr ""

#. type: Plain text
#: doc/guide-conditions.md:112
#, fuzzy
#| msgid "# Functions"
msgid "# Options"
msgstr "# 関数"

#. type: Plain text
#: doc/guide-conditions.md:124
msgid ""
"The simplest and most lightweight mechanism in Rust for indicating an error "
"is the type `std::option::Option<T>`.  This type is a general purpose `enum` "
"for conveying a value of type `T`, represented as `Some(T)` _or_ the "
"sentinel `None`, to indicate the absence of a `T` value.  For simple APIs, "
"it may be sufficient to encode errors as `Option<T>`, returning `Some(T)` on "
"success and `None` on error.  In the example program, the call to `from_str::"
"<int>` returns `Option<int>` with the understanding that \"all parse errors"
"\" result in `None`.  The resulting `Option<int>` values are matched against "
"the pattern `(Some(a), Some(b))` in steps 5 and 6 in the example program, to "
"handle the case in which both fields were parsed successfully."
msgstr ""

#. type: Plain text
#: doc/guide-conditions.md:126
msgid "Using `Option` as in this API has some advantages:"
msgstr ""

#. type: Bullet: '  - '
#: doc/guide-conditions.md:131
msgid "Simple API, users can read it and guess how it works."
msgstr ""

#. type: Bullet: '  - '
#: doc/guide-conditions.md:131
msgid "Very efficient, only an extra `enum` tag on return values."
msgstr ""

#. type: Bullet: '  - '
#: doc/guide-conditions.md:131
msgid "Caller has flexibility in handling or propagating errors."
msgstr ""

#. type: Bullet: '  - '
#: doc/guide-conditions.md:131
msgid ""
"Caller is forced to acknowledge existence of possible-error before using "
"value."
msgstr ""

#. type: Plain text
#: doc/guide-conditions.md:133
msgid "However, it has serious disadvantages too:"
msgstr ""

#. type: Bullet: '  - '
#: doc/guide-conditions.md:141
msgid ""
"Verbose, requires matching results or calling `Option::unwrap` everywhere."
msgstr ""

#. type: Bullet: '  - '
#: doc/guide-conditions.md:141
msgid ""
"Infects caller: if caller doesn't know how to handle the error, must "
"propagate (or force)."
msgstr ""

#. type: Plain text
#: doc/guide-conditions.md:141
#, no-wrap
msgid ""
"  - Temptation to do just that: force the `Some(T)` case by blindly calling `unwrap`,\n"
"    which hides the error from the API without providing any way to make the program robust against the error.\n"
"  - Collapses all errors into one:\n"
"    - Caller can't handle different errors differently.\n"
"    - Caller can't even report a very precise error message\n"
msgstr ""

#. type: Plain text
#: doc/guide-conditions.md:146
msgid ""
"Note that in order to keep the example code reasonably compact, several "
"unwanted cases are silently ignored: lines that do not contain two fields, "
"as well as fields that do not parse as ints.  To propagate these cases to "
"the caller using `Option` would require even more verbose code."
msgstr ""

#. type: Plain text
#: doc/guide-conditions.md:148
msgid "# Results"
msgstr ""

#. type: Plain text
#: doc/guide-conditions.md:158
msgid ""
"Before getting into _trapping_ the error, we will look at a slight "
"refinement on the `Option` type above.  This second mechanism for indicating "
"an error is called a `Result`.  The type `std::result::Result<T,E>` is "
"another simple `enum` type with two forms, `Ok(T)` and `Err(E)`.  The "
"`Result` type is not substantially different from the `Option` type in terms "
"of its ergonomics.  Its main advantage is that the error constructor "
"`Err(E)` can convey _more detail_ about the error.  For example, the "
"`from_str` API could be reformed to return a `Result` carrying an "
"informative description of a parse error, like this:"
msgstr ""

#. type: Plain text
#: doc/guide-conditions.md:165
#, no-wrap
msgid ""
"~~~~ {.ignore}\n"
"enum IntParseErr {\n"
"     EmptyInput,\n"
"     Overflow,\n"
"     BadChar(char)\n"
"}\n"
msgstr ""

#. type: Plain text
#: doc/guide-conditions.md:170
#, no-wrap
msgid ""
"fn from_str(&str) -> Result<int,IntParseErr> {\n"
"  // ...\n"
"}\n"
"~~~~\n"
msgstr ""

#. type: Plain text
#: doc/guide-conditions.md:177
msgid ""
"This would give the caller more information for both handling and reporting "
"the error, but would otherwise retain the verbosity problems of using "
"`Option`.  In particular, it would still be necessary for the caller to "
"return a further `Result` to _its_ caller if it did not want to handle the "
"error.  Manually propagating result values this way can be attractive in "
"certain circumstances &mdash; for example when processing must halt on the "
"very first error, or backtrack &mdash; but as we will see later, many cases "
"have simpler options available."
msgstr ""

#. type: Plain text
#: doc/guide-conditions.md:179
msgid "# Failure"
msgstr ""

#. type: Plain text
#: doc/guide-conditions.md:184
msgid ""
"The third and arguably easiest mechanism for handling errors is called "
"\"failure\".  In fact it was hinted at earlier by suggesting that one can "
"choose to propagate `Option` or `Result` types _or \"force\" them_.  "
"\"Forcing\" them, in this case, means calling a method like `Option<T>::"
"unwrap`, which contains the following code:"
msgstr ""

#. type: Plain text
#: doc/guide-conditions.md:193
#, no-wrap
msgid ""
"~~~~ {.ignore}\n"
"pub fn unwrap(self) -> T {\n"
"    match self {\n"
"      Some(x) => return x,\n"
"      None => fail!(\"option::unwrap `None`\")\n"
"    }\n"
"}\n"
"~~~~\n"
msgstr ""

#. type: Plain text
#: doc/guide-conditions.md:195
msgid ""
"That is, it returns `T` when `self` is `Some(T)`, and _fails_ when `self` is "
"`None`."
msgstr ""

#. type: Plain text
#: doc/guide-conditions.md:205
msgid ""
"Every Rust task can _fail_, either indirectly due to a kill signal or other "
"asynchronous event, or directly by failing an `assert!` or calling the `fail!"
"` macro.  Failure is an _unrecoverable event_ at the task level: it causes "
"the task to halt normal execution and unwind its control stack, freeing all "
"task-local resources (the local heap as well as any task-owned values from "
"the global heap)  and running destructors (the `drop` method of the `Drop` "
"trait)  as frames are unwound and heap values destroyed.  A failing task is "
"not permitted to \"catch\" the unwinding during failure and recover, it is "
"only allowed to clean up and exit."
msgstr ""

#. type: Plain text
#: doc/guide-conditions.md:207
msgid "Failure has advantages:"
msgstr ""

#. type: Bullet: '  - '
#: doc/guide-conditions.md:213
msgid ""
"Simple and non-verbose. Suitable for programs that can't reasonably continue "
"past an error anyways."
msgstr ""

#. type: Bullet: '  - '
#: doc/guide-conditions.md:213
msgid ""
"_All_ errors (except memory-safety errors) can be uniformly trapped in a "
"supervisory task outside the failing task.  For a large program to be robust "
"against a variety of errors, often some form of task-level partitioning to "
"contain pervasive errors (arithmetic overflow, division by zero, logic bugs) "
"is necessary anyways."
msgstr ""

#. type: Plain text
#: doc/guide-conditions.md:215
msgid "As well as obvious disadvantages:"
msgstr ""

#. type: Bullet: '  - '
#: doc/guide-conditions.md:217
msgid "A blunt instrument, terminates the containing task entirely."
msgstr ""

#. type: Plain text
#: doc/guide-conditions.md:221
msgid ""
"Recall that in the first two approaches to error handling, the example "
"program was only handling success cases, and ignoring error cases.  That is, "
"if the input is changed to contain a malformed line:"
msgstr ""

#. type: Plain text
#: doc/guide-conditions.md:230
msgid "~~~~ {.notrust} $ cat bad.txt 1 2 34 56 ostrich 789 123 45 67 ~~~~"
msgstr ""

#. type: Plain text
#: doc/guide-conditions.md:232
msgid "Then the program would give the same output as if there was no error:"
msgstr ""

#. type: Plain text
#: doc/guide-conditions.md:240 doc/guide-conditions.md:574
msgid ""
"~~~~ {.notrust} $ ./example bad.txt 0001, 0002 0034, 0056 0789, 0123 0045, "
"0067 ~~~~"
msgstr ""

#. type: Plain text
#: doc/guide-conditions.md:244
msgid ""
"If the example is rewritten to use failure, these error cases can be "
"trapped.  In this rewriting, failures are trapped by placing the I/O logic "
"in a sub-task, and trapping its exit status using `task::try`:"
msgstr ""

#. type: Plain text
#: doc/guide-conditions.md:264
#, no-wrap
msgid ""
"~~~~\n"
"# #[allow(unused_imports)];\n"
"# extern mod extra;\n"
"use std::io::buffered::BufferedReader;\n"
"use std::io::File;\n"
"use std::task;\n"
"# mod BufferedReader {\n"
"#     use std::io::File;\n"
"#     use std::io::mem::MemReader;\n"
"#     use std::io::buffered::BufferedReader;\n"
"#     static s : &'static [u8] = bytes!(\"1 2\\n\\\n"
"#                                        34 56\\n\\\n"
"#                                        789 123\\n\\\n"
"#                                        45 67\\n\\\n"
"#                                        \");\n"
"#     pub fn new(_inner: Option<File>) -> BufferedReader<MemReader> {\n"
"#           BufferedReader::new(MemReader::new(s.to_owned()))\n"
"#     }\n"
"# }\n"
msgstr ""

#. type: Plain text
#: doc/guide-conditions.md:266
msgid "fn main() {"
msgstr ""

#. type: Plain text
#: doc/guide-conditions.md:269
#, no-wrap
msgid ""
"    // Isolate failure within a subtask.\n"
"    let result = do task::try {\n"
msgstr ""

#. type: Plain text
#: doc/guide-conditions.md:275 doc/guide-conditions.md:529
#: doc/guide-conditions.md:624
#, no-wrap
msgid ""
"        // The protected logic.\n"
"        let pairs = read_int_pairs();\n"
"        for &(a,b) in pairs.iter() {\n"
"            println!(\"{:4.4d}, {:4.4d}\", a, b);\n"
"        }\n"
msgstr ""

#. type: Plain text
#: doc/guide-conditions.md:281
#, no-wrap
msgid ""
"    };\n"
"    if result.is_err() {\n"
"            println(\"parsing failed\");\n"
"    }\n"
"}\n"
msgstr ""

#. type: Plain text
#: doc/guide-conditions.md:286 doc/guide-conditions.md:385
#: doc/guide-conditions.md:460 doc/guide-conditions.md:537
#: doc/guide-conditions.md:632 doc/guide-conditions.md:771
#, no-wrap
msgid ""
"fn read_int_pairs() -> ~[(int,int)] {\n"
"    let mut pairs = ~[];\n"
"#    let _g = std::io::ignore_io_error();\n"
"    let path = Path::new(&\"foo.txt\");\n"
msgstr ""

#. type: Plain text
#: doc/guide-conditions.md:292 doc/guide-conditions.md:543
#: doc/guide-conditions.md:638
#, no-wrap
msgid ""
"    let mut reader = BufferedReader::new(File::open(&path));\n"
"    for line in reader.lines() {\n"
"        match line.words().to_owned_vec() {\n"
"            [a, b] => pairs.push((from_str::<int>(a).unwrap(),\n"
"                                  from_str::<int>(b).unwrap())),\n"
msgstr ""

#. type: Plain text
#: doc/guide-conditions.md:300
#, no-wrap
msgid ""
"            // Explicitly fail on malformed lines.\n"
"            _ => fail!()\n"
"        }\n"
"    }\n"
"    pairs\n"
"}\n"
"~~~~\n"
msgstr ""

#. type: Plain text
#: doc/guide-conditions.md:302
msgid ""
"With these changes in place, running the program on malformed input gives a "
"different answer:"
msgstr ""

#. type: Plain text
#: doc/guide-conditions.md:308
msgid ""
"~~~~ {.notrust} $ ./example bad.txt rust: task failed at 'explicit "
"failure', ./example.rs:44 parsing failed ~~~~"
msgstr ""

#. type: Plain text
#: doc/guide-conditions.md:316
msgid ""
"Note that while failure unwinds the sub-task performing I/O in "
"`read_int_pairs`, control returns to `main` and can easily continue "
"uninterrupted.  In this case, control simply prints out `parsing failed` and "
"then exits `main` (successfully).  Failure of a (sub-)task is analogous to "
"calling `exit(1)` or `abort()` in a unix C program: all the state of a sub-"
"task is cleanly discarded on exit, and a supervisor task can take "
"appropriate action without worrying about its own state having been "
"corrupted."
msgstr ""

#. type: Plain text
#: doc/guide-conditions.md:318
#, fuzzy
#| msgid "## Conditionals"
msgid "# Conditions"
msgstr "## 条件式"

#. type: Plain text
#: doc/guide-conditions.md:324
msgid ""
"The final mechanism for handling errors is called a \"condition\".  "
"Conditions are less blunt than failure, and less cumbersome than the "
"`Option` or `Result` types; indeed they are designed to strike just the "
"right balance between the two.  Conditions require some care to use "
"effectively, but give maximum flexibility with minimum verbosity.  While "
"conditions use exception-like terminology (\"trap\", \"raise\") they are "
"significantly different:"
msgstr ""

#. type: Bullet: '  - '
#: doc/guide-conditions.md:328
msgid ""
"Like exceptions and failure, conditions separate the site at which the error "
"is raised from the site where it is trapped."
msgstr ""

#. type: Bullet: '  - '
#: doc/guide-conditions.md:328
msgid ""
"Unlike exceptions and unlike failure, when a condition is raised and "
"trapped, _no unwinding occurs_."
msgstr ""

#. type: Bullet: '  - '
#: doc/guide-conditions.md:328
msgid ""
"A successfully trapped condition causes execution to continue _at the site "
"of the error_, as though no error occurred."
msgstr ""

#. type: Plain text
#: doc/guide-conditions.md:332
msgid ""
"Conditions are declared with the `condition!` macro.  Each condition has a "
"name, an input type and an output type, much like a function.  In fact, "
"conditions are implemented as dynamically-scoped functions held in task "
"local storage."
msgstr ""

#. type: Plain text
#: doc/guide-conditions.md:338
msgid ""
"The `condition!` macro declares a module with the name of the condition; the "
"module contains a single static value called `cond`, of type `std::"
"condition::Condition`.  The `cond` value within the module is the rendezvous "
"point between the site of error and the site that handles the error.  It has "
"two methods of interest: `raise` and `trap`."
msgstr ""

#. type: Plain text
#: doc/guide-conditions.md:346
msgid ""
"The `raise` method maps a value of the condition's input type to its output "
"type.  The input type should therefore convey all relevant information to "
"the condition handler.  The output type should convey all relevant "
"information _for continuing execution at the site of error_.  When the error "
"site raises a condition handler, the `Condition::raise` method searches for "
"the innermost installed task-local condition _handler_, and if any such "
"handler is found, calls it with the provided input value.  If no handler is "
"found, `Condition::raise` will fail the task with an appropriate error "
"message."
msgstr ""

#. type: Plain text
#: doc/guide-conditions.md:349
msgid ""
"Rewriting the example to use a condition in place of ignoring malformed "
"lines makes it slightly longer, but similarly clear as the version that used "
"`fail!` in the logic where the error occurs:"
msgstr ""

#. type: Plain text
#: doc/guide-conditions.md:373
#, no-wrap
msgid ""
"// Introduce a new condition.\n"
"condition! {\n"
"    pub malformed_line : ~str -> (int,int);\n"
"}\n"
msgstr ""

#. type: Plain text
#: doc/guide-conditions.md:399
#, no-wrap
msgid ""
"    let mut reader = BufferedReader::new(File::open(&path));\n"
"    for line in reader.lines() {\n"
"        match line.words().to_owned_vec() {\n"
"            [a, b] => pairs.push((from_str::<int>(a).unwrap(),\n"
"                                  from_str::<int>(b).unwrap())),\n"
"            // On malformed lines, call the condition handler and\n"
"            // push whatever the condition handler returns.\n"
"            _ => pairs.push(malformed_line::cond.raise(line.clone()))\n"
"        }\n"
"    }\n"
"    pairs\n"
"}\n"
"~~~~\n"
msgstr ""

#. type: Plain text
#: doc/guide-conditions.md:402
msgid ""
"When this is run on malformed input, it still fails, but with a slightly "
"different failure message than before:"
msgstr ""

#. type: Plain text
#: doc/guide-conditions.md:407
msgid ""
"~~~~ {.notrust} $ ./example bad.txt rust: task failed at 'Unhandled "
"condition: malformed_line: ~\"ostrich\"', .../libstd/condition.rs:43 ~~~~"
msgstr ""

#. type: Plain text
#: doc/guide-conditions.md:413
msgid ""
"While this superficially resembles the trapped `fail!` call before, it is "
"only because the example did not install a handler for the condition.  The "
"different failure message is indicating, among other things, that the "
"condition-handling system is being invoked and failing only due to the "
"absence of a _handler_ that traps the condition."
msgstr ""

#. type: Plain text
#: doc/guide-conditions.md:415
msgid "# Trapping a condition"
msgstr ""

#. type: Plain text
#: doc/guide-conditions.md:419
msgid ""
"To trap a condition, use `Condition::trap` in some caller of the site that "
"calls `Condition::raise`.  For example, this version of the program traps "
"the `malformed_line` condition and replaces bad input lines with the pair "
"`(-1,-1)`:"
msgstr ""

#. type: Plain text
#: doc/guide-conditions.md:442
#, no-wrap
msgid ""
"condition! {\n"
"    pub malformed_line : ~str -> (int,int);\n"
"}\n"
msgstr ""

#. type: Plain text
#: doc/guide-conditions.md:446
#, no-wrap
msgid ""
"fn main() {\n"
"    // Trap the condition:\n"
"    malformed_line::cond.trap(|_| (-1,-1)).inside(|| {\n"
msgstr ""

#. type: Plain text
#: doc/guide-conditions.md:452
#, no-wrap
msgid ""
"        // The protected logic.\n"
"        let pairs = read_int_pairs();\n"
"        for &(a,b) in pairs.iter() {\n"
"                println!(\"{:4.4d}, {:4.4d}\", a, b);\n"
"        }\n"
msgstr ""

#. type: Plain text
#: doc/guide-conditions.md:455 doc/guide-conditions.md:532
#: doc/guide-conditions.md:627
#, no-wrap
msgid ""
"    })\n"
"}\n"
msgstr ""

#. type: Plain text
#: doc/guide-conditions.md:472
#, no-wrap
msgid ""
"    let mut reader = BufferedReader::new(File::open(&path));\n"
"    for line in reader.lines() {\n"
"        match line.words().to_owned_vec() {\n"
"            [a, b] => pairs.push((from_str::<int>(a).unwrap(),\n"
"                                  from_str::<int>(b).unwrap())),\n"
"            _ => pairs.push(malformed_line::cond.raise(line.clone()))\n"
"        }\n"
"    }\n"
"    pairs\n"
"}\n"
"~~~~\n"
msgstr ""

#. type: Plain text
#: doc/guide-conditions.md:477
msgid ""
"Note that the remainder of the program is _unchanged_ with this trap in "
"place; only the caller that installs the trap changed.  Yet when the "
"condition-trapping variant runs on the malformed input, it continues "
"execution past the malformed line, substituting the handler's return value."
msgstr ""

#. type: Plain text
#: doc/guide-conditions.md:486
msgid ""
"~~~~ {.notrust} $ ./example bad.txt 0001, 0002 0034, 0056 -0001, -0001 0789, "
"0123 0045, 0067 ~~~~"
msgstr ""

#. type: Plain text
#: doc/guide-conditions.md:488
msgid "# Refining a condition"
msgstr ""

#. type: Plain text
#: doc/guide-conditions.md:495
msgid ""
"As you work with a condition, you may find that the original set of options "
"you present for recovery is insufficient.  This is no different than any "
"other issue of API design: a condition handler is an API for recovering from "
"the condition, and sometimes APIs need to be enriched.  In the example "
"program, the first form of the `malformed_line` API implicitly assumes that "
"recovery involves a substitute value.  This assumption may not be correct; "
"some callers may wish to skip malformed lines, for example.  Changing the "
"condition's return type from `(int,int)` to `Option<(int,int)>` will suffice "
"to support this type of recovery:"
msgstr ""

#. type: Plain text
#: doc/guide-conditions.md:519
#, no-wrap
msgid ""
"// Modify the condition signature to return an Option.\n"
"condition! {\n"
"    pub malformed_line : ~str -> Option<(int,int)>;\n"
"}\n"
msgstr ""

#. type: Plain text
#: doc/guide-conditions.md:523
#, no-wrap
msgid ""
"fn main() {\n"
"    // Trap the condition and return `None`\n"
"    malformed_line::cond.trap(|_| None).inside(|| {\n"
msgstr ""

#. type: Plain text
#: doc/guide-conditions.md:558
#, no-wrap
msgid ""
"            // On malformed lines, call the condition handler and\n"
"            // either ignore the line (if the handler returns `None`)\n"
"            // or push any `Some(pair)` value returned instead.\n"
"            _ => {\n"
"                match malformed_line::cond.raise(line.clone()) {\n"
"                    Some(pair) => pairs.push(pair),\n"
"                    None => ()\n"
"                }\n"
"            }\n"
"        }\n"
"    }\n"
"    pairs\n"
"}\n"
"~~~~\n"
msgstr ""

#. type: Plain text
#: doc/guide-conditions.md:566
msgid ""
"Again, note that the remainder of the program is _unchanged_, in particular "
"the signature of `read_int_pairs` is unchanged, even though the innermost "
"part of its reading-loop has a new way of handling a malformed line.  When "
"the example is run with the `None` trap in place, the line is ignored as it "
"was in the first example, but the choice of whether to ignore or use a "
"substitute value has been moved to some caller, possibly a distant caller."
msgstr ""

#. type: Plain text
#: doc/guide-conditions.md:576
msgid "# Further refining a condition"
msgstr ""

#. type: Plain text
#: doc/guide-conditions.md:581
msgid ""
"Like with any API, the process of refining argument and return types of a "
"condition will continue, until all relevant combinations encountered in "
"practice are encoded.  In the example, suppose a third possible recovery "
"form arose: reusing the previous value read.  This can be encoded in the "
"handler API by introducing a helper type: `enum MalformedLineFix`."
msgstr ""

#. type: Plain text
#: doc/guide-conditions.md:607
#, no-wrap
msgid ""
"// Introduce a new enum to convey condition-handling strategy to error site.\n"
"pub enum MalformedLineFix {\n"
"     UsePair(int,int),\n"
"     IgnoreLine,\n"
"     UsePreviousLine\n"
"}\n"
msgstr ""

#. type: Plain text
#: doc/guide-conditions.md:614
#, no-wrap
msgid ""
"// Modify the condition signature to return the new enum.\n"
"// Note: a condition introduces a new module, so the enum must be\n"
"// named with the `super::` prefix to access it.\n"
"condition! {\n"
"    pub malformed_line : ~str -> super::MalformedLineFix;\n"
"}\n"
msgstr ""

#. type: Plain text
#: doc/guide-conditions.md:618
#, no-wrap
msgid ""
"fn main() {\n"
"    // Trap the condition and return `UsePreviousLine`\n"
"    malformed_line::cond.trap(|_| UsePreviousLine).inside(|| {\n"
msgstr ""

#. type: Plain text
#: doc/guide-conditions.md:656
#, no-wrap
msgid ""
"            // On malformed lines, call the condition handler and\n"
"            // take action appropriate to the enum value returned.\n"
"            _ => {\n"
"                match malformed_line::cond.raise(line.clone()) {\n"
"                    UsePair(a,b) => pairs.push((a,b)),\n"
"                    IgnoreLine => (),\n"
"                    UsePreviousLine => {\n"
"                        let prev = pairs[pairs.len() - 1];\n"
"                        pairs.push(prev)\n"
"                    }\n"
"                }\n"
"            }\n"
"        }\n"
"    }\n"
"    pairs\n"
"}\n"
"~~~~\n"
msgstr ""

#. type: Plain text
#: doc/guide-conditions.md:659
msgid ""
"Running the example with `UsePreviousLine` as the fix code returned from the "
"handler gives the expected result:"
msgstr ""

#. type: Plain text
#: doc/guide-conditions.md:668
msgid ""
"~~~~ {.notrust} $ ./example bad.txt 0001, 0002 0034, 0056 0034, 0056 0789, "
"0123 0045, 0067 ~~~~"
msgstr ""

#. type: Plain text
#: doc/guide-conditions.md:674
msgid ""
"At this point the example has a rich variety of recovery options, none of "
"which is visible to casual users of the `read_int_pairs` function.  This is "
"intentional: part of the purpose of using a condition is to free "
"intermediate callers from the burden of having to write repetitive error-"
"propagation logic, and/or having to change function call and return types as "
"error-handling strategies are refined."
msgstr ""

#. type: Plain text
#: doc/guide-conditions.md:676
msgid "# Multiple conditions, intermediate callers"
msgstr ""

#. type: Plain text
#: doc/guide-conditions.md:682
msgid ""
"So far the function trapping the condition and the function raising it have "
"been immediately adjacent in the call stack.  That is, the caller traps and "
"its immediate callee raises.  In most programs, the function that traps may "
"be separated by very many function calls from the function that raises.  "
"Again, this is part of the point of using conditions: to support that "
"separation without having to thread multiple error values and recovery "
"strategies all the way through the program's main logic."
msgstr ""

#. type: Plain text
#: doc/guide-conditions.md:686
msgid ""
"Careful readers will notice that there is a remaining failure mode in the "
"example program: the call to `.unwrap()` when parsing each integer.  For "
"example, when presented with a file that has the correct number of fields on "
"a line, but a non-numeric value in one of them, such as this:"
msgstr ""

#. type: Plain text
#: doc/guide-conditions.md:695
msgid "~~~~ {.notrust} $ cat bad.txt 1 2 34 56 7 marmot 789 123 45 67 ~~~~"
msgstr ""

#. type: Plain text
#: doc/guide-conditions.md:698
msgid "Then the program fails once more:"
msgstr ""

#. type: Plain text
#: doc/guide-conditions.md:703
msgid ""
"~~~~ {.notrust} $ ./example bad.txt task <unnamed> failed at 'called "
"`Option::unwrap()` on a `None` value', .../libstd/option.rs:314 ~~~~"
msgstr ""

#. type: Plain text
#: doc/guide-conditions.md:706
msgid ""
"To make the program robust &mdash; or at least flexible &mdash; in the face "
"of this potential failure, a second condition and a helper function will "
"suffice:"
msgstr ""

#. type: Plain text
#: doc/guide-conditions.md:731
#, no-wrap
msgid ""
"pub enum MalformedLineFix {\n"
"     UsePair(int,int),\n"
"     IgnoreLine,\n"
"     UsePreviousLine\n"
"}\n"
msgstr ""

#. type: Plain text
#: doc/guide-conditions.md:735
#, no-wrap
msgid ""
"condition! {\n"
"    pub malformed_line : ~str -> ::MalformedLineFix;\n"
"}\n"
msgstr ""

#. type: Plain text
#: doc/guide-conditions.md:740
#, no-wrap
msgid ""
"// Introduce a second condition.\n"
"condition! {\n"
"    pub malformed_int : ~str -> int;\n"
"}\n"
msgstr ""

#. type: Plain text
#: doc/guide-conditions.md:744
#, no-wrap
msgid ""
"fn main() {\n"
"    // Trap the `malformed_int` condition and return -1\n"
"    malformed_int::cond.trap(|_| -1).inside(|| {\n"
msgstr ""

#. type: Plain text
#: doc/guide-conditions.md:747
#, no-wrap
msgid ""
"        // Trap the `malformed_line` condition and return `UsePreviousLine`\n"
"        malformed_line::cond.trap(|_| UsePreviousLine).inside(|| {\n"
msgstr ""

#. type: Plain text
#: doc/guide-conditions.md:753
#, no-wrap
msgid ""
"            // The protected logic.\n"
"            let pairs = read_int_pairs();\n"
"            for &(a,b) in pairs.iter() {\n"
"                println!(\"{:4.4d}, {:4.4d}\", a, b);\n"
"            }\n"
msgstr ""

#. type: Plain text
#: doc/guide-conditions.md:757
#, no-wrap
msgid ""
"        })\n"
"    })\n"
"}\n"
msgstr ""

#. type: Plain text
#: doc/guide-conditions.md:766
#, no-wrap
msgid ""
"// Parse an int; if parsing fails, call the condition handler and\n"
"// return whatever it returns.\n"
"fn parse_int(x: &str) -> int {\n"
"    match from_str::<int>(x) {\n"
"        Some(v) => v,\n"
"        None => malformed_int::cond.raise(x.to_owned())\n"
"    }\n"
"}\n"
msgstr ""

#. type: Plain text
#: doc/guide-conditions.md:778
#, no-wrap
msgid ""
"    let mut reader = BufferedReader::new(File::open(&path));\n"
"    for line in reader.lines() {\n"
"        match line.words().to_owned_vec() {\n"
"            // Delegate parsing ints to helper function that will\n"
"            // handle parse errors by calling `malformed_int`.\n"
"            [a, b] => pairs.push((parse_int(a), parse_int(b))),\n"
msgstr ""

#. type: Plain text
#: doc/guide-conditions.md:794
#, no-wrap
msgid ""
"            _ => {\n"
"                match malformed_line::cond.raise(line.clone()) {\n"
"                    UsePair(a,b) => pairs.push((a,b)),\n"
"                    IgnoreLine => (),\n"
"                    UsePreviousLine => {\n"
"                        let prev = pairs[pairs.len() - 1];\n"
"                        pairs.push(prev)\n"
"                    }\n"
"                }\n"
"            }\n"
"        }\n"
"    }\n"
"    pairs\n"
"}\n"
"~~~~\n"
msgstr ""

#. type: Plain text
#: doc/guide-conditions.md:798
msgid ""
"Again, note that `read_int_pairs` has not changed signature, nor has any of "
"the machinery for trapping or raising `malformed_line`, but now the program "
"can handle the \"right number of fields, non-integral field\" form of bad "
"input:"
msgstr ""

#. type: Plain text
#: doc/guide-conditions.md:807
msgid ""
"~~~~ {.notrust} $ ./example bad.txt 0001, 0002 0034, 0056 0007, -0001 0789, "
"0123 0045, 0067 ~~~~"
msgstr ""

#. type: Plain text
#: doc/guide-conditions.md:809
msgid ""
"There are three other things to note in this variant of the example program:"
msgstr ""

#. type: Bullet: '  - '
#: doc/guide-conditions.md:812
msgid ""
"It traps multiple conditions simultaneously, nesting the protected logic of "
"one `trap` call inside the other."
msgstr ""

#. type: Bullet: '  - '
#: doc/guide-conditions.md:817
msgid ""
"There is a function in between the `trap` site and `raise` site for the "
"`malformed_int` condition.  There could be any number of calls between them: "
"so long as the `raise` occurs within a callee (of any depth) of the logic "
"protected by the `trap` call, it will invoke the handler."
msgstr ""

#. type: Bullet: '  - '
#: doc/guide-conditions.md:822
msgid ""
"This variant insulates callers from a design choice in the library: the "
"`from_str` function was designed to return an `Option<int>`, but this "
"program insulates callers from that choice, routing all `None` values that "
"arise from parsing integers in this file into the condition."
msgstr ""

#. type: Plain text
#: doc/guide-conditions.md:825
msgid "# When to use which technique"
msgstr ""

#. type: Plain text
#: doc/guide-conditions.md:828
msgid ""
"This guide explored several techniques for handling errors.  Each is "
"appropriate to different circumstances:"
msgstr ""

#. type: Bullet: '  - '
#: doc/guide-conditions.md:834
msgid ""
"If an error may be extremely frequent, expected, and very likely dealt with "
"by an immediate caller, then returning an `Option` or `Result` type is best. "
"These types force the caller to handle the error, and incur the lowest speed "
"overhead, usually only returning one extra word to tag the return value.  "
"Between `Option` and `Result`: use an `Option` when there is only one kind "
"of error, otherwise make an `enum FooErr` to represent the possible error "
"codes and use `Result<T,FooErr>`."
msgstr ""

#. type: Bullet: '  - '
#: doc/guide-conditions.md:839
msgid ""
"If an error can reasonably be handled at the site it occurs by one of a few "
"strategies &mdash; possibly including failure &mdash; and it is not clear "
"which strategy a caller would want to use, a condition is best.  For many "
"errors, the only reasonable \"non-stop\" recovery strategies are to retry "
"some number of times, create or substitute an empty or sentinel value, "
"ignore the error, or fail."
msgstr ""

#. type: Bullet: '  - '
#: doc/guide-conditions.md:843
msgid ""
"If an error cannot reasonably be handled at the site it occurs, and the only "
"reasonable response is to abandon a large set of operations in progress, "
"then directly failing is best."
msgstr ""

#. type: Plain text
#: doc/guide-conditions.md:847
msgid ""
"Note that an unhandled condition will cause failure (along with a more-"
"informative-than-usual message), so if there is any possibility that a "
"caller might wish to \"ignore and keep going\", it is usually harmless to "
"use a condition in place of a direct call to `fail!()`."
msgstr ""

#. type: Plain text
#: doc/guide-conditions.md:858
msgid ""
"[^why-no-exceptions]: Exceptions in languages like C++ and Java permit "
"unwinding, like Rust's failure system, but with the option to halt unwinding "
"partway through the process and continue execution.  This behavior "
"unfortunately means that the _heap_ may be left in an inconsistent but "
"accessible state, if an exception is thrown part way through the process of "
"initializing or modifying memory.  To compensate for this risk, correct C++ "
"and Java code must program in an extremely elaborate and difficult "
"\"exception-safe\" style &mdash; effectively transactional style against "
"heap structures &mdash; or else risk introducing silent and very difficult-"
"to-debug errors due to control resuming in a corrupted heap after a caught "
"exception.  These errors are frequently memory-safety errors, which Rust "
"strives to eliminate, and so Rust unwinding is unrecoverable within a single "
"task: once unwinding starts, the entire local heap of a task is destroyed "
"and the task is terminated."
msgstr ""
