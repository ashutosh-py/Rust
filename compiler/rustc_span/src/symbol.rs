//! An "interner" is a data structure that associates values with usize tags and
//! allows bidirectional lookup; i.e., given a value, one can easily find the
//! type, and vice versa.

use rustc_arena::DroplessArena;
use rustc_data_structures::fx::FxHashMap;
use rustc_data_structures::stable_hasher::{HashStable, StableHasher, ToStableHashKey};
use rustc_macros::HashStable_Generic;
use rustc_serialize::{Decodable, Decoder, Encodable, Encoder};

use std::cmp::{Ord, PartialEq, PartialOrd};
use std::fmt;
use std::hash::{Hash, Hasher};
use std::str;

use crate::{Edition, Span, DUMMY_SP, SESSION_GLOBALS};

#[cfg(test)]
mod tests;

// The proc macro code for this is in `src/librustc_macros/src/symbols.rs`.
symbols! {
    // After modifying this list adjust `is_special`, `is_used_keyword`/`is_unused_keyword`,
    // this should be rarely necessary though if the keywords are kept in alphabetic order.
    Keywords {
        // Special reserved identifiers used internally for elided lifetimes,
        // unnamed method parameters, crate root module, error recovery etc.
        Empty:              "",
        PathRoot:           "{{root}}",
        DollarCrate:        "$crate",
        Underscore:         "_",

        // Keywords that are used in stable Rust.
        As:                 "as",
        Break:              "break",
        Const:              "const",
        Continue:           "continue",
        Crate:              "crate",
        Else:               "else",
        Enum:               "enum",
        Extern:             "extern",
        False:              "false",
        Fn:                 "fn",
        For:                "for",
        If:                 "if",
        Impl:               "impl",
        In:                 "in",
        Let:                "let",
        Loop:               "loop",
        Match:              "match",
        Mod:                "mod",
        Move:               "move",
        Mut:                "mut",
        Pub:                "pub",
        Ref:                "ref",
        Return:             "return",
        SelfLower:          "self",
        SelfUpper:          "Self",
        Static:             "static",
        Struct:             "struct",
        Super:              "super",
        Trait:              "trait",
        True:               "true",
        Type:               "type",
        Unsafe:             "unsafe",
        Use:                "use",
        Where:              "where",
        While:              "while",

        // Keywords that are used in unstable Rust or reserved for future use.
        Abstract:           "abstract",
        Become:             "become",
        Box:                "box",
        Do:                 "do",
        Final:              "final",
        Macro:              "macro",
        Override:           "override",
        Priv:               "priv",
        Typeof:             "typeof",
        Unsized:            "unsized",
        Virtual:            "virtual",
        Yield:              "yield",

        // Edition-specific keywords that are used in stable Rust.
        Async:              "async", // >= 2018 Edition only
        Await:              "await", // >= 2018 Edition only
        Dyn:                "dyn", // >= 2018 Edition only

        // Edition-specific keywords that are used in unstable Rust or reserved for future use.
        Try:                "try", // >= 2018 Edition only

        // Special lifetime names
        UnderscoreLifetime: "'_",
        StaticLifetime:     "'static",

        // Weak keywords, have special meaning only in specific contexts.
        Auto:               "auto",
        Catch:              "catch",
        Default:            "default",
        MacroRules:         "macro_rules",
        Raw:                "raw",
        Union:              "union",
    }

    // Pre-interned symbols that can be referred to with `rustc_span::sym::*`.
    //
    // The symbol is the stringified identifier unless otherwise specified, in
    // which case the name should mention the non-identifier punctuation.
    // E.g. `sym::proc_dash_macro` represents "proc-macro", and it shouldn't be
    // called `sym::proc_macro` because then it's easy to mistakenly think it
    // represents "proc_macro".
    //
    // As well as the symbols listed, there are symbols for the strings
    // "0", "1", ..., "9", which are accessible via `sym::integer`.
    //
    // The proc macro will abort if symbols are not in alphabetical order (as
    // defined by `impl Ord for str`) or if any symbols are duplicated. Vim
    // users can sort the list by selecting it and executing the command
    // `:'<,'>!LC_ALL=C sort`.
    //
    // There is currently no checking that all symbols are used; that would be
    // nice to have.
    Symbols {
        Alignment,
        Arc,
        Argument,
        ArgumentV1,
        Arguments,
        C,
        CString,
        Center,
        Clone,
        Copy,
        Count,
        Debug,
        Decodable,
        Decoder,
        Default,
        Encodable,
        Encoder,
        Eq,
        Equal,
        Err,
        Error,
        FormatSpec,
        Formatter,
        From,
        Future,
        FxHashMap,
        FxHashSet,
        GlobalAlloc,
        Hash,
        HashMap,
        HashSet,
        Hasher,
        Implied,
        Input,
        IntoIterator,
        Is,
        ItemContext,
        Iterator,
        Layout,
        Left,
        LintPass,
        None,
        Ok,
        Option,
        Ord,
        Ordering,
        Output,
        Param,
        PartialEq,
        PartialOrd,
        Pending,
        Pin,
        Poll,
        ProcMacro,
        ProcMacroHack,
        ProceduralMasqueradeDummyType,
        Range,
        RangeFrom,
        RangeFull,
        RangeInclusive,
        RangeTo,
        RangeToInclusive,
        Rc,
        Ready,
        Result,
        Return,
        Right,
        RustcDecodable,
        RustcEncodable,
        Send,
        Some,
        StructuralEq,
        StructuralPartialEq,
        Sync,
        Target,
        Try,
        Ty,
        TyCtxt,
        TyKind,
        Unknown,
        Vec,
        Yield,
        _DECLS,
        _Self,
        __D,
        __H,
        __S,
        __next,
        __try_var,
        _d,
        _e,
        _task_context,
        a32,
        aarch64_target_feature,
        abi,
        abi_amdgpu_kernel,
        abi_avr_interrupt,
        abi_efiapi,
        abi_msp430_interrupt,
        abi_ptx,
        abi_sysv64,
        abi_thiscall,
        abi_unadjusted,
        abi_vectorcall,
        abi_x86_interrupt,
        abort,
        aborts,
        add,
        add_assign,
        add_with_overflow,
        address,
        advanced_slice_patterns,
        adx_target_feature,
        alias,
        align,
        align_offset,
        alignstack,
        all,
        alloc,
        alloc_error_handler,
        alloc_layout,
        alloc_zeroed,
        allocator,
        allocator_internals,
        allow,
        allow_fail,
        allow_internal_unsafe,
        allow_internal_unstable,
        allow_internal_unstable_backcompat_hack,
        allowed,
        always,
        and,
        and_then,
        any,
        arbitrary_enum_discriminant,
        arbitrary_self_types,
        arith_offset,
        arm,
        arm_target_feature,
        array,
        arrays,
        as_ptr,
        as_str,
        asm,
        assert,
        assert_inhabited,
        assert_macro,
        assert_receiver_is_total_eq,
        assert_uninit_valid,
        assert_zero_valid,
        associated_consts,
        associated_type_bounds,
        associated_type_defaults,
        associated_types,
        assume,
        assume_init,
        async_await,
        async_closure,
        atomics,
        att_syntax,
        attr,
        attr_literals,
        attributes,
        augmented_assignments,
        auto_traits,
        automatically_derived,
        avx512_target_feature,
        await_macro,
        bang,
        begin_panic,
        bench,
        bin,
        bind_by_move_pattern_guards,
        bindings_after_at,
        bitand,
        bitand_assign,
        bitor,
        bitor_assign,
        bitreverse,
        bitxor,
        bitxor_assign,
        block,
        bool,
        borrowck_graphviz_format,
        borrowck_graphviz_postflow,
        borrowck_graphviz_preflow,
        box_free,
        box_patterns,
        box_syntax,
        braced_empty_structs,
        breakpoint,
        bridge,
        bswap,
        c_str,
        c_variadic,
        call,
        call_mut,
        call_once,
        caller_location,
        capture_disjoint_fields,
        cdylib,
        ceilf32,
        ceilf64,
        cfg,
        cfg_accessible,
        cfg_attr,
        cfg_attr_multi,
        cfg_doctest,
        cfg_panic,
        cfg_sanitize,
        cfg_target_feature,
        cfg_target_has_atomic,
        cfg_target_thread_local,
        cfg_target_vendor,
        cfg_version,
        char,
        client,
        clippy,
        clone,
        clone_closures,
        clone_from,
        closure,
        closure_to_fn_coercion,
        cmp,
        cmpxchg16b_target_feature,
        cmse_nonsecure_entry,
        coerce_unsized,
        cold,
        column,
        compile_error,
        compiler_builtins,
        concat,
        concat_idents,
        conservative_impl_trait,
        console,
        const_allocate,
        const_compare_raw_pointers,
        const_constructor,
        const_eval_limit,
        const_evaluatable_checked,
        const_extern_fn,
        const_fn,
        const_fn_floating_point_arithmetic,
        const_fn_fn_ptr_basics,
        const_fn_transmute,
        const_fn_union,
        const_generics,
        const_generics_defaults,
        const_if_match,
        const_impl_trait,
        const_in_array_repeat_expressions,
        const_indexing,
        const_let,
        const_loop,
        const_mut_refs,
        const_panic,
        const_precise_live_drops,
        const_ptr,
        const_raw_ptr_deref,
        const_raw_ptr_to_usize_cast,
        const_slice_ptr,
        const_trait_bound_opt_out,
        const_trait_impl,
        const_transmute,
        constant,
        constructor,
        contents,
        context,
        convert,
        copy,
        copy_closures,
        copy_nonoverlapping,
        copysignf32,
        copysignf64,
        core,
        core_intrinsics,
        core_panic_macro,
        cosf32,
        cosf64,
        crate_id,
        crate_in_paths,
        crate_local,
        crate_name,
        crate_type,
        crate_visibility_modifier,
        crt_dash_static: "crt-static",
        cstring_type,
        ctlz,
        ctlz_nonzero,
        ctpop,
        cttz,
        cttz_nonzero,
        custom_attribute,
        custom_derive,
        custom_inner_attributes,
        custom_test_frameworks,
        d,
        dead_code,
        dealloc,
        debug,
        debug_assert_macro,
        debug_assertions,
        debug_struct,
        debug_trait,
        debug_trait_builder,
        debug_tuple,
        decl_macro,
        declare_lint_pass,
        decode,
        default_alloc_error_handler,
        default_lib_allocator,
        default_type_parameter_fallback,
        default_type_params,
        delay_span_bug_from_inside_query,
        deny,
        deprecated,
        deref,
        deref_method,
        deref_mut,
        deref_target,
        derive,
        destructuring_assignment,
        diagnostic,
        direct,
        discriminant_kind,
        discriminant_type,
        discriminant_value,
        dispatch_from_dyn,
        div,
        div_assign,
        doc,
        doc_alias,
        doc_cfg,
        doc_keyword,
        doc_masked,
        doc_spotlight,
        doctest,
        document_private_items,
        dotdot_in_tuple_patterns,
        dotdoteq_in_patterns,
        dreg,
        dreg_low16,
        dreg_low8,
        drop,
        drop_in_place,
        drop_types_in_const,
        dropck_eyepatch,
        dropck_parametricity,
        dylib,
        dyn_trait,
        edition_macro_pats,
        eh_catch_typeinfo,
        eh_personality,
        emit_enum,
        emit_enum_variant,
        emit_enum_variant_arg,
        emit_struct,
        emit_struct_field,
        enable,
        enclosing_scope,
        encode,
        env,
        eq,
        ermsb_target_feature,
        err,
        exact_div,
        except,
        exchange_malloc,
        exclusive_range_pattern,
        exhaustive_integer_patterns,
        exhaustive_patterns,
        existential_type,
        exp2f32,
        exp2f64,
        expect,
        expected,
        expf32,
        expf64,
        export_name,
        expr,
        extended_key_value_attributes,
        extern_absolute_paths,
        extern_crate_item_prelude,
        extern_crate_self,
        extern_in_paths,
        extern_prelude,
        extern_types,
        external_doc,
        f,
        f16c_target_feature,
        f32,
        f32_runtime,
        f64,
        f64_runtime,
        fabsf32,
        fabsf64,
        fadd_fast,
        fdiv_fast,
        feature,
        ffi,
        ffi_const,
        ffi_pure,
        ffi_returns_twice,
        field,
        field_init_shorthand,
        file,
        fill,
        finish,
        flags,
        float_to_int_unchecked,
        floorf32,
        floorf64,
        fmaf32,
        fmaf64,
        fmt,
        fmt_internals,
        fmul_fast,
        fn_must_use,
        fn_mut,
        fn_once,
        fn_once_output,
        forbid,
        forget,
        format,
        format_args,
        format_args_capture,
        format_args_nl,
        freeze,
        freg,
        frem_fast,
        from,
        from_desugaring,
        from_error,
        from_generator,
        from_method,
        from_ok,
        from_size_align_unchecked,
        from_trait,
        from_usize,
        fsub_fast,
        fundamental,
        future,
        future_trait,
        ge,
        gen_future,
        gen_kill,
        generator,
        generator_state,
        generators,
        generic_associated_types,
        generic_param_attrs,
        get_context,
        global_allocator,
        global_asm,
        globs,
        gt,
        half_open_range_patterns,
        hash,
        hexagon_target_feature,
        hidden,
        homogeneous_aggregate,
        html_favicon_url,
        html_logo_url,
        html_no_source,
        html_playground_url,
        html_root_url,
        i,
        i128,
        i128_type,
        i16,
        i32,
        i64,
        i8,
        ident,
        if_let,
        if_let_guard,
        if_while_or_patterns,
        ignore,
        impl_header_lifetime_elision,
        impl_lint_pass,
        impl_macros,
        impl_trait_in_bindings,
        import_shadowing,
        in_band_lifetimes,
        include,
        include_bytes,
        include_str,
        inclusive_range_syntax,
        index,
        index_mut,
        infer_outlives_requirements,
        infer_static_outlives_requirements,
        inlateout,
        inline,
        inline_const,
        inout,
        instruction_set,
        intel,
        into_iter,
        into_result,
        intrinsics,
        irrefutable_let_patterns,
        isa_attribute,
        isize,
        issue,
        issue_5723_bootstrap,
        issue_tracker_base_url,
        item,
        item_like_imports,
        iter,
        keyword,
        kind,
        kreg,
        label,
        label_break_value,
        lang,
        lang_items,
        lateout,
        lazy_normalization_consts,
        le,
        let_chains,
        lhs,
        lib,
        libc,
        lifetime,
        likely,
        line,
        link,
        link_args,
        link_cfg,
        link_llvm_intrinsics,
        link_name,
        link_ordinal,
        link_section,
        linkage,
        lint_reasons,
        literal,
        llvm_asm,
        local,
        local_inner_macros,
        log10f32,
        log10f64,
        log2f32,
        log2f64,
        log_syntax,
        logf32,
        logf64,
        loop_break_value,
        lt,
        macro_at_most_once_rep,
        macro_escape,
        macro_export,
        macro_lifetime_matcher,
        macro_literal_matcher,
        macro_reexport,
        macro_use,
        macro_vis_matcher,
        macros_in_extern,
        main,
        managed_boxes,
        manually_drop,
        map,
        marker,
        marker_trait_attr,
        masked,
        match_beginning_vert,
        match_default_bindings,
        maxnumf32,
        maxnumf64,
        may_dangle,
        maybe_uninit,
        maybe_uninit_uninit,
        maybe_uninit_zeroed,
        mem_uninitialized,
        mem_zeroed,
        member_constraints,
        memory,
        message,
        meta,
        min_align_of,
        min_align_of_val,
        min_const_fn,
        min_const_generics,
        min_const_unsafe_fn,
        min_specialization,
        minnumf32,
        minnumf64,
        mips_target_feature,
        misc,
        module,
        module_path,
        more_struct_aliases,
        movbe_target_feature,
        move_ref_pattern,
        move_val_init,
        mul,
        mul_assign,
        mul_with_overflow,
        must_use,
        mut_ptr,
        mut_slice_ptr,
        naked,
        naked_functions,
        name,
        ne,
        nearbyintf32,
        nearbyintf64,
        needs_allocator,
        needs_drop,
        needs_panic_runtime,
        neg,
        negate_unsigned,
        negative_impls,
        never,
        never_type,
        never_type_fallback,
        new,
        new_unchecked,
        next,
        nll,
        no,
        no_builtins,
        no_core,
        no_crate_inject,
        no_debug,
        no_default_passes,
        no_implicit_prelude,
        no_inline,
        no_link,
        no_main,
        no_mangle,
        no_niche,
        no_sanitize,
        no_stack_check,
        no_start,
        no_std,
        nomem,
        non_ascii_idents,
        non_exhaustive,
        non_modrs_mods,
        none_error,
        nontemporal_store,
        nontrapping_dash_fptoint: "nontrapping-fptoint",
        noreturn,
        nostack,
        not,
        note,
        object_safe_for_dispatch,
        of,
        offset,
        omit_gdb_pretty_printer_section,
        on,
        on_unimplemented,
        oom,
        opaque,
        ops,
        opt_out_copy,
        optimize,
        optimize_attribute,
        optin_builtin_traits,
        option,
        option_env,
        option_type,
        options,
        or,
        or_patterns,
        other,
        out,
        overlapping_marker_traits,
        owned_box,
        packed,
        panic,
        panic_abort,
        panic_bounds_check,
        panic_handler,
        panic_impl,
        panic_implementation,
        panic_info,
        panic_location,
        panic_runtime,
        panic_str,
        panic_unwind,
        panicking,
        param_attrs,
        parent_trait,
        partial_cmp,
        partial_ord,
        passes,
        pat,
        pat2018,
        pat2021,
        path,
        pattern_parentheses,
        phantom_data,
        pin,
        pinned,
        platform_intrinsics,
        plugin,
        plugin_registrar,
        plugins,
        pointer,
        pointer_trait,
        pointer_trait_fmt,
        poll,
        position,
        post_dash_lto: "post-lto",
        powerpc_target_feature,
        powf32,
        powf64,
        powif32,
        powif64,
        pre_dash_lto: "pre-lto",
        precise_pointer_size_matching,
        precision,
        pref_align_of,
        prefetch_read_data,
        prefetch_read_instruction,
        prefetch_write_data,
        prefetch_write_instruction,
        prelude,
        prelude_import,
        preserves_flags,
        primitive,
        proc_dash_macro: "proc-macro",
        proc_macro,
        proc_macro_attribute,
        proc_macro_def_site,
        proc_macro_derive,
        proc_macro_expr,
        proc_macro_gen,
        proc_macro_hygiene,
        proc_macro_internals,
        proc_macro_mod,
        proc_macro_non_items,
        proc_macro_path_invoc,
        profiler_builtins,
        profiler_runtime,
        ptr_guaranteed_eq,
        ptr_guaranteed_ne,
        ptr_offset_from,
        pub_restricted,
        pure,
        pushpop_unsafe,
        qreg,
        qreg_low4,
        qreg_low8,
        quad_precision_float,
        question_mark,
        quote,
        range_inclusive_new,
        raw_dylib,
        raw_identifiers,
        raw_ref_op,
        re_rebalance_coherence,
        read_enum,
        read_enum_variant,
        read_enum_variant_arg,
        read_struct,
        read_struct_field,
        readonly,
        realloc,
        reason,
        receiver,
        recursion_limit,
        reexport_test_harness_main,
        reference,
        reflect,
        reg,
        reg16,
        reg32,
        reg64,
        reg_abcd,
        reg_byte,
        reg_thumb,
        register_attr,
        register_tool,
        relaxed_adts,
        rem,
        rem_assign,
        repr,
        repr128,
        repr_align,
        repr_align_enum,
        repr_no_niche,
        repr_packed,
        repr_simd,
        repr_transparent,
        result,
        result_type,
        rhs,
        rintf32,
        rintf64,
        riscv_target_feature,
        rlib,
        rotate_left,
        rotate_right,
        roundf32,
        roundf64,
        rt,
        rtm_target_feature,
        rust,
        rust_2015_preview,
        rust_2018_preview,
        rust_2021_preview,
        rust_begin_unwind,
        rust_eh_catch_typeinfo,
        rust_eh_personality,
        rust_eh_register_frames,
        rust_eh_unregister_frames,
        rust_oom,
        rustc,
        rustc_allocator,
        rustc_allocator_nounwind,
        rustc_allow_const_fn_unstable,
        rustc_args_required_const,
        rustc_attrs,
        rustc_builtin_macro,
        rustc_capture_analysis,
        rustc_clean,
        rustc_const_stable,
        rustc_const_unstable,
        rustc_conversion_suggestion,
        rustc_def_path,
        rustc_deprecated,
        rustc_diagnostic_item,
        rustc_diagnostic_macros,
        rustc_dirty,
        rustc_dummy,
        rustc_dump_env_program_clauses,
        rustc_dump_program_clauses,
        rustc_dump_user_substs,
        rustc_error,
        rustc_expected_cgu_reuse,
        rustc_if_this_changed,
        rustc_inherit_overflow_checks,
        rustc_layout,
        rustc_layout_scalar_valid_range_end,
        rustc_layout_scalar_valid_range_start,
        rustc_macro_transparency,
        rustc_mir,
        rustc_nonnull_optimization_guaranteed,
        rustc_object_lifetime_default,
        rustc_on_unimplemented,
        rustc_outlives,
        rustc_paren_sugar,
        rustc_partition_codegened,
        rustc_partition_reused,
        rustc_peek,
        rustc_peek_definite_init,
        rustc_peek_indirectly_mutable,
        rustc_peek_liveness,
        rustc_peek_maybe_init,
        rustc_peek_maybe_uninit,
        rustc_polymorphize_error,
        rustc_private,
        rustc_proc_macro_decls,
        rustc_promotable,
        rustc_regions,
        rustc_reservation_impl,
        rustc_serialize,
        rustc_specialization_trait,
        rustc_stable,
        rustc_std_internal_symbol,
        rustc_symbol_name,
        rustc_synthetic,
        rustc_test_marker,
        rustc_then_this_would_need,
        rustc_unsafe_specialization_marker,
        rustc_variance,
        rustfmt,
        rvalue_static_promotion,
        sanitize,
        sanitizer_runtime,
        saturating_add,
        saturating_sub,
        self_in_typedefs,
        self_struct_ctor,
        semitransparent,
        send_trait,
        shl,
        shl_assign,
        should_panic,
        shr,
        shr_assign,
        simd,
        simd_add,
        simd_and,
        simd_bitmask,
        simd_cast,
        simd_ceil,
        simd_div,
        simd_eq,
        simd_extract,
        simd_fabs,
        simd_fcos,
        simd_fexp,
        simd_fexp2,
        simd_ffi,
        simd_flog,
        simd_flog10,
        simd_flog2,
        simd_floor,
        simd_fma,
        simd_fmax,
        simd_fmin,
        simd_fpow,
        simd_fpowi,
        simd_fsin,
        simd_fsqrt,
        simd_gather,
        simd_ge,
        simd_gt,
        simd_insert,
        simd_le,
        simd_lt,
        simd_mul,
        simd_ne,
        simd_or,
        simd_reduce_add_ordered,
        simd_reduce_add_unordered,
        simd_reduce_all,
        simd_reduce_and,
        simd_reduce_any,
        simd_reduce_max,
        simd_reduce_max_nanless,
        simd_reduce_min,
        simd_reduce_min_nanless,
        simd_reduce_mul_ordered,
        simd_reduce_mul_unordered,
        simd_reduce_or,
        simd_reduce_xor,
        simd_rem,
        simd_saturating_add,
        simd_saturating_sub,
        simd_scatter,
        simd_select,
        simd_select_bitmask,
        simd_shl,
        simd_shr,
        simd_sub,
        simd_xor,
        since,
        sinf32,
        sinf64,
        size,
        size_of,
        size_of_val,
        sized,
        slice,
        slice_alloc,
        slice_patterns,
        slice_u8,
        slice_u8_alloc,
        slicing_syntax,
        soft,
        specialization,
        speed,
        spotlight,
        sqrtf32,
        sqrtf64,
        sreg,
        sreg_low16,
        sse4a_target_feature,
        stable,
        staged_api,
        start,
        state,
        static_in_const,
        static_nobundle,
        static_recursion,
        staticlib,
        std,
        std_inject,
        std_panic_macro,
        stmt,
        stmt_expr_attributes,
        stop_after_dataflow,
        str,
        str_alloc,
        string_type,
        stringify,
        struct_field_attributes,
        struct_inherit,
        struct_variant,
        structural_match,
        structural_peq,
        structural_teq,
        sty,
        sub,
        sub_assign,
        sub_with_overflow,
        suggestion,
        sym,
        sync,
        sync_trait,
        t32,
        target_arch,
        target_endian,
        target_env,
        target_family,
        target_feature,
        target_feature_11,
        target_has_atomic,
        target_has_atomic_equal_alignment,
        target_has_atomic_load_store,
        target_os,
        target_pointer_width,
        target_target_vendor,
        target_thread_local,
        target_vendor,
        task,
        tbm_target_feature,
        termination,
        termination_trait,
        termination_trait_test,
        test,
        test_2018_feature,
        test_accepted_feature,
        test_case,
        test_removed_feature,
        test_runner,
        then_with,
        thread,
        thread_local,
        tool_attributes,
        tool_lints,
        trace_macros,
        track_caller,
        trait_alias,
        transmute,
        transparent,
        transparent_enums,
        transparent_unions,
        trivial_bounds,
        truncf32,
        truncf64,
        try_blocks,
        try_trait,
        tt,
        tuple,
        tuple_from_req,
        tuple_indexing,
        two_phase,
        ty,
        type_alias_enum_variants,
        type_alias_impl_trait,
        type_ascription,
        type_id,
        type_length_limit,
        type_macros,
        type_name,
        u128,
        u16,
        u32,
        u64,
        u8,
        unaligned_volatile_load,
        unaligned_volatile_store,
        unboxed_closures,
        unchecked_add,
        unchecked_div,
        unchecked_mul,
        unchecked_rem,
        unchecked_shl,
        unchecked_shr,
        unchecked_sub,
        underscore_const_names,
        underscore_imports,
        underscore_lifetimes,
        uniform_paths,
        unit,
        universal_impl_trait,
        unix,
        unlikely,
        unmarked_api,
        unpin,
        unreachable,
        unreachable_code,
        unrestricted_attribute_tokens,
        unsafe_block_in_unsafe_fn,
        unsafe_cell,
        unsafe_no_drop_flag,
        unsize,
        unsized_fn_params,
        unsized_locals,
        unsized_tuple_coercion,
        unstable,
        untagged_unions,
        unused_qualifications,
        unwind,
        unwind_attributes,
        unwrap,
        unwrap_or,
        use_extern_macros,
        use_nested_groups,
        used,
        usize,
        v1,
        va_arg,
        va_copy,
        va_end,
        va_list,
        va_start,
        val,
        var,
        variant_count,
        vec,
        vec_type,
        version,
        vis,
        visible_private_types,
        volatile,
        volatile_copy_memory,
        volatile_copy_nonoverlapping_memory,
        volatile_load,
        volatile_set_memory,
        volatile_store,
        vreg,
        vreg_low16,
        warn,
        wasm_import_module,
        wasm_target_feature,
        while_let,
        width,
        windows,
        windows_subsystem,
        wrapping_add,
        wrapping_mul,
        wrapping_sub,
        write_bytes,
        xmm_reg,
        ymm_reg,
        zmm_reg,
        zz0000: "'tcx",
        zz0001: "'a",
        zz0002: " ```",
        zz0003: "tcx",
        zz0004: "T",
        zz0005: "this crate is being loaded from the sysroot, an unstable location; did you mean to load this crate from crates.io via `Cargo.toml` instead?",
        zz0006: "1.0.0",
        zz0007: "rust1",
        zz0008: "STRUCT",
        zz0009: "a",
        zz0010: "__encoder",
        zz0011: " # Examples",
        zz0012: "<upvars>",
        zz0013: "<closure_kind>",
        zz0014: "<closure_signature>",
        zz0015: "'hir",
        zz0016: "__err",
        zz0017: " }",
        zz0018: "A",
        zz0019: "span",
        zz0020: "RustaceansAreAwesome",
        zz0021: "__self_0",
        zz0022: "'data",
        zz0023: "b",
        zz0024: "F",
        zz0025: " ",
        zz0026: "Symbol",
        zz0027: "I",
        zz0028: "__res",
        zz0029: "V",
        zz0030: "__decoder",
        zz0031: "K",
        zz0032: "'b",
        zz0033: "arg0",
        zz0034: "data",
        zz0035: "B",
        zz0036: "hir",
        zz0037: "$crate::valueset",
        zz0038: "r",
        zz0039: "inner",
        zz0040: "'r",
        zz0041: "rustc_hir",
        zz0042: "rustc_span",
        zz0043: "len",
        zz0044: "new_v1",
        zz0045: "__binding_0",
        zz0046: "k",
        zz0047: "'file",
        zz0048: "$crate::fieldset",
        zz0049: "forward_ref_binop",
        zz0050: "E",
        zz0051: "value",
        zz0052: "D",
        zz0053: "rustc_middle",
        zz0054: "target",
        zz0055: "rustc_data_structures",
        zz0056: "Display",
        zz0057: "ptr",
        zz0058: "tracing",
        zz0059: "rustc_ast",
        zz0060: "__self_0_0",
        zz0061: "R",
        zz0062: "S",
        zz0063: "e",
        zz0064: "rustc_index",
        zz0065: "HashStable",
        zz0066: "$crate::event",
        zz0067: "parent",
        zz0068: "v",
        zz0069: "'s",
        zz0070: "'v",
        zz0071: "cfg_if",
        zz0072: "'__ctx",
        zz0073: "Span",
        zz0074: "s",
        zz0075: "Item",
        zz0076: "Ret",
        zz0077: "def_id",
        zz0078: "     }",
        zz0079: "arg1",
        zz0080: "id",
        zz0081: "N",
        zz0082: "hash_stable",
        zz0083: "key",
        zz0084: "x",
        zz0085: "P",
        zz0086: "cx",
        zz0087: "Cache",
        zz0088: "compute",
        zz0089: "U",
        zz0090: "c",
        zz0091: "hash_result",
        zz0092: "$crate::format_args",
        zz0093: " Basic usage:",
        zz0094: "handle_cycle_error",
        zz0095: "query_state",
        zz0096: "DEP_KIND",
        zz0097: "ANON",
        zz0098: "EVAL_ALWAYS",
        zz0099: "derive_clone_copy",
        zz0100: "__binding_1",
        zz0101: "mem",
        zz0102: "G",
        zz0103: "H",
        zz0104: "__arg_1_0",
        zz0105: "TypeFoldable",
        zz0106: "rustc_std_workspace_core",
        zz0107: "attempt to divide by zero",
        zz0108: "__hcx",
        zz0109: "__hasher",
        zz0110: "end",
        zz0111: "step_trait_ext",
        zz0112: "arg",
        zz0113: "step_trait",
        zz0114: "Value",
        zz0115: "avx512f",
        zz0116: "sess",
        zz0117: "__self_0_1",
        zz0118: "core_panic",
        zz0119: "ast",
        zz0120: "__self_1_0",
        zz0121: "t",
        zz0122: "fold",
        zz0123: "Type",
        zz0124: " documentation for more.",
        zz0125: "p",
        zz0126: "n",
        zz0127: "rustc_errors",
        zz0128: "$crate::level_enabled",
        zz0129: "$crate::callsite",
        zz0130: "$crate::__export::format_args",
        zz0131: "DefId",
        zz0132: " # Safety",
        zz0133: "$crate::newtype_index",
        zz0134: "hashbrown",
        zz0135: " ```rust",
        zz0136: " # Example",
        zz0137: "__E",
        zz0138: "src",
        zz0139: "1.27.0",
        zz0140: "1.",
        zz0141: "fields",
        zz0142: "count",
        zz0143: "TyDecodable",
        zz0144: "write",
        zz0145: "event",
        zz0146: "__ctx",
        zz0147: "ENUM",
        zz0148: "rustc_session",
        zz0149: "$crate::quote_token_with_context",
        zz0150: "attrs",
        zz0151: "HashStable_Generic",
        zz0152: "__self_vi",
        zz0153: "layout",
        zz0154: "hir_id",
        zz0155: "non_upper_case_globals",
        zz0156: "Const",
        zz0157: "Path",
        zz0158: "body",
        zz0159: "rustc_target",
        zz0160: "__self_1",
        zz0161: "base",
        zz0162: "token",
        zz0163: "1.28.0",
        zz0164: "$crate::__tracing_stringify",
        zz0165: "shl_impl",
        zz0166: "rustc_std_workspace_alloc",
        zz0167: "object",
        zz0168: "simd_test",
        zz0169: "$crate::metadata",
        zz0170: "$crate::identify_callsite",
        zz0171: "12",
        zz0172: "$crate::__tracing_log",
        zz0173: "doc_comment",
        zz0174: "TyEncodable",
        zz0175: "Level",
        zz0176: "elem",
        zz0177: "args",
        zz0178: " See its documentation for more.",
        zz0179: "gimli",
        zz0180: "emr",
        zz0181: "assert_instr",
        zz0182: "rustc_demangle",
        zz0183: "Q",
        zz0184: "addr2line",
        zz0185: "declare_lint",
        zz0186: "simd_ty",
        zz0187: "msg",
        zz0188: "1.34.0",
        zz0189: "visitor",
        zz0190: "get",
        zz0191: "__CTX",
        zz0192: "1.32.0",
        zz0193: "stable_hasher",
        zz0194: "UNION",
        zz0195: "Fn",
        zz0196: "substs",
        zz0197: "String",
        zz0198: "push",
        zz0199: "IntoIter",
        zz0200: "Flags",
        zz0201: "0b1111111111111111",
        zz0202: " ```no_run",
        zz0203: "10",
        zz0204: "mir",
        zz0205: "MAX",
        zz0206: "Ident",
        zz0207: "lvl",
        zz0208: " # }",
        zz0209: "Expr",
        zz0210: "none",
        zz0211: "buf",
        zz0212: "StableHasher",
        zz0213: "Deref",
        zz0214: "Box",
        zz0215: "error",
        zz0216: "const_caller_location",
        zz0217: "to_string",
        zz0218: "$crate::panic",
        zz0219: "imm8",
        zz0220: " unsafe {",
        zz0221: "is_empty",
        zz0222: "__arg_1_vi",
        zz0223: "callsite",
        zz0224: "smallvec",
        zz0225: "size_hint",
        zz0226: "cmd",
        zz0227: "Less",
        zz0228: "__folder",
        zz0229: "rustfmt::skip",
        zz0230: "11",
        zz0231: "__m512i",
        zz0232: "13",
        zz0233: "AssertParamIsClone",
        zz0234: "Iter",
        zz0235: "__binding_2",
        zz0236: "14",
        zz0237: " # Panics",
        zz0238: "simd_x86",
        zz0239: "PhantomData",
        zz0240: "15",
        zz0241: "sse2",
        zz0242: "__self",
        zz0243: "io",
        zz0244: "T11",
        zz0245: "walk_list",
        zz0246: "Node",
        zz0247: "Greater",
        zz0248: "bitflags",
        zz0249: "expand",
        zz0250: "Cow",
        zz0251: "idx",
        zz0252: "param_env",
        zz0253: "__self_0_2",
        zz0254: "1.2.0",
        zz0255: "Idx",
        zz0256: "ExprKind",
        zz0257: "J",
        zz0258: "this",
        zz0259: "__variant_idx",
        zz0260: "T10",
        zz0261: "StableHashingContext",
        zz0262: "1.26.0",
        zz0263: "length",
        zz0264: "node",
        zz0265: "cmdsize",
        zz0266: "Ref",
        zz0267: "warnings",
        zz0268: "place",
        zz0269: "unused_lifetimes",
        zz0270: "non_camel_case_types",
        zz0271: "rust_2018_idioms",
        zz0272: "insert",
        zz0273: "1.36.0",
        zz0274: "generics",
        zz0275: "16",
        zz0276: "assert_eq",
        zz0277: "Size",
        zz0278: "rest",
        zz0279: "bx",
        zz0280: "0.",
        zz0281: "Index",
        zz0282: "borrow",
        zz0283: "bytes",
        zz0284: "Lifetime",
        zz0285: "rustc_infer",
        zz0286: "sp",
        zz0287: "dst",
        zz0288: "MIN",
        zz0289: "Closure",
        zz0290: "pos",
        zz0291: " };",
        zz0292: "hasher",
        zz0293: " });",
        zz0294: " );",
        zz0295: "dw",
        zz0296: "Reserved",
        zz0297: "Local",
        zz0298: "T9",
        zz0299: "predicate",
        zz0300: "CTX",
        zz0301: "u",
        zz0302: "bits",
        zz0303: "Field",
        zz0304: "chalk_ir",
        zz0305: "__self_1_1",
        zz0306: "ItemKind",
        zz0307: "forward_ref_op_assign",
        zz0308: " use std::collections::HashMap;",
        zz0309: "infcx",
        zz0310: "query",
        zz0311: "rustc_macros",
        zz0312: "'de",
        zz0313: "`",
        zz0314: "::std::format_args",
        zz0315: "Int",
        zz0316: "32",
        zz0317: "op",
        zz0318: "into",
        zz0319: "__F",
        zz0320: "rustc_trait_selection",
        zz0321: "1.7.0",
        zz0322: "__m128i",
        zz0323: "0xFFFFFF00",
        zz0324: "1.9.0",
        zz0325: "left_val",
        zz0326: "right_val",
        zz0327: "def",
        zz0328: "Acc",
        zz0329: "Array",
        zz0330: "Struct",
        zz0331: "max",
        zz0332: " [slices]: ../../std/primitive.slice.html",
        zz0333: "location",
        zz0334: "Trait",
        zz0335: "as_ref",
        zz0336: "1.20.0",
        zz0337: "arg2",
        zz0338: "tail",
        zz0339: "res",
        zz0340: "IndexVec",
        zz0341: "Key",
        zz0342: " use std::thread;",
        zz0343: "2.",
        zz0344: "iterators are lazy and do nothing unless consumed",
        zz0345: "T8",
        zz0346: "ich",
        zz0347: "int_module",
        zz0348: "init",
        zz0349: "1.17.0",
        zz0350: "Sized",
        zz0351: "CALLSITE",
        zz0352: " let a = [1, 2, 3];",
        zz0353: "metadata",
        zz0354: "winapi",
        zz0355: "64",
        zz0356: "$crate::quote_token",
        zz0357: "Slice",
        zz0358: "GenericArg",
        zz0359: "Offset",
        zz0360: "matches",
        zz0361: "_marker",
        zz0362: "$crate::declare_lint",
        zz0363: "W",
        zz0364: "tokens",
        zz0365: "Region",
        zz0366: "collect",
        zz0367: "HirId",
        zz0368: "Static",
        zz0369: "1.4.0",
        zz0370: "param",
        zz0371: "bug",
        zz0372: "describe",
        zz0373: "last",
        zz0374: "Block",
        zz0375: "Mutability",
        zz0376: "sig",
        zz0377: "source",
        zz0378: "L",
        zz0379: "rustc::internal",
        zz0380: "'ll",
        zz0381: "PathBuf",
        zz0382: "AssertParamIsEq",
        zz0383: "Generator",
        zz0384: "section",
        zz0385: "y",
        zz0386: "contains",
        zz0387: "head",
        zz0388: "State",
        zz0389: "trait_ref",
        zz0390: "Empty",
        zz0391: "'i",
        zz0392: "avx512bw",
        zz0393: "__m256i",
        zz0394: "symbol",
        zz0395: "capacity",
        zz0396: "ControlFlow",
        zz0397: "bounds",
        zz0398: "1.6.0",
        zz0399: "FnMut",
        zz0400: " use std::ptr;",
        zz0401: "codec",
        zz0402: " use std::fmt;",
        zz0403: "lock",
        zz0404: "Write",
        zz0405: "DUMMY_SP",
        zz0406: "DerefMut",
        zz0407: "level",
        zz0408: " `](",
        zz0409: "input",
        zz0410: "struct_span_err",
        zz0411: "T7",
        zz0412: "obligation",
        zz0413: "Bound",
        zz0414: "Float",
        zz0415: "entry",
        zz0416: "Lrc",
        zz0417: "FusedIterator",
        zz0418: "CrateNum",
        zz0419: "Scalar",
        zz0420: "1.8.0",
        zz0421: " [`HashMap`]: struct.HashMap.html",
        zz0422: "1.10.0",
        zz0423: "lazy_static",
        zz0424: "table",
        zz0425: "Borrow",
        zz0426: "'unit",
        zz0427: "__self_0_3",
        zz0428: "'abbrev",
        zz0429: "Location",
        zz0430: "header",
        zz0431: "rustc_codegen_ssa",
        zz0432: "__m128",
        zz0433: "PatKind",
        zz0434: "Body",
        zz0435: "SubstsRef",
        zz0436: "__self_2",
        zz0437: "__arg_1_1",
        zz0438: "Rhs",
        zz0439: "zero",
        zz0440: "DEBUG",
        zz0441: "FromIterator",
        zz0442: "__arg_1",
        zz0443: "get_mut",
        zz0444: "Global",
        zz0445: "     Ok(())",
        zz0446: "items",
        zz0447: "Lift",
        zz0448: "emit",
        zz0449: "BinOp",
        zz0450: " use std::mem;",
        zz0451: "1.5.0",
        zz0452: "log",
        zz0453: "debug_builders",
        zz0454: "traits",
        zz0455: " ```text",
        zz0456: "Tag",
        zz0457: "private",
        zz0458: "register",
        zz0459: "LocalDefId",
        zz0460: "lo",
        zz0461: " The stabilized version of this intrinsic is available on the",
        zz0462: "set",
        zz0463: "Tuple",
        zz0464: "Mask",
        zz0465: "T6",
        zz0466: " [`Iterator`]: trait.Iterator.html",
        zz0467: "__m128d",
        zz0468: " let mut map = HashMap::new();",
        zz0469: "Pat",
        zz0470: "interner",
        zz0471: "source_map",
        zz0472: "IterMut",
        zz0473: "HashStableContext",
        zz0474: "Header",
        zz0475: "Place",
        zz0476: "kw",
        zz0477: "Union",
        zz0478: "'cx",
        zz0479: "left",
        zz0480: "fold_with",
        zz0481: "DefKind",
        zz0482: "right",
        zz0483: "source_info",
        zz0484: "Add",
        zz0485: "1.40.0",
        zz0486: "FnOnce",
        zz0487: "m",
        zz0488: " use hashbrown::HashMap;",
        zz0489: "queries",
        zz0490: "Metadata",
        zz0491: " ```rust,no_run",
        zz0492: "Drain",
        zz0493: "Id",
        zz0494: "MacCall",
        zz0495: "TerminatorKind",
        zz0496: "drain",
        zz0497: "MaybeUninit",
        zz0498: "ll",
        zz0499: "BasicBlock",
        zz0500: "AllocError",
        zz0501: "visit_with",
        zz0502: "O",
        zz0503: "Adt",
        zz0504: "extend",
        zz0505: "llvm",
        zz0506: "DEFINE_GUID",
        zz0507: "SmallVec",
        zz0508: "3.",
        zz0509: "1.38.0",
        zz0510: "valueset",
        zz0511: "rclBounds",
        zz0512: " assert_eq!(iter.next(), None);",
        zz0513: "Attribute",
        zz0514: "         }",
        zz0515: "Lit",
        zz0516: "__binding_3",
        zz0517: "Break",
        zz0518: "M",
        zz0519: "unused_variables",
        zz0520: "process",
        zz0521: "span_label",
        zz0522: "super_fold_with",
        zz0523: "assert_eq_m512i",
        zz0524: "BitFlags",
        zz0525: " use std::mem::MaybeUninit;",
        zz0526: "Pointer",
        zz0527: "NonNull",
        zz0528: "opts",
        zz0529: "cause",
        zz0530: "self_ty",
        zz0531: "super_visit_with",
        zz0532: "did",
        zz0533: " # fn main() {",
        zz0534: "BorrowType",
        zz0535: "TyAlias",
        zz0536: "dep_node_index",
        zz0537: "nth",
        zz0538: "begin",
        zz0539: "1.13.0",
        zz0540: "ErrorReported",
        zz0541: "stack",
        zz0542: "'ast",
        zz0543: "1.3.0",
        zz0544: "range",
        zz0545: "1.1.0",
        zz0546: "1.16.0",
        zz0547: "output",
        zz0548: " assert_eq!(",
        zz0549: "Applicability",
        zz0550: "debug_assert_eq",
        zz0551: "nonzero",
        zz0552: "skip",
        zz0553: "Mod",
        zz0554: ")",
        zz0555: "TokenTree",
        zz0556: "getrandom",
        zz0557: "Char",
        zz0558: "T5",
        zz0559: "Crate",
        zz0560: "time_date_stamp",
        zz0561: "values",
        zz0562: "ret",
        zz0563: "'bases",
        zz0564: "scopeguard",
        zz0565: "guard",
        zz0566: "print",
        zz0567: "NodeId",
        zz0568: "InlineAsm",
        zz0569: "FromStr",
        zz0570: "current",
        zz0571: "Impl",
        zz0572: "debug_assert",
        zz0573: "Projection",
        zz0574: "Arm",
        zz0575: "libstd_sys_internals",
        zz0576: "SidStart",
        zz0577: "DiagnosticBuilder",
        zz0578: "Visibility",
        zz0579: "lint",
        zz0580: "Occupied",
        zz0581: "rand_core",
        zz0582: "LOCAL_CRATE",
        zz0583: "symbols",
        zz0584: "find",
        zz0585: "Token",
        zz0586: "Str",
        zz0587: "typenum",
        zz0588: "Vacant",
        zz0589: "0.7.0",
        zz0590: "TokenStream",
        zz0591: "18",
        zz0592: "DrainFilter",
        zz0593: "Entry",
        zz0594: "QueryDescription",
        zz0595: "Not",
        zz0596: " use std::collections::HashSet;",
        zz0597: "Res",
        zz0598: "pred",
        zz0599: "17",
        zz0600: "rustc_index::newtype_index",
        zz0601: "krate",
        zz0602: "handle",
        zz0603: "TraitRef",
        zz0604: "Normal",
        zz0605: "Session",
        zz0606: "4.",
        zz0607: "string",
        zz0608: "code",
        zz0609: "impl IntoQueryParam<DefId>",
        zz0610: "Drop",
        zz0611: "__m512",
        zz0612: "indexmap",
        zz0613: "20",
        zz0614: "ppv_lite86",
        zz0615: "__m512d",
        zz0616: "desc",
        zz0617: "avx",
        zz0618: "additional",
        zz0619: "31",
        zz0620: "BinOpKind",
        zz0621: "Operand",
        zz0622: "dest",
        zz0623: "l",
        zz0624: "Match",
        zz0625: "parking_lot",
        zz0626: "UnsafeCell",
        zz0627: "InlineAsmOperand",
        zz0628: "'__lifted",
        zz0629: "Length",
        zz0630: "generic_array",
        zz0631: "'input",
        zz0632: "haystack",
        zz0633: "moved to rand_distr crate",
        zz0634: "try_fold",
        zz0635: "instant",
        zz0636: "lock_api",
        zz0637: "1.12.0",
        zz0638: "parking_lot_core",
        zz0639: "No",
        zz0640: "BorrowKind",
        zz0641: "LlvmInlineAsm",
        zz0642: "rustc_attr",
        zz0643: " [`HashSet`]: struct.HashSet.html",
        zz0644: "rustc_lexer",
        zz0645: "rustc_arena",
        zz0646: "Cell",
        zz0647: "internal to format_args!",
        zz0648: "19",
        zz0649: "rustc_hash",
        zz0650: "first",
        zz0651: "TyDecoder",
        zz0652: "BytePos",
        zz0653: "30",
        zz0654: "terminator",
        zz0655: "T4",
        zz0656: "remove_dir_all",
        zz0657: "Variant",
        zz0658: "     unsafe {",
        zz0659: "Coff",
        zz0660: "min",
        zz0661: "fs",
        zz0662: "TyEncoder",
        zz0663: "Infer",
        zz0664: "jobserver",
        zz0665: "tracing_attributes",
        zz0666: "__lifted",
        zz0667: "get_unchecked",
        zz0668: "info",
        zz0669: "Fold",
        zz0670: "root",
        zz0671: "24",
        zz0672: "try_from",
        zz0673: "avx2",
        zz0674: "rand_chacha",
        zz0675: "rand_pcg",
        zz0676: "MultiSpan",
        zz0677: "rand",
        zz0678: "region",
        zz0679: "rustc_graphviz",
        zz0680: "Placeholder",
        zz0681: "OsStr",
        zz0682: "digest",
        zz0683: "'t",
        zz0684: "mask",
        zz0685: "__mmask8",
        zz0686: "arrayvec",
        zz0687: "from_u32",
        zz0688: "measureme",
        zz0689: "tracing_core",
        zz0690: "28",
        zz0691: "25",
        zz0692: "22",
        zz0693: "replace",
        zz0694: "scoped_cx",
        zz0695: "1.47.0",
        zz0696: " # Errors",
        zz0697: "opaque_debug",
        zz0698: "26",
        zz0699: "Map",
        zz0700: " fn main() {",
        zz0701: "Lock",
        zz0702: "Data",
        zz0703: "acc",
        zz0704: "next_back",
        zz0705: "missing_docs",
        zz0706: "cap",
        zz0707: "Generics",
        zz0708: "21",
        zz0709: "block_buffer",
        zz0710: "23",
        zz0711: "buffer",
        zz0712: "Abi",
        zz0713: "stacker",
        zz0714: "is_anon",
        zz0715: "psm",
        zz0716: "Args",
        zz0717: "29",
        zz0718: "tempfile",
        zz0719: "27",
        zz0720: "IndexMut",
        zz0721: "Async",
        zz0722: "ena",
        zz0723: "take",
        zz0724: "Lazy",
        zz0725: "Yes",
        zz0726: "GenericParam",
        zz0727: "rustc_expand",
        zz0728: "$crate::cfg",
        zz0729: "Owned",
        zz0730: "features",
        zz0731: "Internal",
        zz0732: "'mir",
        zz0733: "missing_debug_implementations",
        zz0734: "LangItem",
        zz0735: "g",
        zz0736: "Allocator",
        zz0737: "__self_0_4",
        zz0738: "TryFrom",
        zz0739: "0xFFFF_FF00",
        zz0740: "stable_deref_trait",
        zz0741: "Rvalue",
        zz0742: "$crate::assert",
        zz0743: "unicode_width",
        zz0744: "Literal",
        zz0745: "siphasher",
        zz0746: "Stmt",
        zz0747: " (provided by the `IntoIterator` trait). See its documentation for more.",
        zz0748: "Once",
        zz0749: "types",
        zz0750: "inputs",
        zz0751: "cpuid_bool",
        zz0752: "Bool",
        zz0753: "dep_node",
        zz0754: " {",
        zz0755: "Repeat",
        zz0756: "integer_atomics_stable",
        zz0757: "List",
        zz0758: "1.21.0",
        zz0759: "it",
        zz0760: "BTreeMap",
        zz0761: "rustc_lint_defs",
        zz0762: "sha1",
        zz0763: "variant",
        zz0764: "debug_format",
        zz0765: "SeqCst",
        zz0766: "is_eval_always",
        zz0767: "Binary",
        zz0768: "$crate::assert_eq",
        zz0769: "remove",
        zz0770: "GlobalAsm",
        zz0771: " fn main() -> std::io::Result<()> {",
        zz0772: "md5",
        zz0773: "fn_sig",
        zz0774: "1.15.0",
        zz0775: "ToOwned",
        zz0776: "predicates",
        zz0777: "1.50.0",
        zz0778: "Edition",
        zz0779: "arch",
        zz0780: "TimeDateStamp",
        zz0781: "T3",
        zz0782: "Split",
        zz0783: "hcx",
        zz0784: "Stored",
        zz0785: "num",
        zz0786: "pointer_methods",
        zz0787: "Sub",
        zz0788: "ForeignItem",
        zz0789: "get_unchecked_mut",
        zz0790: "UnOp",
        zz0791: "100",
        zz0792: "phf_shared",
        zz0793: "hash_builder",
        zz0794: "const_ptr_offset",
        zz0795: "atomic_int",
        zz0796: "AnonConst",
        zz0797: "read",
        zz0798: "Continue",
        zz0799: "chunk_size",
        zz0800: "scoped_tls",
        zz0801: "assert_eq_m128i",
        zz0802: "1.31.0",
        zz0803: "rounding",
        zz0804: "StmtKind",
        zz0805: "Opaque",
        zz0806: "text",
        zz0807: "GenericParamKind",
        zz0808: "Name",
        zz0809: "FnSig",
        zz0810: "FileName",
        zz0811: "peel",
        zz0812: "list",
        zz0813: "is_some",
        zz0814: "addr",
        zz0815: "hi",
        zz0816: "Fingerprint",
        zz0817: " use std::io::prelude::*;",
        zz0818: "Call",
        zz0819: "dummy",
        zz0820: "NAME",
        zz0821: "empty",
        zz0822: "OsString",
        zz0823: "RefCell",
        zz0824: "__mmask16",
        zz0825: "Group",
        zz0826: "rustc_feature",
        zz0827: "phf",
        zz0828: "ManuallyDrop",
        zz0829: "imm4",
        zz0830: "with_no_trimmed_paths",
        zz0831: " impl fmt::Debug for Foo {",
        zz0832: " book_reviews.insert(",
        zz0833: "sha2",
        zz0834: "reserve",
        zz0835: "DWORD",
        zz0836: "CacheSelector",
        zz0837: "origin",
        zz0838: "Mut",
        zz0839: "characteristics",
        zz0840: "graph",
        zz0841: "macros",
        zz0842: "decoder",
        zz0843: "71499",
        zz0844: "arena",
        zz0845: "obligations",
        zz0846: "Visitor",
        zz0847: "instance",
        zz0848: " Behavior is undefined if any of the following conditions are violated:",
        zz0849: "PolyTraitRef",
        zz0850: "ecx",
        zz0851: "$crate::cfg_if",
        zz0852: "fieldset",
        zz0853: "decl",
        zz0854: "missing_inline_in_public_items",
        zz0855: "TypeFolder",
        zz0856: "config",
        zz0857: "Guard",
        zz0858: "PathSegment",
        zz0859: "MacroDef",
        zz0860: " An integer type which can be safely shared between threads.",
        zz0861: " This type has the same in-memory representation as the underlying",
        zz0862: " integer type, [`",
        zz0863: " ). For more about the differences between atomic types and",
        zz0864: " non-atomic types as well as information about the portability of",
        zz0865: " this type, please see the [module-level documentation].",
        zz0866: " **Note:** This type is only available on platforms that support",
        zz0867: " atomic loads and stores of [`",
        zz0868: " ).",
        zz0869: " [module-level documentation]: crate::sync::atomic",
        zz0870: "dwFlags",
        zz0871: "1.44.0",
        zz0872: "Dynamic",
        zz0873: "RangeBounds",
        zz0874: "FnDef",
        zz0875: "1.43.0",
        zz0876: "Any",
        zz0877: "T2",
        zz0878: " use std::fs::File;",
        zz0879: "iterator",
        zz0880: "from_u32_unchecked",
        zz0881: "fcx",
        zz0882: "unsafety",
        zz0883: "1.48.0",
        zz0884: "template",
        zz0885: "rustc_ast_pretty",
        zz0886: "query_helper_param_ty",
        zz0887: "1.29.0",
        zz0888: "returns a new pointer rather than modifying its argument",
        zz0889: "adt_def",
        zz0890: "endian",
        zz0891: "VariantData",
        zz0892: "with_capacity",
        zz0893: "Mutex",
        zz0894: "File",
        zz0895: "diag",
        zz0896: "Version",
        zz0897: "clear",
        zz0898: "folder",
        zz0899: "scope",
        zz0900: "old",
        zz0901: "Read",
        zz0902: "borrow_mut",
        zz0903: "Or",
        zz0904: "assert_eq_m256i",
        zz0905: "Duration",
        zz0906: "depth",
        zz0907: "ExpnId",
        zz0908: "TrustedLen",
        zz0909: "derives",
        zz0910: "Section",
        zz0911: "Values",
        zz0912: "discriminant",
        zz0913: "1.25.0",
        zz0914: "Borrowed",
        zz0915: "display",
        zz0916: "assertion failed: `(left == right)`",
        zz0917: "prefix",
        zz0918: "DropGuard",
        zz0919: "1.33.0",
        zz0920: "allocator_api",
        zz0921: "as_mut_ptr",
        zz0922: "StatementKind",
        zz0923: "1.42.0",
        zz0924: "1.30.0",
        zz0925: "unicode_xid",
        zz0926: "Never",
        zz0927: "GenericBound",
        zz0928: "cloned",
        zz0929: "default_span",
        zz0930: "from_iter",
        zz0931: "style",
        zz0932: "once_cell",
        zz0933: " ```should_panic",
        zz0934: "to",
        zz0935: "Bytes",
        zz0936: "v2",
        zz0937: "AtomicUsize",
        zz0938: "intravisit",
        zz0939: "5.",
        zz0940: "Leaf",
        zz0941: "Enum",
        zz0942: "variants",
        zz0943: "6.",
        zz0944: "ctxt",
        zz0945: "Uint",
        zz0946: " use std::sync::Arc;",
        zz0947: "cb",
        zz0948: "sys",
        zz0949: "NAN",
        zz0950: "ch",
        zz0951: "query_crate",
        zz0952: "Handle",
        zz0953: "I64",
        zz0954: "FnDecl",
        zz0955: "TryReserveError",
        zz0956: "phantom",
        zz0957: "OpaqueTy",
        zz0958: "Ptr",
        zz0959: "IntTy",
        zz0960: "w",
        zz0961: "F64",
        zz0962: "edition",
        zz0963: "'f",
        zz0964: "GenericArgKind",
        zz0965: "Defaultness",
        zz0966: "Shl",
        zz0967: "trace",
        zz0968: "time",
        zz0969: "enumerate",
        zz0970: "`,",
        zz0971: "Elf",
        zz0972: "provider",
        zz0973: "encoding",
        zz0974: "shr_impl",
        zz0975: "PredicateAtom",
        zz0976: "__self_1_2",
        zz0977: "TypeVisitor",
        zz0978: "AsInner",
        zz0979: "tag",
        zz0980: "word",
        zz0981: "Assign",
        zz0982: "body_id",
        zz0983: "copied",
        zz0984: "visit",
        zz0985: "order",
        zz0986: "swap",
        zz0987: "repeat",
        zz0988: "params",
        zz0989: "Cast",
        zz0990: "cnum",
        zz0991: "exp",
        zz0992: "Unsafe",
        zz0993: "sse",
        zz0994: "c_void",
        zz0995: "LitKind",
        zz0996: "AssocItemKind",
        zz0997: " It is part of the [`Entry`] enum.",
        zz0998: "Included",
        zz0999: "ForeignItemKind",
        zz1000: "this returns the result of the operation, without modifying the original",
        zz1001: "mode",
        zz1002: "Paren",
        zz1003: "byte",
        zz1004: "Gt",
        zz1005: "pattern",
        zz1006: " This intrinsic does not have a stable counterpart.",
        zz1007: "is_none",
        zz1008: "U32",
        zz1009: "__self_0_5",
        zz1010: "1.46.0",
        zz1011: "reserved",
        zz1012: "P0",
        zz1013: "visit_ty",
        zz1014: "unwrap_or_else",
        zz1015: "Elf32",
        zz1016: "Elf64",
        zz1017: "MachO32",
        zz1018: "MachO64",
        zz1019: "Pe32",
        zz1020: "Pe64",
        zz1021: "Unsize",
        zz1022: "CRATE_DEF_INDEX",
        zz1023: "1.45.0",
        zz1024: "nested",
        zz1025: "thread_local_internals",
        zz1026: "ObligationCause",
        zz1027: "Unpin",
        zz1028: "CoerceUnsized",
        zz1029: "pop",
        zz1030: "join",
        zz1031: "FnRetTy",
        zz1032: "VisibilityKind",
        zz1033: "     // ...",
        zz1034: "UintTy",
        zz1035: "ctrl",
        zz1036: "StructField",
        zz1037: " use std::collections::BTreeMap;",
        zz1038: "Raw",
        zz1039: "WhereClause",
        zz1040: "infer",
        zz1041: "parse",
        zz1042: "impls",
        zz1043: "loc",
        zz1044: "Pattern",
        zz1045: "Foreign",
        zz1046: "to_def_id",
        zz1047: "Shr",
        zz1048: "AngleBracketed",
        zz1049: "debug_assert_ne",
        zz1050: "AddAssign",
        zz1051: "filter",
        zz1052: "0b11111111",
        zz1053: "I32",
        zz1054: "TraitBoundModifier",
        zz1055: "Parenthesized",
        zz1056: "Use",
        zz1057: "slice_ptr_get",
        zz1058: "Mul",
        zz1059: "VariantIdx",
        zz1060: " use hashbrown::HashSet;",
        zz1061: "cell",
        zz1062: "const_wrapping_math",
        zz1063: "Receiver",
        zz1064: "write_str",
        zz1065: "InferCtxt",
        zz1066: " thread::spawn(move || {",
        zz1067: "WherePredicate",
        zz1068: "TraitItem",
        zz1069: "RwLock",
        zz1070: "SourceMap",
        zz1071: "ExactSizeIterator",
        zz1072: "segment",
        zz1073: "__binding_4",
        zz1074: "type_of",
        zz1075: "ParamEnv",
        zz1076: "ProjectionElem",
        zz1077: "expression",
        zz1078: "I16",
        zz1079: "F32",
        zz1080: "Wrapping",
        zz1081: "builtin_macro_prelude",
        zz1082: "Reject",
        zz1083: "Buffer",
        zz1084: "Binder",
        zz1085: "hint",
        zz1086: "I8",
        zz1087: "mutbl",
        zz1088: "BorrowMut",
        zz1089: "FieldPat",
        zz1090: "DoubleEndedIterator",
        zz1091: "Diagnostic",
        zz1092: "ForeignMod",
        zz1093: "RangeEnd",
        zz1094: "1.35.0",
        zz1095: "into_inner",
        zz1096: "Reserved1",
        zz1097: " >",
        zz1098: "ImplPolarity",
        zz1099: "job",
        zz1100: "1.37.0",
        zz1101: "ImplItem",
        zz1102: "UserProvided",
        zz1103: "Zero",
        zz1104: "scale",
        zz1105: "to_owned",
        zz1106: "verify-winapi",
        zz1107: "__session_diagnostic_sess",
        zz1108: "Context",
        zz1109: "BitSet",
        zz1110: "typeck_results",
        zz1111: "Unevaluated",
        zz1112: "CompilerGenerated",
        zz1113: "futures_api",
        zz1114: "7.",
        zz1115: "subst",
        zz1116: "profiler",
        zz1117: "as_f64x8",
        zz1118: "Keys",
        zz1119: "BlockCheckMode",
        zz1120: "RawPtr",
        zz1121: "DiscriminantKind",
        zz1122: "NodeType",
        zz1123: "GenericArgs",
        zz1124: "as_slice",
        zz1125: "util",
        zz1126: "8.",
        zz1127: "typ",
        zz1128: "getopts",
        zz1129: "as_f32x16",
        zz1130: "Reserved2",
        zz1131: "BitFields",
        zz1132: "Attributes",
        zz1133: "span_bug",
        zz1134: "TraitAlias",
        zz1135: "SliceIndex",
        zz1136: "TRACE",
        zz1137: "MetaItem",
        zz1138: "Excluded",
        zz1139: "check",
        zz1140: "32838",
        zz1141: "_mm_setr_ps",
        zz1142: "_mm512_setzero_si512",
        zz1143: "bb",
        zz1144: " `count` is in units of T; e.g., a `count` of 3 represents a pointer",
        zz1145: " offset of `3 * size_of::<T>()` bytes.",
        zz1146: "__iterator_get_unchecked",
        zz1147: "segments",
        zz1148: "as_u32",
        zz1149: "impl_trait_ref",
        zz1150: "projection",
        zz1151: "1.24.0",
        zz1152: "$crate::format_args_nl",
        zz1153: "iter_mut",
        zz1154: "tmp",
        zz1155: "ok",
        zz1156: "MacroKind",
        zz1157: "GenericBounds",
        zz1158: "signed_nonzero",
        zz1159: " Stores a value if the current value is the same as the `old` value.",
        zz1160: "split",
        zz1161: " system.",
        zz1162: "binding",
        zz1163: "avx512bw,avx512vl",
        zz1164: "__fn_bitflags",
        zz1165: "Canonical",
        zz1166: "T1",
        zz1167: "os",
        zz1168: "U64",
        zz1169: "41",
        zz1170: "Statement",
        zz1171: "cast",
        zz1172: "elt",
        zz1173: "associated_item",
        zz1174: "InlineAsmRegOrRegClass",
        zz1175: "TyAndLayout",
        zz1176: "def_span",
        zz1177: "_MM_FROUND_NO_EXC",
        zz1178: "NoSolution",
        zz1179: "Instance",
        zz1180: "74265",
        zz1181: "asyncness",
        zz1182: " [`char`]: prim@char",
        zz1183: "InstanceDef",
        zz1184: "element",
        zz1185: "avx512vl",
        zz1186: "1.19.0",
        zz1187: "k1",
        zz1188: "Event",
        zz1189: "FnHeader",
        zz1190: "Div",
        zz1191: "Unique",
        zz1192: "Lt",
        zz1193: "spec",
        zz1194: "Ur",
        zz1195: "const_math",
        zz1196: "edges",
        zz1197: "_core",
        zz1198: "'p",
        zz1199: "Def",
        zz1200: "Constant",
    }
}

#[derive(Copy, Clone, Eq, HashStable_Generic, Encodable, Decodable)]
pub struct Ident {
    pub name: Symbol,
    pub span: Span,
}

impl Ident {
    #[inline]
    /// Constructs a new identifier from a symbol and a span.
    pub const fn new(name: Symbol, span: Span) -> Ident {
        Ident { name, span }
    }

    /// Constructs a new identifier with a dummy span.
    #[inline]
    pub const fn with_dummy_span(name: Symbol) -> Ident {
        Ident::new(name, DUMMY_SP)
    }

    #[inline]
    pub fn invalid() -> Ident {
        Ident::with_dummy_span(kw::Empty)
    }

    /// Maps a string to an identifier with a dummy span.
    pub fn from_str(string: &str) -> Ident {
        Ident::with_dummy_span(Symbol::intern(string))
    }

    /// Maps a string and a span to an identifier.
    pub fn from_str_and_span(string: &str, span: Span) -> Ident {
        Ident::new(Symbol::intern(string), span)
    }

    /// Replaces `lo` and `hi` with those from `span`, but keep hygiene context.
    pub fn with_span_pos(self, span: Span) -> Ident {
        Ident::new(self.name, span.with_ctxt(self.span.ctxt()))
    }

    pub fn without_first_quote(self) -> Ident {
        Ident::new(Symbol::intern(self.as_str().trim_start_matches('\'')), self.span)
    }

    /// "Normalize" ident for use in comparisons using "item hygiene".
    /// Identifiers with same string value become same if they came from the same macro 2.0 macro
    /// (e.g., `macro` item, but not `macro_rules` item) and stay different if they came from
    /// different macro 2.0 macros.
    /// Technically, this operation strips all non-opaque marks from ident's syntactic context.
    pub fn normalize_to_macros_2_0(self) -> Ident {
        Ident::new(self.name, self.span.normalize_to_macros_2_0())
    }

    /// "Normalize" ident for use in comparisons using "local variable hygiene".
    /// Identifiers with same string value become same if they came from the same non-transparent
    /// macro (e.g., `macro` or `macro_rules!` items) and stay different if they came from different
    /// non-transparent macros.
    /// Technically, this operation strips all transparent marks from ident's syntactic context.
    pub fn normalize_to_macro_rules(self) -> Ident {
        Ident::new(self.name, self.span.normalize_to_macro_rules())
    }

    /// Convert the name to a `SymbolStr`. This is a slowish operation because
    /// it requires locking the symbol interner.
    pub fn as_str(self) -> SymbolStr {
        self.name.as_str()
    }
}

impl PartialEq for Ident {
    fn eq(&self, rhs: &Self) -> bool {
        self.name == rhs.name && self.span.ctxt() == rhs.span.ctxt()
    }
}

impl Hash for Ident {
    fn hash<H: Hasher>(&self, state: &mut H) {
        self.name.hash(state);
        self.span.ctxt().hash(state);
    }
}

impl fmt::Debug for Ident {
    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {
        fmt::Display::fmt(self, f)?;
        fmt::Debug::fmt(&self.span.ctxt(), f)
    }
}

/// This implementation is supposed to be used in error messages, so it's expected to be identical
/// to printing the original identifier token written in source code (`token_to_string`),
/// except that AST identifiers don't keep the rawness flag, so we have to guess it.
impl fmt::Display for Ident {
    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {
        fmt::Display::fmt(&IdentPrinter::new(self.name, self.is_raw_guess(), None), f)
    }
}

/// This is the most general way to print identifiers.
/// AST pretty-printer is used as a fallback for turning AST structures into token streams for
/// proc macros. Additionally, proc macros may stringify their input and expect it survive the
/// stringification (especially true for proc macro derives written between Rust 1.15 and 1.30).
/// So we need to somehow pretty-print `$crate` in a way preserving at least some of its
/// hygiene data, most importantly name of the crate it refers to.
/// As a result we print `$crate` as `crate` if it refers to the local crate
/// and as `::other_crate_name` if it refers to some other crate.
/// Note, that this is only done if the ident token is printed from inside of AST pretty-pringing,
/// but not otherwise. Pretty-printing is the only way for proc macros to discover token contents,
/// so we should not perform this lossy conversion if the top level call to the pretty-printer was
/// done for a token stream or a single token.
pub struct IdentPrinter {
    symbol: Symbol,
    is_raw: bool,
    /// Span used for retrieving the crate name to which `$crate` refers to,
    /// if this field is `None` then the `$crate` conversion doesn't happen.
    convert_dollar_crate: Option<Span>,
}

impl IdentPrinter {
    /// The most general `IdentPrinter` constructor. Do not use this.
    pub fn new(symbol: Symbol, is_raw: bool, convert_dollar_crate: Option<Span>) -> IdentPrinter {
        IdentPrinter { symbol, is_raw, convert_dollar_crate }
    }

    /// This implementation is supposed to be used when printing identifiers
    /// as a part of pretty-printing for larger AST pieces.
    /// Do not use this either.
    pub fn for_ast_ident(ident: Ident, is_raw: bool) -> IdentPrinter {
        IdentPrinter::new(ident.name, is_raw, Some(ident.span))
    }
}

impl fmt::Display for IdentPrinter {
    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {
        if self.is_raw {
            f.write_str("r#")?;
        } else if self.symbol == kw::DollarCrate {
            if let Some(span) = self.convert_dollar_crate {
                let converted = span.ctxt().dollar_crate_name();
                if !converted.is_path_segment_keyword() {
                    f.write_str("::")?;
                }
                return fmt::Display::fmt(&converted, f);
            }
        }
        fmt::Display::fmt(&self.symbol, f)
    }
}

/// An newtype around `Ident` that calls [Ident::normalize_to_macro_rules] on
/// construction.
// FIXME(matthewj, petrochenkov) Use this more often, add a similar
// `ModernIdent` struct and use that as well.
#[derive(Copy, Clone, Eq, PartialEq, Hash)]
pub struct MacroRulesNormalizedIdent(Ident);

impl MacroRulesNormalizedIdent {
    pub fn new(ident: Ident) -> Self {
        Self(ident.normalize_to_macro_rules())
    }
}

impl fmt::Debug for MacroRulesNormalizedIdent {
    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {
        fmt::Debug::fmt(&self.0, f)
    }
}

impl fmt::Display for MacroRulesNormalizedIdent {
    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {
        fmt::Display::fmt(&self.0, f)
    }
}

/// An interned string.
///
/// Internally, a `Symbol` is implemented as an index, and all operations
/// (including hashing, equality, and ordering) operate on that index. The use
/// of `rustc_index::newtype_index!` means that `Option<Symbol>` only takes up 4 bytes,
/// because `rustc_index::newtype_index!` reserves the last 256 values for tagging purposes.
///
/// Note that `Symbol` cannot directly be a `rustc_index::newtype_index!` because it
/// implements `fmt::Debug`, `Encodable`, and `Decodable` in special ways.
#[derive(Clone, Copy, PartialEq, Eq, PartialOrd, Ord, Hash)]
pub struct Symbol(SymbolIndex);

rustc_index::newtype_index! {
    pub struct SymbolIndex { .. }
}

impl Symbol {
    const fn new(n: u32) -> Self {
        Symbol(SymbolIndex::from_u32(n))
    }

    /// Maps a string to its interned representation.
    pub fn intern(string: &str) -> Self {
        if let Some(symbol) = STATIC_SYMBOLS_PHF.get(string) {
            *symbol
        } else {
            with_interner(|interner| interner.intern(string))
        }
    }

    /// Convert to a `SymbolStr`. This is a slowish operation because it
    /// requires locking the symbol interner.
    pub fn as_str(self) -> SymbolStr {
        with_interner(|interner| unsafe {
            SymbolStr { string: std::mem::transmute::<&str, &str>(interner.get(self)) }
        })
    }

    pub fn as_u32(self) -> u32 {
        self.0.as_u32()
    }

    pub fn is_empty(self) -> bool {
        self == kw::Empty
    }

    /// This method is supposed to be used in error messages, so it's expected to be
    /// identical to printing the original identifier token written in source code
    /// (`token_to_string`, `Ident::to_string`), except that symbols don't keep the rawness flag
    /// or edition, so we have to guess the rawness using the global edition.
    pub fn to_ident_string(self) -> String {
        Ident::with_dummy_span(self).to_string()
    }
}

impl fmt::Debug for Symbol {
    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {
        fmt::Debug::fmt(&self.as_str(), f)
    }
}

impl fmt::Display for Symbol {
    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {
        fmt::Display::fmt(&self.as_str(), f)
    }
}

impl<S: Encoder> Encodable<S> for Symbol {
    fn encode(&self, s: &mut S) -> Result<(), S::Error> {
        s.emit_str(&self.as_str())
    }
}

impl<D: Decoder> Decodable<D> for Symbol {
    #[inline]
    fn decode(d: &mut D) -> Result<Symbol, D::Error> {
        Ok(Symbol::intern(&d.read_str()?))
    }
}

impl<CTX> HashStable<CTX> for Symbol {
    #[inline]
    fn hash_stable(&self, hcx: &mut CTX, hasher: &mut StableHasher) {
        self.as_str().hash_stable(hcx, hasher);
    }
}

impl<CTX> ToStableHashKey<CTX> for Symbol {
    type KeyType = SymbolStr;

    #[inline]
    fn to_stable_hash_key(&self, _: &CTX) -> SymbolStr {
        self.as_str()
    }
}

// The `&'static str`s in this type actually point into the arena.
//
// The `FxHashMap`+`Vec` pair could be replaced by `FxIndexSet`, but #75278
// found that to regress performance up to 2% in some cases. This might be
// revisited after further improvements to `indexmap`.
#[derive(Default)]
pub struct Interner {
    arena: DroplessArena,
    names: FxHashMap<&'static str, Symbol>,
    strings: Vec<&'static str>,
}

impl Interner {
    fn prefill(init: &[&'static str]) -> Self {
        Interner {
            strings: init.into(),
            names: init.iter().copied().zip((0..).map(Symbol::new)).collect(),
            ..Default::default()
        }
    }

    #[inline]
    pub fn intern(&mut self, string: &str) -> Symbol {
        if let Some(&name) = self.names.get(string) {
            return name;
        }

        let name = Symbol::new(self.strings.len() as u32);

        // `from_utf8_unchecked` is safe since we just allocated a `&str` which is known to be
        // UTF-8.
        let string: &str =
            unsafe { str::from_utf8_unchecked(self.arena.alloc_slice(string.as_bytes())) };
        // It is safe to extend the arena allocation to `'static` because we only access
        // these while the arena is still alive.
        let string: &'static str = unsafe { &*(string as *const str) };
        self.strings.push(string);
        self.names.insert(string, name);
        name
    }

    // Get the symbol as a string. `Symbol::as_str()` should be used in
    // preference to this function.
    pub fn get(&self, symbol: Symbol) -> &str {
        self.strings[symbol.0.as_usize()]
    }
}

// This module has a very short name because it's used a lot.
/// This module contains all the defined keyword `Symbol`s.
///
/// Given that `kw` is imported, use them like `kw::keyword_name`.
/// For example `kw::Loop` or `kw::Break`.
pub mod kw {
    pub use super::kw_generated::*;
}

// This module has a very short name because it's used a lot.
/// This module contains all the defined non-keyword `Symbol`s.
///
/// Given that `sym` is imported, use them like `sym::symbol_name`.
/// For example `sym::rustfmt` or `sym::u8`.
pub mod sym {
    use super::Symbol;
    use std::convert::TryInto;

    pub use super::sym_generated::*;

    // Used from a macro in `librustc_feature/accepted.rs`
    pub use super::kw::MacroRules as macro_rules;

    /// Get the symbol for an integer.
    ///
    /// The first few non-negative integers each have a static symbol and therefore
    /// are fast.
    pub fn integer<N: TryInto<usize> + Copy + ToString>(n: N) -> Symbol {
        if let Result::Ok(idx) = n.try_into() {
            if idx < 10 {
                return Symbol::new(super::SYMBOL_DIGITS_BASE + idx as u32);
            }
        }
        Symbol::intern(&n.to_string())
    }
}

impl Symbol {
    fn is_special(self) -> bool {
        self <= kw::Underscore
    }

    fn is_used_keyword_always(self) -> bool {
        self >= kw::As && self <= kw::While
    }

    fn is_used_keyword_conditional(self, edition: impl FnOnce() -> Edition) -> bool {
        (self >= kw::Async && self <= kw::Dyn) && edition() >= Edition::Edition2018
    }

    fn is_unused_keyword_always(self) -> bool {
        self >= kw::Abstract && self <= kw::Yield
    }

    fn is_unused_keyword_conditional(self, edition: impl FnOnce() -> Edition) -> bool {
        self == kw::Try && edition() >= Edition::Edition2018
    }

    pub fn is_reserved(self, edition: impl Copy + FnOnce() -> Edition) -> bool {
        self.is_special()
            || self.is_used_keyword_always()
            || self.is_unused_keyword_always()
            || self.is_used_keyword_conditional(edition)
            || self.is_unused_keyword_conditional(edition)
    }

    /// A keyword or reserved identifier that can be used as a path segment.
    pub fn is_path_segment_keyword(self) -> bool {
        self == kw::Super
            || self == kw::SelfLower
            || self == kw::SelfUpper
            || self == kw::Crate
            || self == kw::PathRoot
            || self == kw::DollarCrate
    }

    /// Returns `true` if the symbol is `true` or `false`.
    pub fn is_bool_lit(self) -> bool {
        self == kw::True || self == kw::False
    }

    /// Returns `true` if this symbol can be a raw identifier.
    pub fn can_be_raw(self) -> bool {
        self != kw::Empty && self != kw::Underscore && !self.is_path_segment_keyword()
    }
}

impl Ident {
    // Returns `true` for reserved identifiers used internally for elided lifetimes,
    // unnamed method parameters, crate root module, error recovery etc.
    pub fn is_special(self) -> bool {
        self.name.is_special()
    }

    /// Returns `true` if the token is a keyword used in the language.
    pub fn is_used_keyword(self) -> bool {
        // Note: `span.edition()` is relatively expensive, don't call it unless necessary.
        self.name.is_used_keyword_always()
            || self.name.is_used_keyword_conditional(|| self.span.edition())
    }

    /// Returns `true` if the token is a keyword reserved for possible future use.
    pub fn is_unused_keyword(self) -> bool {
        // Note: `span.edition()` is relatively expensive, don't call it unless necessary.
        self.name.is_unused_keyword_always()
            || self.name.is_unused_keyword_conditional(|| self.span.edition())
    }

    /// Returns `true` if the token is either a special identifier or a keyword.
    pub fn is_reserved(self) -> bool {
        // Note: `span.edition()` is relatively expensive, don't call it unless necessary.
        self.name.is_reserved(|| self.span.edition())
    }

    /// A keyword or reserved identifier that can be used as a path segment.
    pub fn is_path_segment_keyword(self) -> bool {
        self.name.is_path_segment_keyword()
    }

    /// We see this identifier in a normal identifier position, like variable name or a type.
    /// How was it written originally? Did it use the raw form? Let's try to guess.
    pub fn is_raw_guess(self) -> bool {
        self.name.can_be_raw() && self.is_reserved()
    }
}

#[inline]
fn with_interner<T, F: FnOnce(&mut Interner) -> T>(f: F) -> T {
    SESSION_GLOBALS.with(|session_globals| f(&mut *session_globals.symbol_interner.lock()))
}

/// An alternative to [`Symbol`], useful when the chars within the symbol need to
/// be accessed. It deliberately has limited functionality and should only be
/// used for temporary values.
///
/// Because the interner outlives any thread which uses this type, we can
/// safely treat `string` which points to interner data, as an immortal string,
/// as long as this type never crosses between threads.
//
// FIXME: ensure that the interner outlives any thread which uses `SymbolStr`,
// by creating a new thread right after constructing the interner.
#[derive(Clone, Eq, PartialOrd, Ord)]
pub struct SymbolStr {
    string: &'static str,
}

// This impl allows a `SymbolStr` to be directly equated with a `String` or
// `&str`.
impl<T: std::ops::Deref<Target = str>> std::cmp::PartialEq<T> for SymbolStr {
    fn eq(&self, other: &T) -> bool {
        self.string == other.deref()
    }
}

impl !Send for SymbolStr {}
impl !Sync for SymbolStr {}

/// This impl means that if `ss` is a `SymbolStr`:
/// - `*ss` is a `str`;
/// - `&*ss` is a `&str` (and `match &*ss { ... }` is a common pattern).
/// - `&ss as &str` is a `&str`, which means that `&ss` can be passed to a
///   function expecting a `&str`.
impl std::ops::Deref for SymbolStr {
    type Target = str;
    #[inline]
    fn deref(&self) -> &str {
        self.string
    }
}

impl fmt::Debug for SymbolStr {
    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {
        fmt::Debug::fmt(self.string, f)
    }
}

impl fmt::Display for SymbolStr {
    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {
        fmt::Display::fmt(self.string, f)
    }
}

impl<CTX> HashStable<CTX> for SymbolStr {
    #[inline]
    fn hash_stable(&self, hcx: &mut CTX, hasher: &mut StableHasher) {
        self.string.hash_stable(hcx, hasher)
    }
}

impl<CTX> ToStableHashKey<CTX> for SymbolStr {
    type KeyType = SymbolStr;

    #[inline]
    fn to_stable_hash_key(&self, _: &CTX) -> SymbolStr {
        self.clone()
    }
}
