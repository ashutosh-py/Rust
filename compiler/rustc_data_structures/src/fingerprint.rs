use crate::stable_hasher;
use rustc_serialize::{
    opaque::{self, EncodeResult},
    Decodable, Encodable,
};
use std::cmp::Ordering;
use std::hash::{Hash, Hasher};

#[cfg(test)]
mod tests;

// Use `[u8; 16]` representation since it imposes no alignment requirements.
// This can reduce memory consumption by preventing otherwise unnecessary
// padding in arrays of structs containing `Fingerprint`s. An example of this is
// the query dependency graph, which contains a large array of `DepNode`s. As of
// this writing, the size of a `DepNode` decreases by ~30% (from 24 bytes to 17)
// by using a byte array here instead of two `u64`s, which noticeably decreases
// total memory usage when compiling large crates. However, it has the potential
// to increase the instruction count slightly if not carefully implemented.
#[derive(Eq, Debug, Clone, Copy)]
pub struct Fingerprint([u8; 16]);

impl Fingerprint {
    pub const ZERO: Fingerprint = Fingerprint([0; 16]);

    #[inline]
    fn from_value(v0: u64, v1: u64) -> Fingerprint {
        Fingerprint([
            (v0 >> 0) as u8,
            (v0 >> 8) as u8,
            (v0 >> 16) as u8,
            (v0 >> 24) as u8,
            (v0 >> 32) as u8,
            (v0 >> 40) as u8,
            (v0 >> 48) as u8,
            (v0 >> 56) as u8,
            (v1 >> 0) as u8,
            (v1 >> 8) as u8,
            (v1 >> 16) as u8,
            (v1 >> 24) as u8,
            (v1 >> 32) as u8,
            (v1 >> 40) as u8,
            (v1 >> 48) as u8,
            (v1 >> 56) as u8,
        ])
    }

    #[inline]
    pub fn to_value(&self) -> (u64, u64) {
        (
            ((self.0[0] as u64) << 0)
                | ((self.0[1] as u64) << 8)
                | ((self.0[2] as u64) << 16)
                | ((self.0[3] as u64) << 24)
                | ((self.0[4] as u64) << 32)
                | ((self.0[5] as u64) << 40)
                | ((self.0[6] as u64) << 48)
                | ((self.0[7] as u64) << 56),
            ((self.0[8] as u64) << 0)
                | ((self.0[9] as u64) << 8)
                | ((self.0[10] as u64) << 16)
                | ((self.0[11] as u64) << 24)
                | ((self.0[12] as u64) << 32)
                | ((self.0[13] as u64) << 40)
                | ((self.0[14] as u64) << 48)
                | ((self.0[15] as u64) << 56),
        )
    }

    #[inline]
    fn from_value_u128(v: u128) -> Fingerprint {
        Fingerprint::from_value(v as u64, (v >> 64) as u64)
    }

    #[inline]
    pub fn to_value_u128(&self) -> u128 {
        let (v0, v1) = self.to_value();
        v0 as u128 | ((v1 as u128) << 64)
    }

    #[inline]
    pub fn from_smaller_hash(hash: u64) -> Fingerprint {
        Fingerprint::from_value(hash, hash)
    }

    #[inline]
    pub fn to_smaller_hash(&self) -> u64 {
        self.to_value().0
    }

    #[inline]
    pub fn combine(self, other: Fingerprint) -> Fingerprint {
        // See https://stackoverflow.com/a/27952689 on why this function is
        // implemented this way.
        let v = self.to_value_u128().wrapping_mul(3).wrapping_add(other.to_value_u128());
        Fingerprint::from_value_u128(v)
    }

    // Combines two hashes in an order independent way. Make sure this is what
    // you want.
    #[inline]
    pub fn combine_commutative(self, other: Fingerprint) -> Fingerprint {
        let v = self.to_value_u128().wrapping_add(other.to_value_u128());
        Fingerprint::from_value_u128(v)
    }

    pub fn to_hex(&self) -> String {
        let (self0, self1) = self.to_value();
        format!("{:x}{:x}", self0, self1)
    }

    pub fn encode_opaque(&self, encoder: &mut opaque::Encoder) -> EncodeResult {
        encoder.emit_raw_bytes(&self.0);
        Ok(())
    }

    pub fn decode_opaque(decoder: &mut opaque::Decoder<'_>) -> Result<Fingerprint, String> {
        let mut fingerprint = Fingerprint::ZERO;
        decoder.read_raw_bytes(&mut fingerprint.0)?;
        Ok(fingerprint)
    }
}

impl std::fmt::Display for Fingerprint {
    fn fmt(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let (self0, self1) = self.to_value();
        write!(formatter, "{:x}-{:x}", self0, self1)
    }
}

impl Ord for Fingerprint {
    #[inline]
    fn cmp(&self, other: &Fingerprint) -> Ordering {
        // This implementation is faster than the one generated by the `derive` attribute.
        self.to_value_u128().cmp(&other.to_value_u128())
    }
}

impl PartialOrd for Fingerprint {
    #[inline]
    fn partial_cmp(&self, other: &Fingerprint) -> Option<Ordering> {
        // This implementation is faster than the one generated by the `derive` attribute.
        Some(self.cmp(other))
    }
}

impl PartialEq for Fingerprint {
    #[inline]
    fn eq(&self, other: &Fingerprint) -> bool {
        // This implementation is faster than the one generated by the `derive` attribute.
        self.to_value_u128() == other.to_value_u128()
    }
}

impl Hash for Fingerprint {
    #[inline]
    fn hash<H: Hasher>(&self, state: &mut H) {
        state.write_fingerprint(self);
    }
}

trait FingerprintHasher {
    fn write_fingerprint(&mut self, fingerprint: &Fingerprint);
}

impl<H: Hasher> FingerprintHasher for H {
    #[inline]
    default fn write_fingerprint(&mut self, fingerprint: &Fingerprint) {
        // It's faster to hash this as two `u64`s than as a `u128` or slice.
        let (fingerprint0, fingerprint1) = fingerprint.to_value();
        self.write_u64(fingerprint0);
        self.write_u64(fingerprint1);
    }
}

impl FingerprintHasher for crate::unhash::Unhasher {
    #[inline]
    fn write_fingerprint(&mut self, fingerprint: &Fingerprint) {
        // `Unhasher` only wants a single `u64`
        let (fingerprint0, _) = fingerprint.to_value();
        self.write_u64(fingerprint0);
    }
}

impl stable_hasher::StableHasherResult for Fingerprint {
    #[inline]
    fn finish(hasher: stable_hasher::StableHasher) -> Self {
        let (_0, _1) = hasher.finalize();
        Fingerprint::from_value(_0, _1)
    }
}

impl_stable_hash_via_hash!(Fingerprint);

impl<E: rustc_serialize::Encoder> Encodable<E> for Fingerprint {
    fn encode(&self, s: &mut E) -> Result<(), E::Error> {
        s.encode_fingerprint(self)
    }
}

impl<D: rustc_serialize::Decoder> Decodable<D> for Fingerprint {
    fn decode(d: &mut D) -> Result<Self, D::Error> {
        d.decode_fingerprint()
    }
}

pub trait FingerprintEncoder: rustc_serialize::Encoder {
    fn encode_fingerprint(&mut self, f: &Fingerprint) -> Result<(), Self::Error>;
}

pub trait FingerprintDecoder: rustc_serialize::Decoder {
    fn decode_fingerprint(&mut self) -> Result<Fingerprint, Self::Error>;
}

impl<E: rustc_serialize::Encoder> FingerprintEncoder for E {
    default fn encode_fingerprint(&mut self, _: &Fingerprint) -> Result<(), E::Error> {
        panic!("Cannot encode `Fingerprint` with `{}`", std::any::type_name::<E>());
    }
}

impl FingerprintEncoder for opaque::Encoder {
    fn encode_fingerprint(&mut self, f: &Fingerprint) -> EncodeResult {
        f.encode_opaque(self)
    }
}

impl<D: rustc_serialize::Decoder> FingerprintDecoder for D {
    default fn decode_fingerprint(&mut self) -> Result<Fingerprint, D::Error> {
        panic!("Cannot decode `Fingerprint` with `{}`", std::any::type_name::<D>());
    }
}
impl FingerprintDecoder for opaque::Decoder<'_> {
    fn decode_fingerprint(&mut self) -> Result<Fingerprint, String> {
        Fingerprint::decode_opaque(self)
    }
}
