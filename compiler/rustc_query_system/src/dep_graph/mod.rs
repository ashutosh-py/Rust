pub mod debug;
mod dep_kind;
mod dep_node;
mod graph;
mod query;
mod serialized;

pub use dep_kind::{dep_kind_from_label_string, label_strs, DepKind};
pub use dep_node::{DepNode, DepNodeParams, WorkProductId, NODE_DEBUG};
pub use graph::{hash_result, DepGraph, DepNodeColor, DepNodeIndex, TaskDeps, WorkProduct};
pub use query::DepGraphQuery;
pub use serialized::{SerializedDepGraph, SerializedDepNodeIndex};

use crate::ich::StableHashingContext;
use rustc_data_structures::profiling::SelfProfilerRef;
use rustc_session::Session;

pub trait DepContext: Copy {
    /// Create a hashing context for hashing new results.
    fn create_stable_hashing_context(&self) -> StableHashingContext<'_>;

    /// Access the DepGraph.
    fn dep_graph(&self) -> &DepGraph;

    /// Access the profiler.
    fn profiler(&self) -> &SelfProfilerRef;

    /// Access the compiler session.
    fn sess(&self) -> &Session;

    /// Return whether this kind always require evaluation.
    fn is_eval_always(&self, kind: DepKind) -> bool;

    fn fingerprint_style(&self, kind: DepKind) -> FingerprintStyle;

    /// Try to force a dep node to execute and see if it's green.
    fn try_force_from_dep_node(&self, dep_node: DepNode) -> bool;

    /// Load data from the on-disk cache.
    fn try_load_from_on_disk_cache(&self, dep_node: DepNode);
}

pub trait HasDepContext: Copy {
    type DepContext: self::DepContext;

    fn dep_context(&self) -> &Self::DepContext;
}

impl<T: DepContext> HasDepContext for T {
    type DepContext = Self;

    fn dep_context(&self) -> &Self::DepContext {
        self
    }
}

/// Describes the contents of the fingerprint generated by a given query.
#[derive(Debug, PartialEq, Eq, Copy, Clone)]
pub enum FingerprintStyle {
    /// The fingerprint is actually a DefPathHash.
    DefPathHash,
    /// Query key was `()` or equivalent, so fingerprint is just zero.
    Unit,
    /// Some opaque hash.
    Opaque,
}

impl FingerprintStyle {
    #[inline]
    pub fn reconstructible(self) -> bool {
        match self {
            FingerprintStyle::DefPathHash | FingerprintStyle::Unit => true,
            FingerprintStyle::Opaque => false,
        }
    }
}
