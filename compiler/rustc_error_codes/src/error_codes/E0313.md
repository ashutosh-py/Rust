Lifetime of borrowed pointer outlives lifetime of captured variable.

Erroneous code example:

```compile_fail,E0313
fn foo(bar: &'static mut ()) {
    || foo(bar);
}
```

This error is raised because the body of the closure, which implements `FnMut`,
has a lifetime shorter than `'static`. Let's name this lifetime `'fooc`. This is
problematic because `foo`'s argument requires that `'fooc` must outlive
`'static`, but references to captured variables in a `FnMut` closure can't
escape the closure.

To fix this error, define a temporary variable inside the closure that takes
ownership of `foo`'s argument. Then, pass this into `foo`:

```
fn foo(bar: &'static mut ()) {
    || {
        let baz = bar;
        foo(baz);
    };
}
```

This works because `bar` must be moved into the closure for the body to be
sensical. The closure now implements `FnOnce` because the value is moved in
then moved out in order to call the function, meaning it can only be called
once.

Additionally, it seems like the following would also work:

```
fn foo(bar: &'static mut ()) {
    move || foo(bar);
}
```

Although the closure is forced to capture its environment by value, which is
what `FnOnce` does, `move` closures can still implement `FnMut` (or `Fn`).
