A value was moved whose size was not known at compile time.

Erroneous code example:

```compile_fail,E0161
trait Bar {
    fn f(self);
}

impl Bar for i32 {
    fn f(self) {}
}

fn main() {
    let b: Box<dyn Bar> = Box::new(0i32);
    b.f();
    // error: cannot move a value of type dyn Bar: the size of dyn Bar cannot
    //        be statically determined
}
```

In Rust, you can only move a value when its size is known at compile time.

To work around this restriction, consider "hiding" the value behind a
reference: either `&x` or `&mut x`. Since a reference has a fixed size, this
lets you move it around as usual. Example:

```
trait Bar {
    fn f(&self);
}

impl Bar for i32 {
    fn f(&self) {}
}

fn main() {
    let b: Box<dyn Bar> = Box::new(0i32);
    b.f();
    // ok!
}
```

If you absolutely must use a value by moving in a trait, and you know that you
will primarily use your trait through boxed trait objects, you may want to
consider using the `Box<Self>` pattern.  You can then move the value out of the
`Box` by dereferencing. For example:

```
trait Bar {
    fn f(self: Box<Self>);
}

impl Bar for String {
    fn f(self: Box<Self>) {
        // move the string out of the box
        let _string: String = *self;
    }
}

fn main() {
    let b: Box<dyn Bar> = Box::new(String::new());
    b.f();
    // ok!
}
```
