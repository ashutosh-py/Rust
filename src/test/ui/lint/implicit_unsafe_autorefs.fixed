// check-pass
// run-rustfix
#![allow(dead_code)]
use std::mem::ManuallyDrop;
use std::ptr::{addr_of, addr_of_mut};

unsafe fn test_mut(ptr: *mut [u8]) -> *mut [u8] {
    addr_of_mut!((&mut (*ptr))[..16])
    //~^ warn: implicit auto-ref creates a reference to a dereference of a raw pointer
}

unsafe fn test_const(ptr: *const [u8]) -> *const [u8] {
    addr_of!((&(*ptr))[..16])
    //~^ warn: implicit auto-ref creates a reference to a dereference of a raw pointer
}

struct Test {
    field: [u8],
}

unsafe fn test_field(ptr: *const Test) -> *const [u8] {
    let l = (&(*ptr).field).len();
    //~^ warn: implicit auto-ref creates a reference to a dereference of a raw pointer

    addr_of!((&(*ptr).field)[..l - 1])
    //~^ warn: implicit auto-ref creates a reference to a dereference of a raw pointer
}

unsafe fn test_builtin_index(a: *mut [String]) {
    // built-in (should warn before `.len()`)
    _ = (&(*a)[0]).len();
    //~^ warn: implicit auto-ref creates a reference to a dereference of a raw pointer

    // overloaded (should warn before index)
    _ = (&(*a))[..1][0].len();
    //~^ warn: implicit auto-ref creates a reference to a dereference of a raw pointer
}

unsafe fn test_overloaded_deref_const(ptr: *const ManuallyDrop<Test>) {
    _ = addr_of!((&(*ptr)).field);
    //~^ warn: implicit auto-ref creates a reference to a dereference of a raw pointer
}

unsafe fn test_overloaded_deref_mut(ptr: *mut ManuallyDrop<Test>) {
    _ = addr_of_mut!((&mut (*ptr)).field);
    //~^ warn: implicit auto-ref creates a reference to a dereference of a raw pointer
}

fn main() {}
