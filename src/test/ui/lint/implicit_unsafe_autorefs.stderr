warning: implicit auto-ref creates a reference to a dereference of a raw pointer
  --> $DIR/implicit_unsafe_autorefs.rs:8:18
   |
LL |     addr_of_mut!((*ptr)[..16])
   |                  ^^^^^^
   |
   = note: creating a reference requires the pointer to be valid and imposes aliasing requirements
   = note: a reference is implicitly created because a user-defined indexing operation is being called
   = note: `#[warn(implicit_unsafe_autorefs)]` on by default
help: try using a raw pointer method instead; or if this reference is intentional, make it explicit
   |
LL |     addr_of_mut!((&mut (*ptr))[..16])
   |                  +++++       +

warning: implicit auto-ref creates a reference to a dereference of a raw pointer
  --> $DIR/implicit_unsafe_autorefs.rs:13:14
   |
LL |     addr_of!((*ptr)[..16])
   |              ^^^^^^
   |
   = note: creating a reference requires the pointer to be valid and imposes aliasing requirements
   = note: a reference is implicitly created because a user-defined indexing operation is being called
help: try using a raw pointer method instead; or if this reference is intentional, make it explicit
   |
LL |     addr_of!((&(*ptr))[..16])
   |              ++      +

warning: implicit auto-ref creates a reference to a dereference of a raw pointer
  --> $DIR/implicit_unsafe_autorefs.rs:22:13
   |
LL |     let l = (*ptr).field.len();
   |             ^^^^^^^^^^^^
   |
   = note: creating a reference requires the pointer to be valid and imposes aliasing requirements
   = note: a reference is implicitly created to match the method receiver type
help: try using a raw pointer method instead; or if this reference is intentional, make it explicit
   |
LL |     let l = (&(*ptr).field).len();
   |             ++            +

warning: implicit auto-ref creates a reference to a dereference of a raw pointer
  --> $DIR/implicit_unsafe_autorefs.rs:25:14
   |
LL |     addr_of!((*ptr).field[..l - 1])
   |              ^^^^^^^^^^^^
   |
   = note: creating a reference requires the pointer to be valid and imposes aliasing requirements
   = note: a reference is implicitly created because a user-defined indexing operation is being called
help: try using a raw pointer method instead; or if this reference is intentional, make it explicit
   |
LL |     addr_of!((&(*ptr).field)[..l - 1])
   |              ++            +

warning: implicit auto-ref creates a reference to a dereference of a raw pointer
  --> $DIR/implicit_unsafe_autorefs.rs:31:9
   |
LL |     _ = (*a)[0].len();
   |         ^^^^^^^
   |
   = note: creating a reference requires the pointer to be valid and imposes aliasing requirements
   = note: a reference is implicitly created to match the method receiver type
help: try using a raw pointer method instead; or if this reference is intentional, make it explicit
   |
LL |     _ = (&(*a)[0]).len();
   |         ++       +

warning: implicit auto-ref creates a reference to a dereference of a raw pointer
  --> $DIR/implicit_unsafe_autorefs.rs:35:9
   |
LL |     _ = (*a)[..1][0].len();
   |         ^^^^
   |
   = note: creating a reference requires the pointer to be valid and imposes aliasing requirements
   = note: a reference is implicitly created because a user-defined indexing operation is being called
help: try using a raw pointer method instead; or if this reference is intentional, make it explicit
   |
LL |     _ = (&(*a))[..1][0].len();
   |         ++    +

warning: implicit auto-ref creates a reference to a dereference of a raw pointer
  --> $DIR/implicit_unsafe_autorefs.rs:40:18
   |
LL |     _ = addr_of!((*ptr).field);
   |                  ^^^^^^
   |
   = note: creating a reference requires the pointer to be valid and imposes aliasing requirements
   = note: a reference is implicitly created because a deref coercion is being applied
help: try using a raw pointer method instead; or if this reference is intentional, make it explicit
   |
LL |     _ = addr_of!((&(*ptr)).field);
   |                  ++      +

warning: implicit auto-ref creates a reference to a dereference of a raw pointer
  --> $DIR/implicit_unsafe_autorefs.rs:45:22
   |
LL |     _ = addr_of_mut!((*ptr).field);
   |                      ^^^^^^
   |
   = note: creating a reference requires the pointer to be valid and imposes aliasing requirements
   = note: a reference is implicitly created because a deref coercion is being applied
help: try using a raw pointer method instead; or if this reference is intentional, make it explicit
   |
LL |     _ = addr_of_mut!((&mut (*ptr)).field);
   |                      +++++       +

warning: 8 warnings emitted

