Any constant item, static item, array length expression, or enum
discriminant cannot refer to type parameters.

Erroneous code example:

```compile_fail,E0747
use std::mem::size_of;

fn foo<T>() {
    let _ = [0; size_of::<T>()];
}
```

A workaround for array length expressions is to use [`vec!`] instead, which
does support type parameters in it's length expression, though this does
perform dynamic memory allocation. Example:

```
use std::mem::size_of;

fn foo<T>() {
    let _ = vec![0; size_of::<T>()];
}
```

While enum discriminants cannot refer to regular type parameters, they can still
refer to the `Self` type parameter. Example:

```
#[repr(u8)]
enum Alpha {
    V1 = 41,
    V2 = Self::V1 as u8 + 1,
}
```

Note that associated constants do not have this limitation and can refer to
type parameters. Example:

```
use std::mem::size_of;

trait Foo {
    const X: i32;
}

struct Bar<T>(T);

impl<T> Foo for Bar<T> {
    const X: i32 = size_of::<T>();
}
```

This is currently a limitation with the compiler. These restrictions may be
relaxed in the future, see [issue 43408] for more information.

[`vec!`]: https://doc.rust-lang.org/std/vec/struct.Vec.html
[issue 43408]: https://github.com/rust-lang/rust/issues/43408
