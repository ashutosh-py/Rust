error: calling `.parse()` on a string without trimming the trailing newline character
  --> tests/ui/read_line_without_trim.rs:12:25
   |
LL |     let _x: i32 = input.parse().unwrap();
   |                         ^^^^^^^
   |
note: call to `.read_line()` here, which leaves a trailing newline character in the buffer, which in turn will cause the checking to always fail
  --> tests/ui/read_line_without_trim.rs:11:5
   |
LL |     std::io::stdin().read_line(&mut input).unwrap();
   |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
   = note: `-D clippy::read-line-without-trim` implied by `-D warnings`
   = help: to override `-D warnings` add `#[allow(clippy::read_line_without_trim)]`
help: try
   |
LL |     let _x: i32 = input.trim_end().parse().unwrap();
   |                   ~~~~~~~~~~~~~~~~

error: calling `.parse()` on a string without trimming the trailing newline character
  --> tests/ui/read_line_without_trim.rs:16:20
   |
LL |     let _x = input.parse::<i32>().unwrap();
   |                    ^^^^^^^^^^^^^^
   |
note: call to `.read_line()` here, which leaves a trailing newline character in the buffer, which in turn will cause the checking to always fail
  --> tests/ui/read_line_without_trim.rs:15:5
   |
LL |     std::io::stdin().read_line(&mut input).unwrap();
   |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
help: try
   |
LL |     let _x = input.trim_end().parse::<i32>().unwrap();
   |              ~~~~~~~~~~~~~~~~

error: calling `.parse()` on a string without trimming the trailing newline character
  --> tests/ui/read_line_without_trim.rs:20:20
   |
LL |     let _x = input.parse::<u32>().unwrap();
   |                    ^^^^^^^^^^^^^^
   |
note: call to `.read_line()` here, which leaves a trailing newline character in the buffer, which in turn will cause the checking to always fail
  --> tests/ui/read_line_without_trim.rs:19:5
   |
LL |     std::io::stdin().read_line(&mut input).unwrap();
   |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
help: try
   |
LL |     let _x = input.trim_end().parse::<u32>().unwrap();
   |              ~~~~~~~~~~~~~~~~

error: calling `.parse()` on a string without trimming the trailing newline character
  --> tests/ui/read_line_without_trim.rs:24:20
   |
LL |     let _x = input.parse::<f32>().unwrap();
   |                    ^^^^^^^^^^^^^^
   |
note: call to `.read_line()` here, which leaves a trailing newline character in the buffer, which in turn will cause the checking to always fail
  --> tests/ui/read_line_without_trim.rs:23:5
   |
LL |     std::io::stdin().read_line(&mut input).unwrap();
   |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
help: try
   |
LL |     let _x = input.trim_end().parse::<f32>().unwrap();
   |              ~~~~~~~~~~~~~~~~

error: calling `.parse()` on a string without trimming the trailing newline character
  --> tests/ui/read_line_without_trim.rs:28:20
   |
LL |     let _x = input.parse::<bool>().unwrap();
   |                    ^^^^^^^^^^^^^^^
   |
note: call to `.read_line()` here, which leaves a trailing newline character in the buffer, which in turn will cause the checking to always fail
  --> tests/ui/read_line_without_trim.rs:27:5
   |
LL |     std::io::stdin().read_line(&mut input).unwrap();
   |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
help: try
   |
LL |     let _x = input.trim_end().parse::<bool>().unwrap();
   |              ~~~~~~~~~~~~~~~~

error: comparing a string literal without trimming the trailing newline character
  --> tests/ui/read_line_without_trim.rs:38:8
   |
LL |     if input == "foo" {
   |        ^^^^^^^^^^^^^^
   |
note: call to `.read_line()` here, which leaves a trailing newline character in the buffer, which in turn will cause the comparison to always fail
  --> tests/ui/read_line_without_trim.rs:37:5
   |
LL |     std::io::stdin().read_line(&mut input).unwrap();
   |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
help: try
   |
LL |     if input.trim_end() == "foo" {
   |        ~~~~~~~~~~~~~~~~

error: checking the end of a string without trimming the trailing newline character
  --> tests/ui/read_line_without_trim.rs:44:8
   |
LL |     if input.ends_with("foo") {
   |        ^^^^^^^^^^^^^^^^^^^^^^
   |
note: call to `.read_line()` here, which leaves a trailing newline character in the buffer, which in turn will cause the parsing to always fail
  --> tests/ui/read_line_without_trim.rs:43:5
   |
LL |     std::io::stdin().read_line(&mut input).unwrap();
   |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
help: try
   |
LL |     if input.trim_end().ends_with("foo") {
   |        ~~~~~~~~~~~~~~~~

error: aborting due to 7 previous errors

