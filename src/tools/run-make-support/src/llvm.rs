use std::env;
use std::path::{Path, PathBuf};
use std::process::{Command, Output};
use std::io::{BufReader, Read, Write};
use std::fs::File;

use crate::handle_failed_output;

/// Construct a new `llvm-readobj` invocation. This assumes that `llvm-readobj` is available
/// at `$LLVM_BIN_DIR/llvm-readobj`.
pub fn llvm_readobj() -> LlvmReadobj {
    LlvmReadobj::new()
}

/// Construct a new `llvm-profdata` invocation. This assumes that `llvm-profdata` is available
/// at `$LLVM_BIN_DIR/llvm-profdata`.
pub fn llvm_profdata() -> LlvmProfdata {
    LlvmProfdata::new()
}

/// Construct a new `llvm-filecheck` invocation. This assumes that `llvm-filecheck` is available
/// at `$LLVM_FILECHECK`.
pub fn llvm_filecheck() -> LlvmFilecheck {
    LlvmFilecheck::new()
}

/// A `llvm-readobj` invocation builder.
#[derive(Debug)]
pub struct LlvmReadobj {
    cmd: Command,
}

/// A `llvm-profdata` invocation builder.
#[derive(Debug)]
pub struct LlvmProfdata {
    cmd: Command,
}

/// A `llvm-filecheck` invocation builder.
#[derive(Debug)]
pub struct LlvmFilecheck {
    cmd: Command,
}

crate::impl_common_helpers!(LlvmReadobj);

/// Generate the path to the bin directory of LLVM.
pub fn llvm_bin_dir() -> PathBuf {
    let llvm_bin_dir = env::var("LLVM_BIN_DIR")
    .expect("`LLVM_BIN_DIR` not specified, but this is required to find `llvm-readobj`");
    PathBuf::from(llvm_bin_dir)
}

impl LlvmReadobj {
    /// Construct a new `llvm-readobj` invocation. This assumes that `llvm-readobj` is available
    /// at `$LLVM_BIN_DIR/llvm-readobj`.
    pub fn new() -> Self {
        let llvm_readobj = llvm_bin_dir().join("llvm-readobj");
        let cmd = Command::new(llvm_readobj);
        Self { cmd }
    }

    /// Provide an input file.
    pub fn input<P: AsRef<Path>>(&mut self, path: P) -> &mut Self {
        self.cmd.arg(path.as_ref());
        self
    }

    /// Pass `--file-header` to display file headers.
    pub fn file_header(&mut self) -> &mut Self {
        self.cmd.arg("--file-header");
        self
    }

    /// Get the [`Output`][::std::process::Output] of the finished process.
    #[track_caller]
    pub fn command_output(&mut self) -> Output {
        self.cmd.output().expect("failed to get output of finished process")
    }
}

impl LlvmProfdata {
    /// Construct a new `llvm-profdata` invocation. This assumes that `llvm-profdata` is available
    /// at `$LLVM_BIN_DIR/llvm-profdata`.
    pub fn new() -> Self {
        let llvm_profdata = llvm_bin_dir().join("llvm-profdata");
        let cmd = Command::new(llvm_profdata);
        Self { cmd }
    }

    /// Provide an input file.
    pub fn input<P: AsRef<Path>>(&mut self, path: P) -> &mut Self {
        self.cmd.arg("-o");
        self.cmd.arg(path.as_ref());
        self
    }

    /// Specify the output file path.
    pub fn output<P: AsRef<Path>>(&mut self, path: P) -> &mut Self {
        self.cmd.arg(path.as_ref());
        self
    }

    /// Take several profile data files generated by PGO instrumentation and merge them
    /// together into a single indexed profile data file.
    pub fn merge(&mut self) -> &mut Self {
        self.cmd.arg("merge");
        self
    }

    /// Get the [`Output`][::std::process::Output] of the finished process.
    #[track_caller]
    pub fn command_output(&mut self) -> Output {
        self.cmd.output().expect("failed to get output of finished process")
    }
}

impl LlvmFilecheck {
    /// Construct a new `llvm-filecheck` invocation. This assumes that `llvm-filecheck` is available
    /// at `$LLVM_FILECHECK`.
    pub fn new() -> Self {
        let llvm_filecheck = env::var("LLVM_FILECHECK").expect("LLVM_FILECHECK env var not specified");
        let cmd = Command::new(llvm_filecheck);
        Self { cmd }
    }

    /// Pipe a file into standard input containing patterns that will be matched against the .patterns(path) call.
    pub fn stdin<P: AsRef<Path>>(&mut self, path: P) -> &mut Self {
        let file = File::open(path).unwrap();
        let reader = BufReader::new(file);
        let byte_vec = read_bytes(reader).expect("failed to read bytes of standard input");
        let byte_slice = byte_vec.as_slice();
        self.cmd.stdin(std::process::Stdio::piped());
        let mut child = self.cmd.spawn().unwrap();
        let mut stdin = child.stdin.take().unwrap();
        stdin.write_all(byte_slice).unwrap();
        stdin.flush().unwrap();
        child.wait_with_output().unwrap();
        self
    }

    /// Provide the patterns that need to be matched.
    pub fn patterns<P: AsRef<Path>>(&mut self, path: P) -> &mut Self {
        self.cmd.arg(path.as_ref());
        self
    }
}

fn read_bytes<R: Read>(mut reader: R) -> Result<Vec<u8>, std::io::Error> {
    let mut buffer = Vec::new();
    reader.read_to_end(&mut buffer)?;
    Ok(buffer)
}
