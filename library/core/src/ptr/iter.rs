use crate::fmt::{self, Debug};
use crate::hash::{Hash, Hasher};
use crate::iter::{FusedIterator, TrustedLen, TrustedRandomAccess, TrustedRandomAccessNoCoerce};
use crate::mem;

macro_rules! ptr_iter {
    ($ty:ident, *$mutability:tt T) => {
        /// Iterator with items generated by incrementing a raw pointer.
        ///
        /// # Safety
        ///
        /// Constructing an iterator, as well as dereferencing any pointers
        /// obtained from traversing that iterator, require several invariants
        /// to be upheld by the programmer or else the result is Undefined
        /// Behavior.
        #[doc = concat!("See [`", stringify!($ty), "::new`].")]
        ///
        /// Most importantly, remember that the pointers between the start and
        /// end of a range "remember" the [allocated object] that they refer
        /// into. Pointers resulting from pointer arithmetic must not be used to
        /// read or write to any other allocated object.
        ///
        /// As a consequence, pointers from a traversal of this iterator are
        /// only dereferenceable if the `start` and `end` with which the
        /// iterator was constructed both point into the same allocated object.
        /// Dereferencing a pointer obtained via iteration when this is not the
        /// case is Undefined Behavior.
        ///
        /// [allocated object]: crate::ptr#allocated-object
        ///
        /// # Alignment
        ///
        /// All the pointers in the iterator are at offsets of multiples of
        /// `size_of::<T>()` bytes from the iterator's start, so if the
        /// iterator's starting pointer is misaligned, then all the pointers in
        /// the iterator are misaligned as well.
        ///
        /// # Example
        ///
        #[doc = example!($mutability,
        const {
            /// ```
            /// #![feature(ptr_iter)]
            ///
            /// use core::ptr;
            ///
            /// // Designed to be called from C++ or C.
            /// #[no_mangle]
            /// unsafe extern "C" fn demo(start: *const u16, end: *const u16) {
            ///     for ptr in ptr::IterConst::new(start, end) {
            ///         println!("{}", *ptr);
            ///     }
            /// }
            ///
            /// fn main() {
            ///     let slice = &[1u16, 2, 3];
            ///     let range = slice.as_ptr_range();
            ///     unsafe { demo(range.start, range.end); }
            /// }
            /// ```
        }
        mut {
            /// ```
            /// #![feature(ptr_iter)]
            /// #![feature(vec_spare_capacity)]
            ///
            /// use core::ptr;
            ///
            /// // Designed to be called from C++ or C.
            /// #[no_mangle]
            /// unsafe extern "C" fn demo(start: *mut u16, end: *mut u16) {
            ///     for (i, ptr) in ptr::IterMut::new(start, end).enumerate() {
            ///         ptr::write(ptr, i as u16);
            ///     }
            /// }
            ///
            /// fn main() {
            ///     let mut vec: Vec<u16> = Vec::with_capacity(100);
            ///     let range = vec.spare_capacity_mut().as_mut_ptr_range();
            ///     unsafe {
            ///         demo(range.start.cast::<u16>(), range.end.cast::<u16>());
            ///         vec.set_len(100);
            ///     }
            /// }
            /// ```
        })]
        #[unstable(feature = "ptr_iter", issue = "none")]
        pub struct $ty<T> {
            start: *$mutability T,
            end: *$mutability T,
        }

        impl<T> $ty<T> {
            /// Creates an iterator with functionality analogous to:
            ///
            /// ```
            /// # let start = core::ptr::null::<()>();
            /// # let end = start;
            /// #
            /// let mut item = start;
            /// while item < end {
            ///     // ... do thing with item
            ///
            ///     item = unsafe { item.offset(1) };
            /// }
            /// ```
            ///
            /// # Safety
            ///
            /// If any of the following conditions are violated, the result is
            /// Undefined Behavior:
            ///
            /// * Both the `start` and `end` pointer must be either in bounds or
            ///   one byte past the end of the same [allocated object].
            ///
            /// * Both pointers must be *derived from* a pointer to the same
            ///   object. (See [pointer::offset_from] for an example.)
            ///
            /// * `null::<T>() < start <= end`.
            ///
            /// * If `T`'s size is positive, then the distance between the
            ///   pointers, in bytes, must be an exact multiple of the size of
            ///   `T`.
            ///
            /// * The distance between the pointers, **in bytes**, cannot
            ///   overflow an `isize`.
            ///
            /// Rust types are never larger than `isize::MAX`, so two pointers
            /// within some value of any Rust type will always satisfy the last
            /// condition. The standard library also generally ensures that
            /// allocations never reach a size where an offset is a concern. For
            /// instance, `Vec` and `Box` ensure they never allocate more than
            /// `isize::MAX` bytes, so the pointers from `vec.as_ptr_range()`
            /// always satisfies the last condition.
            ///
            /// Most platforms fundamentally can't even construct such a large
            /// allocation. For instance, no known 64-bit platform can ever
            /// serve a request for 2<sup>63</sup> bytes due to page-table
            /// limitations or splitting the address space. However, some 32-bit
            /// and 16-bit platforms may successfully serve a request for more
            /// than `isize::MAX` bytes with things like Physical Address
            /// Extension. As such, memory acquired directly from allocators or
            /// memory mapped files *may* be too large to handle with this
            /// iterator. (Note that [`offset`] and [`add`] also have a similar
            /// limitation and hence cannot be used on such large allocations
            /// either.)
            ///
            /// While not a requirement of this constructor call, dereferencing
            /// any of the pointers obtained through iteration of this iterator
            /// requires that `start` have been constructed with provenance over
            /// that memory location. All the pointers produced by the iterator
            /// have the same provenance as `start`.
            ///
            #[doc = example!($mutability,
            const {
                /// ```no_run
                /// #![feature(ptr_iter)]
                ///
                /// use core::ptr;
                ///
                /// let slice = &[0i32, 1, 2, 3];
                /// let start: *const i32 = &slice[0];  // provenance over slice[0] only
                /// let end = unsafe { start.offset(4) };
                ///
                /// for p in unsafe { ptr::IterConst::new(start, end) } {  // UB ðŸ’¥
                ///     println!("{}", unsafe { *p });
                /// }
                /// ```
            }
            mut {
                /// ```no_run
                /// #![feature(ptr_iter)]
                ///
                /// use core::ptr;
                ///
                /// let slice = &mut [0i32, 1, 2, 3];
                /// let start: *mut i32 = &mut slice[0];  // provenance over slice[0] only
                /// let end = unsafe { start.offset(4) };
                ///
                /// for p in unsafe { ptr::IterMut::new(start, end) } {
                ///     unsafe { *p = 99; }
                /// }
                /// ```
            })]
            ///
            /// Correct code would instead have used:
            ///
            #[doc = example!($mutability,
            const {
                /// ```
                /// # let slice = &[0i32, 1, 2, 3];
                /// let start = slice.as_ptr();
                /// ```
            }
            mut {
                /// ```
                /// # let slice = &mut [0i32, 1, 2, 3];
                /// let start = slice.as_mut_ptr();
                /// ```
            })]
            ///
            /// or:
            ///
            #[doc = example!($mutability,
            const {
                /// ```
                /// use core::ops::Range;
                ///
                /// # let slice = &[0i32, 1, 2, 3];
                /// let Range { start, end } = slice.as_ptr_range();
                /// ```
            }
            mut {
                /// ```
                /// use core::ops::Range;
                ///
                /// # let slice = &mut [0i32, 1, 2, 3];
                /// let Range { start, end } = slice.as_mut_ptr_range();
                /// ```
            })]
            ///
            /// [allocated object]: crate::ptr#allocated-object
            /// [`offset`]: pointer::offset
            /// [`add`]: pointer::add
            #[unstable(feature = "ptr_iter", issue = "none")]
            pub unsafe fn new(start: *$mutability T, end: *$mutability T) -> Self {
                $ty { start, end }
            }

            /// Returns true if the iterator has no pointers remaining in it.
            ///
            /// # Example
            ///
            #[doc = example!($mutability,
            const {
                /// ```
                /// #![feature(ptr_iter)]
                ///
                /// use core::ptr;
                ///
                /// let slice = &[0i32, 1, 2, 3];
                /// let start = slice.as_ptr();
                /// let end = unsafe { start.offset(2) };
                ///
                /// let mut iter = unsafe { ptr::IterConst::new(start, end) };
                /// assert!(!iter.is_empty());
                /// assert_eq!(unsafe { *iter.next().unwrap() }, 0);
                /// assert!(!iter.is_empty());
                /// assert_eq!(unsafe { *iter.next().unwrap() }, 1);
                /// assert!(iter.is_empty());
                /// assert_eq!(iter.next(), None);
                /// ```
            }
            mut {
                /// ```
                /// #![feature(ptr_iter)]
                ///
                /// use core::ptr;
                ///
                /// let slice = &mut [0i32, 1, 2, 3];
                /// let start = slice.as_mut_ptr();
                /// let end = unsafe { start.offset(2) };
                ///
                /// let mut iter = unsafe { ptr::IterMut::new(start, end) };
                /// assert!(!iter.is_empty());
                /// unsafe { *iter.next().unwrap() = 99; }
                /// assert!(!iter.is_empty());
                /// unsafe { *iter.next().unwrap() = 99; }
                /// assert!(iter.is_empty());
                /// assert_eq!(iter.next(), None);
                /// assert_eq!(slice, &[99, 99, 2, 3]);
                /// ```
            })]
            #[unstable(feature = "ptr_iter", issue = "none")]
            pub fn is_empty(&self) -> bool {
                !(self.start < self.end)
            }
        }

        #[unstable(feature = "ptr_iter", issue = "none")]
        impl<T> Iterator for $ty<T> {
            type Item = *$mutability T;

            fn next(&mut self) -> Option<Self::Item> {
                if self.is_empty() {
                    None
                } else {
                    let curr = self.start;
                    // SAFETY: `new`'s extensive precondition allows us to do
                    // this until the iterator becomes exhausted.
                    self.start = unsafe { curr.offset(1) };
                    Some(curr)
                }
            }

            fn size_hint(&self) -> (usize, Option<usize>) {
                if self.is_empty() {
                    (0, Some(0))
                } else if mem::size_of::<T>() == 0 {
                    // T is zero sized so there are infinity of them in the
                    // nonempty range.
                    (usize::MAX, None)
                } else {
                    // SAFETY: `new`'s extensive precondition allows us to do this.
                    let hint = unsafe { self.end.offset_from(self.start) } as usize;
                    (hint, Some(hint))
                }
            }

            fn nth(&mut self, n: usize) -> Option<Self::Item> {
                let _ = self.advance_by(n);
                self.next()
            }

            fn last(mut self) -> Option<Self::Item> {
                self.next_back()
            }

            fn min(mut self) -> Option<Self::Item> {
                self.next()
            }

            fn max(mut self) -> Option<Self::Item> {
                self.next_back()
            }

            fn is_sorted(self) -> bool {
                true
            }

            fn advance_by(&mut self, n: usize) -> Result<(), usize> {
                match self.size_hint().1 {
                    None => {
                        // T is zero sized. Advancing does nothing.
                        Ok(())
                    }
                    Some(len) => {
                        if n <= len {
                            // SAFETY: `start` remains at most equal to `end`
                            // which is in bounds or one byte past the end of
                            // the same allocated object according to the
                            // preconditions of `new`.
                            self.start = unsafe { self.start.add(n) };
                            Ok(())
                        } else {
                            self.start = self.end;
                            Err(len)
                        }
                    }
                }
            }

            #[doc(hidden)]
            unsafe fn __iterator_get_unchecked(&mut self, idx: usize) -> Self::Item {
                // SAFETY: TrustedRandomAccess guarantees that there are enough
                // remaining items in the iterator, so this offset lands
                // somewhere in between self.start and self.end.
                unsafe { self.start.add(idx) }
            }
        }

        #[unstable(feature = "ptr_iter", issue = "none")]
        impl<T> DoubleEndedIterator for $ty<T> {
            fn next_back(&mut self) -> Option<Self::Item> {
                match self.size_hint().1 {
                    None => {
                        // T is zero sized so the iterator never progresses past
                        // start, even if going backwards.
                        Some(self.start)
                    }
                    Some(0) => {
                        None
                    }
                    Some(len) => {
                        // Advance leaving `len - 1` elements in the iterator.
                        //
                        // SAFETY: this pointer remains in between `start` and
                        // `end` which is in bounds of the same allocated object
                        // according to the preconditions of `new`.
                        self.end = unsafe { self.start.add(len - 1) };
                        Some(self.end)
                    }
                }
            }

            fn nth_back(&mut self, n: usize) -> Option<Self::Item> {
                match self.size_hint().1 {
                    None => {
                        // T is zero sized.
                        Some(self.start)
                    }
                    Some(len) => {
                        if n < len {
                            // Advance leaving `len - n - 1` elements in the
                            // iterator.
                            //
                            // SAFETY: this pointer remains in between `start`
                            // and `end` which is in bounds of the same
                            // allocated object according to the preconditions
                            // of `new`.
                            self.end = unsafe { self.start.add(len - n - 1) };
                            Some(self.end)
                        } else {
                            self.end = self.start;
                            None
                        }
                    }
                }
            }

            fn advance_back_by(&mut self, n: usize) -> Result<(), usize> {
                match self.size_hint().1 {
                    None => {
                        // T is zero sized. Advancing does nothing.
                        Ok(())
                    }
                    Some(len) => {
                        if n <= len {
                            // Advance leaving `len - n` elements in the
                            // iterator.
                            //
                            // SAFETY: this pointer remains in between `start`
                            // and `end` which is in bounds of the same
                            // allocated object according to the preconditions
                            // of `new`.
                            self.end = unsafe { self.start.add(len - n) };
                            Ok(())
                        } else {
                            // Advance too far.
                            self.end = self.start;
                            Err(len)
                        }
                    }
                }
            }
        }

        #[unstable(feature = "ptr_iter", issue = "none")]
        impl<T> FusedIterator for $ty<T> {}

        #[unstable(feature = "trusted_len", issue = "37572")]
        unsafe impl<T> TrustedLen for $ty<T> {}

        #[doc(hidden)]
        #[unstable(feature = "trusted_random_access", issue = "none")]
        unsafe impl<T> TrustedRandomAccess for $ty<T> {}

        #[doc(hidden)]
        #[unstable(feature = "trusted_random_access", issue = "none")]
        unsafe impl<T> TrustedRandomAccessNoCoerce for $ty<T> {
            const MAY_HAVE_SIDE_EFFECT: bool = false;
        }

        // not Copy -- see #27186
        #[unstable(feature = "ptr_iter", issue = "none")]
        impl<T> Clone for $ty<T> {
            fn clone(&self) -> Self {
                $ty {
                    start: self.start,
                    end: self.end,
                }
            }
        }

        #[unstable(feature = "ptr_iter", issue = "none")]
        impl<T> PartialEq for $ty<T> {
            fn eq(&self, other: &Self) -> bool {
                self.start == other.start && self.end == other.end
            }
        }

        #[unstable(feature = "ptr_iter", issue = "none")]
        impl<T> Eq for $ty<T> {}

        #[unstable(feature = "ptr_iter", issue = "none")]
        impl<T> Hash for $ty<T> {
            fn hash<H: Hasher>(&self, state: &mut H) {
                self.start.hash(state);
                self.end.hash(state);
            }
        }

        #[unstable(feature = "ptr_iter", issue = "none")]
        impl<T> Debug for $ty<T> {
            fn fmt(&self, formatter: &mut fmt::Formatter<'_>) -> fmt::Result {
                formatter
                    .debug_struct(stringify!($ty))
                    .field("start", &self.start)
                    .field("end", &self.end)
                    .finish()
            }
        }
    };
}

macro_rules! example {
    (const, const { $($doc:tt)* } mut $unused:tt) => {
        doc_comment_to_literal!($($doc)*)
    };

    (mut, const $unused:tt mut { $($doc:tt)* }) => {
        doc_comment_to_literal!($($doc)*)
    };
}

macro_rules! doc_comment_to_literal {
    ($(#[doc = $example:literal])*) => {
        concat!($($example, '\n'),*)
    };
}

ptr_iter!(IterConst, *const T);
ptr_iter!(IterMut, *mut T);
