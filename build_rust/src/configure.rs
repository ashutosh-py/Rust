// Copyright 2013-2015 The Rust Project Developers. See the COPYRIGHT
// file at the top-level directory of this distribution and at
// http://rust-lang.org/COPYRIGHT.
//
// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or
// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license
// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your
// option. This file may not be copied, modified, or distributed
// except according to those terms.

//! Set build variables from the command line and inspect build
//! environment.
//!
//! For a general description of the build pipeline, see main.rs

// Include the build_env.rs file generated by build.rs
include!(concat!(env!("OUT_DIR"), "/build_env.rs"));

use std::process::Command;
use std::path::PathBuf;
use std::ffi::OsString;
use std::env;
use std::str::from_utf8;
use build_state::*;
use cmd_args::*;
use llvm::{LLVMBuildType, LLVMTools};
use cc::Triple;
use log::Logger;

/// Build variables collected from the command line arguments
/// and the build environment.
pub struct ConfigArgs {
    build_triple : Triple,
    host_triple : Triple,
    target_triples : Vec<Triple>,
    llvm_build_type : LLVMBuildType,
    cmd_args : CmdArgs
}

impl ConfigArgs {
    /// Get the git hash for the HEAD commit in the source repo.
    /// This is used to append the `extra-filename` argument to rustc.
    /// TODO: For build from a tarball release, we should supply
    /// a fixed git hash.
    pub fn get_git_hash(&self) -> String {
        Command::new("git").current_dir(self.rustc_root_dir())
            .arg("rev-parse").arg("--short").arg("HEAD").output()
            .map_err(|e| format!("{}", e))
            .and_then(|output| from_utf8(&output.stdout)
                      .map(|s| s.trim().into())
                      .map_err(|e| format!("{}", e)))
            .unwrap_or("0000000".into())
    }

    /// Root directory for the rustc repo. This can be overridden
    /// from the command line. Note user may provide a relative path,
    /// in which case we prepend the current dir to it.
    pub fn rustc_root_dir(&self) -> PathBuf {
        if let Some(ref dir) = self.cmd_args.rustc_root_dir {
            let mut src_dir = env::current_dir().unwrap();
            src_dir.push(&dir);
            src_dir
        } else {
            PathBuf::from(MANIFEST_DIR).parent()
                .expect("MANIFEST_DIR has no parent directory.").into()
        }
    }

    pub fn src_dir(&self) -> PathBuf {
        self.rustc_root_dir().join("src")
    }

    /// All build artifacts are written into the toplevel build
    /// directory, which by default is the same directory as the
    /// Cargo manifest of this package.
    pub fn toplevel_build_dir(&self) -> PathBuf {
        if let Some(ref dir) = self.cmd_args.build_dir {
            let mut build_dir = env::current_dir().unwrap();
            build_dir.push(&dir); // see comment in rustc_root_dir()
            build_dir
        } else {
            PathBuf::from(MANIFEST_DIR)
        }
    }

    /// All build artifacts belonging to a particular target triple
    /// are written into <toplevel-build-dir>/<target-triple>
    pub fn target_build_dir(&self, triple : &Triple) -> PathBuf {
        self.toplevel_build_dir().join(triple)
    }

    /// Triple of the build machine.
    pub fn build_triple(&self) -> &Triple {
        &self.build_triple
    }

    /// Host triple of the stage2 compiler
    pub fn host_triple(&self) -> &Triple {
        &self.host_triple
    }

    /// Target triples for which the stage2 libraries will be built
    pub fn target_triples(&self) -> &[Triple] {
        &self.target_triples
    }

    /// See `mod llvm`.
    pub fn llvm_build_type(&self) -> LLVMBuildType {
        self.llvm_build_type
    }

    /// See `mod llvm`.
    pub fn llvm_tools(&self, target : &Triple) -> LLVMTools {
        LLVMTools::new(self, target)
    }

    pub fn is_debug_build(&self) -> bool {
        self.cmd_args.enable_debug_build
    }

    /// Use the rustc in the local $PATH as the stage0 compiler
    /// instead of the stage0 snapshot.
    pub fn use_local_rustc(&self) -> bool {
        self.cmd_args.use_local_rustc
    }

    /// Indicate whether we should clean the build directory.
    /// We won't if either --no-reconfigure-llvm,
    /// --no-rebuild-llvm or --no-bootstrap is supplied.
    pub fn no_clean_build(&self) -> bool {
        self.cmd_args.no_clean_build || self.no_reconfigure_llvm()
            || self.no_rebuild_llvm() || self.no_bootstrap()
    }

    pub fn no_reconfigure_llvm(&self) -> bool {
        self.cmd_args.no_reconfigure_llvm
            || self.no_rebuild_llvm() || self.no_bootstrap()
    }

    pub fn no_rebuild_llvm(&self) -> bool {
        self.cmd_args.no_rebuild_llvm || self.no_bootstrap()
    }

    /// See `mod rust`
    pub fn no_bootstrap(&self) -> bool {
        self.cmd_args.no_bootstrap
    }

    /// Number of parallel jobs to run during build. Default to 1.
    pub fn jnproc(&self) -> OsString {
        if let Some(n) = self.cmd_args.nproc {
            format!("-j{}", n).into()
        } else {
            "-j1".into()
        }
    }

    /// See `mod log`.
    pub fn get_logger(&self, triple : &Triple, prog : &str) -> Logger {
        let build_dir = self.target_build_dir(triple);
        let stdout = build_dir.join("log")
            .join(format!("{}.stdout.log", prog));
        let stderr = build_dir.join("log")
            .join(format!("{}.stderr.log", prog));
        Logger::new(stdout, stderr, triple.into(), prog.into(),
                    self.cmd_args.verbose)
    }
}

fn get_config_args(cmd_args : CmdArgs) -> BuildState<ConfigArgs> {
    let build_triple = try!(Triple::new(BUILD_TRIPLE));
    let host_triple = match cmd_args.host_triple {
        None => build_triple.clone(),
        Some(ref t) => try!(Triple::new(t))
    };
    let mut target_triples = vec![ host_triple.clone() ];
    for triple in &cmd_args.target_triples {
        target_triples.push(try!(Triple::new(triple)));
    }
    let llvm_build_type =
        if cmd_args.enable_debug_build {
            if cmd_args.disable_llvm_assertions {
                LLVMBuildType::DebugNoAsserts
            } else {
                LLVMBuildType::Debug
            }
        } else if cmd_args.enable_llvm_assertions {
            LLVMBuildType::ReleaseAsserts
        } else {
            LLVMBuildType::Release
        };
    continue_with(ConfigArgs {
        build_triple : build_triple,
        host_triple : host_triple,
        target_triples : target_triples,
        llvm_build_type : llvm_build_type,
        cmd_args : cmd_args
    })
}

fn check_prog(prog : &str) -> BuildState<()> {
    println!("Looking for {}...", prog);
    let _ = try!(Command::new(prog).output());
    continue_build()
}

fn check_python_version() -> BuildState<()> {
    use regex::Regex;
    println!("Checking if python --version >= 2.7 ...");
    let output = try!(Command::new("python").arg("--version").output());
    let out_str = try!(String::from_utf8(output.stderr));
    let re = try!(Regex::new(r"Python (\d+)\.(\d+)\.(\d+)"));
    let err_msg = "Python 2.7 or newer is required.";
    let cap = try!(re.captures(&out_str).ok_or(err_msg.to_string()));
    let major_version = try!(try!(
        cap.at(1).ok_or(err_msg.to_string())).parse::<u8>());
    let minor_version = try!(try!(
        cap.at(2).ok_or(err_msg.to_string())).parse::<u8>());
    if (major_version == 2 && minor_version >= 7) || major_version >= 3 {
        continue_build()
    } else {
        err_stop(err_msg)
    }
}

fn check_build_prereq(_ : &ConfigArgs) -> BuildState<()> {
    println!("Checking build prerequisite...");
    try!(check_prog("cmake"));
    try!(check_prog("git"));
    try!(check_prog("curl"));
    try!(check_prog("tar"));
    try!(check_prog("bzip2"));
    try!(check_prog("python"));
    try!(check_python_version());
    // TODO: Check toolchain availability
    continue_build()
}

fn clean_build_dirs(args : &ConfigArgs) -> BuildState<()> {
    use std::fs::remove_dir_all;
    println!("Removing old build directories...");
    for triple in args.target_triples() {
        let _ = remove_dir_all(args.target_build_dir(triple));
    }
    continue_build()
}

fn create_build_dirs(args : &ConfigArgs) -> BuildState<()> {
    use std::fs::create_dir_all;
    println!("Creating build directories...");
    let dirs = vec![ "llvm", "log", "rt" ];
    for d in &dirs {
        let bld = args.target_build_dir(args.build_triple());
        let hst = args.target_build_dir(args.host_triple());
        let _ = create_dir_all(hst.join(d));
        let _ = create_dir_all(bld.join(d));
    }
    continue_build()
}

fn check_src_dir(args : &ConfigArgs) -> BuildState<()> {
    use std::fs::read_dir;
    let libsyntax_dir = args.src_dir().join("libsyntax");
    if read_dir(&libsyntax_dir).is_err() {
        err_stop!("{:?} does not appear to contain rustc source code. Use --rustc-root=DIR to specify the rustc root directory.",
                  &args.src_dir());
    }
    continue_build()
}

/// Perform the configure step and return the build variables.
pub fn configure() -> BuildState<ConfigArgs> {
    let cmd_args = try!(parse_cmd_args());
    if !cmd_args.verbose {
        println!("Building in quiet mode. Use --verbose for more loggings.");
    }
    let config_args = try!(get_config_args(cmd_args));
    try!(check_build_prereq(&config_args));
    try!(check_src_dir(&config_args));
    if !config_args.no_clean_build() {
        try!(clean_build_dirs(&config_args));
    }
    try!(create_build_dirs(&config_args));
    continue_with(config_args)
}
